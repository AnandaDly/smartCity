/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ let e, t, i, n, r, s, a, o, l, h, c, u, d;
const p = { ROTATE: 0, DOLLY: 1, PAN: 2 },
  m = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  f = "attached",
  g = "srgb",
  _ = "srgb-linear",
  v = "display-p3",
  x = "display-p3-linear",
  y = "linear",
  M = "srgb",
  S = "rec709",
  b = "300 es";
class T {
  addEventListener(e, t) {
    void 0 === this._listeners && (this._listeners = {});
    let i = this._listeners;
    void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (void 0 === this._listeners) return !1;
    let i = this._listeners;
    return void 0 !== i[e] && -1 !== i[e].indexOf(t);
  }
  removeEventListener(e, t) {
    if (void 0 === this._listeners) return;
    let i = this._listeners[e];
    if (void 0 !== i) {
      let e = i.indexOf(t);
      -1 !== e && i.splice(e, 1);
    }
  }
  dispatchEvent(e) {
    if (void 0 === this._listeners) return;
    let t = this._listeners[e.type];
    if (void 0 !== t) {
      e.target = this;
      let i = t.slice(0);
      for (let t = 0, n = i.length; t < n; t++) i[t].call(this, e);
      e.target = null;
    }
  }
}
const E = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let w = 1234567;
const A = Math.PI / 180,
  R = 180 / Math.PI;
function C() {
  let e = (4294967295 * Math.random()) | 0,
    t = (4294967295 * Math.random()) | 0,
    i = (4294967295 * Math.random()) | 0,
    n = (4294967295 * Math.random()) | 0;
  return (
    E[255 & e] +
    E[(e >> 8) & 255] +
    E[(e >> 16) & 255] +
    E[(e >> 24) & 255] +
    "-" +
    E[255 & t] +
    E[(t >> 8) & 255] +
    "-" +
    E[((t >> 16) & 15) | 64] +
    E[(t >> 24) & 255] +
    "-" +
    E[(63 & i) | 128] +
    E[(i >> 8) & 255] +
    "-" +
    E[(i >> 16) & 255] +
    E[(i >> 24) & 255] +
    E[255 & n] +
    E[(n >> 8) & 255] +
    E[(n >> 16) & 255] +
    E[(n >> 24) & 255]
  ).toLowerCase();
}
function P(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function L(e, t) {
  return ((e % t) + t) % t;
}
function N(e, t, i) {
  return (1 - i) * e + i * t;
}
function I(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint32Array:
      return e / 4294967295;
    case Uint16Array:
      return e / 65535;
    case Uint8Array:
      return e / 255;
    case Int32Array:
      return Math.max(e / 2147483647, -1);
    case Int16Array:
      return Math.max(e / 32767, -1);
    case Int8Array:
      return Math.max(e / 127, -1);
    default:
      throw Error("Invalid component type.");
  }
}
function D(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint32Array:
      return Math.round(4294967295 * e);
    case Uint16Array:
      return Math.round(65535 * e);
    case Uint8Array:
      return Math.round(255 * e);
    case Int32Array:
      return Math.round(2147483647 * e);
    case Int16Array:
      return Math.round(32767 * e);
    case Int8Array:
      return Math.round(127 * e);
    default:
      throw Error("Invalid component type.");
  }
}
const O = {
  DEG2RAD: A,
  RAD2DEG: R,
  generateUUID: C,
  clamp: P,
  euclideanModulo: L,
  mapLinear: function (e, t, i, n, r) {
    return n + ((e - t) * (r - n)) / (i - t);
  },
  inverseLerp: function (e, t, i) {
    return e !== t ? (i - e) / (t - e) : 0;
  },
  lerp: N,
  damp: function (e, t, i, n) {
    return N(e, t, 1 - Math.exp(-i * n));
  },
  pingpong: function (e, t = 1) {
    return t - Math.abs(L(e, 2 * t) - t);
  },
  smoothstep: function (e, t, i) {
    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e);
  },
  smootherstep: function (e, t, i) {
    return e <= t
      ? 0
      : e >= i
      ? 1
      : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10);
  },
  randInt: function (e, t) {
    return e + Math.floor(Math.random() * (t - e + 1));
  },
  randFloat: function (e, t) {
    return e + Math.random() * (t - e);
  },
  randFloatSpread: function (e) {
    return e * (0.5 - Math.random());
  },
  seededRandom: function (e) {
    void 0 !== e && (w = e);
    let t = (w += 1831565813);
    return (
      (t = Math.imul(t ^ (t >>> 15), 1 | t)),
      (((t ^= t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ (t >>> 14)) >>> 0) /
        4294967296
    );
  },
  degToRad: function (e) {
    return e * A;
  },
  radToDeg: function (e) {
    return e * R;
  },
  isPowerOfTwo: function (e) {
    return (e & (e - 1)) == 0 && 0 !== e;
  },
  ceilPowerOfTwo: function (e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
  },
  floorPowerOfTwo: function (e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (e, t, i, n, r) {
    let s = Math.cos,
      a = Math.sin,
      o = s(i / 2),
      l = a(i / 2),
      h = s((t + n) / 2),
      c = a((t + n) / 2),
      u = s((t - n) / 2),
      d = a((t - n) / 2),
      p = s((n - t) / 2),
      m = a((n - t) / 2);
    switch (r) {
      case "XYX":
        e.set(o * c, l * u, l * d, o * h);
        break;
      case "YZY":
        e.set(l * d, o * c, l * u, o * h);
        break;
      case "ZXZ":
        e.set(l * u, l * d, o * c, o * h);
        break;
      case "XZX":
        e.set(o * c, l * m, l * p, o * h);
        break;
      case "YXY":
        e.set(l * p, o * c, l * m, o * h);
        break;
      case "ZYZ":
        e.set(l * m, l * p, o * c, o * h);
        break;
      default:
        console.warn(
          "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
            r
        );
    }
  },
  normalize: D,
  denormalize: I,
};
class U {
  constructor(e = 0, t = 0) {
    (U.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    let t = this.x,
      i = this.y,
      n = e.elements;
    return (
      (this.x = n[0] * t + n[3] * i + n[6]),
      (this.y = n[1] * t + n[4] * i + n[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    let i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    let t = Math.sqrt(this.lengthSq() * e.lengthSq());
    return 0 === t ? Math.PI / 2 : Math.acos(P(this.dot(e) / t, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    let t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    let i = Math.cos(t),
      n = Math.sin(t),
      r = this.x - e.x,
      s = this.y - e.y;
    return (this.x = r * i - s * n + e.x), (this.y = r * n + s * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class z {
  constructor(e, t, i, n, r, s, a, o, l) {
    (z.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      void 0 !== e && this.set(e, t, i, n, r, s, a, o, l);
  }
  set(e, t, i, n, r, s, a, o, l) {
    let h = this.elements;
    return (
      (h[0] = e),
      (h[1] = n),
      (h[2] = a),
      (h[3] = t),
      (h[4] = r),
      (h[5] = o),
      (h[6] = i),
      (h[7] = s),
      (h[8] = l),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    let t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    let t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    let i = e.elements,
      n = t.elements,
      r = this.elements,
      s = i[0],
      a = i[3],
      o = i[6],
      l = i[1],
      h = i[4],
      c = i[7],
      u = i[2],
      d = i[5],
      p = i[8],
      m = n[0],
      f = n[3],
      g = n[6],
      _ = n[1],
      v = n[4],
      x = n[7],
      y = n[2],
      M = n[5],
      S = n[8];
    return (
      (r[0] = s * m + a * _ + o * y),
      (r[3] = s * f + a * v + o * M),
      (r[6] = s * g + a * x + o * S),
      (r[1] = l * m + h * _ + c * y),
      (r[4] = l * f + h * v + c * M),
      (r[7] = l * g + h * x + c * S),
      (r[2] = u * m + d * _ + p * y),
      (r[5] = u * f + d * v + p * M),
      (r[8] = u * g + d * x + p * S),
      this
    );
  }
  multiplyScalar(e) {
    let t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    let e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      r = e[3],
      s = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      h = e[8];
    return (
      t * s * h - t * a * l - i * r * h + i * a * o + n * r * l - n * s * o
    );
  }
  invert() {
    let e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      r = e[3],
      s = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      h = e[8],
      c = h * s - a * l,
      u = a * o - h * r,
      d = l * r - s * o,
      p = t * c + i * u + n * d;
    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    let m = 1 / p;
    return (
      (e[0] = c * m),
      (e[1] = (n * l - h * i) * m),
      (e[2] = (a * i - n * s) * m),
      (e[3] = u * m),
      (e[4] = (h * t - n * o) * m),
      (e[5] = (n * r - a * t) * m),
      (e[6] = d * m),
      (e[7] = (i * o - l * t) * m),
      (e[8] = (s * t - i * r) * m),
      this
    );
  }
  transpose() {
    let e;
    let t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    let t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, n, r, s, a) {
    let o = Math.cos(r),
      l = Math.sin(r);
    return (
      this.set(
        i * o,
        i * l,
        -i * (o * s + l * a) + s + e,
        -n * l,
        n * o,
        -n * (-l * s + o * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(F.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(F.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(F.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    let t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    let t = this.elements,
      i = e.elements;
    for (let e = 0; e < 9; e++) if (t[e] !== i[e]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    let i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const F = new z();
function B(e) {
  for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0;
  return !1;
}
function k(e) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", e);
}
Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array;
const H = {};
function V(e) {
  e in H || ((H[e] = !0), console.warn(e));
}
const G = new z().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  W = new z().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  X = {
    [_]: {
      transfer: y,
      primaries: S,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (e) => e,
      fromReference: (e) => e,
    },
    [g]: {
      transfer: M,
      primaries: S,
      luminanceCoefficients: [0.2126, 0.7152, 0.0722],
      toReference: (e) => e.convertSRGBToLinear(),
      fromReference: (e) => e.convertLinearToSRGB(),
    },
    [x]: {
      transfer: y,
      primaries: "p3",
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (e) => e.applyMatrix3(W),
      fromReference: (e) => e.applyMatrix3(G),
    },
    [v]: {
      transfer: M,
      primaries: "p3",
      luminanceCoefficients: [0.2289, 0.6917, 0.0793],
      toReference: (e) => e.convertSRGBToLinear().applyMatrix3(W),
      fromReference: (e) => e.applyMatrix3(G).convertLinearToSRGB(),
    },
  },
  j = new Set([_, x]),
  q = {
    enabled: !0,
    _workingColorSpace: _,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(colorSpace) {
      if (!j.has(colorSpace))
        throw Error(`Unsupported working color space, "${colorSpace}".`);
      this._workingColorSpace = colorSpace;
    },
    convert: function (e, t, i) {
      if (!1 === this.enabled || t === i || !t || !i) return e;
      let n = X[t].toReference;
      return (0, X[i].fromReference)(n(e));
    },
    fromWorkingColorSpace: function (e, t) {
      return this.convert(e, this._workingColorSpace, t);
    },
    toWorkingColorSpace: function (e, t) {
      return this.convert(e, t, this._workingColorSpace);
    },
    getPrimaries: function (e) {
      return X[e].primaries;
    },
    getTransfer: function (e) {
      return "" === e ? y : X[e].transfer;
    },
    getLuminanceCoefficients: function (e, t = this._workingColorSpace) {
      return e.fromArray(X[t].luminanceCoefficients);
    },
  };
function J(e) {
  return e < 0.04045
    ? 0.0773993808 * e
    : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
}
function Y(e) {
  return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
class K {
  static getDataURL(t) {
    let i;
    if (/^data:/i.test(t.src) || "undefined" == typeof HTMLCanvasElement)
      return t.src;
    if (t instanceof HTMLCanvasElement) i = t;
    else {
      void 0 === e && (e = k("canvas")),
        (e.width = t.width),
        (e.height = t.height);
      let n = e.getContext("2d");
      t instanceof ImageData
        ? n.putImageData(t, 0, 0)
        : n.drawImage(t, 0, 0, t.width, t.height),
        (i = e);
    }
    return i.width > 2048 || i.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          t
        ),
        i.toDataURL("image/jpeg", 0.6))
      : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      ("undefined" != typeof HTMLImageElement &&
        e instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        e instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
    ) {
      let t = k("canvas");
      (t.width = e.width), (t.height = e.height);
      let i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      let n = i.getImageData(0, 0, e.width, e.height),
        r = n.data;
      for (let e = 0; e < r.length; e++) r[e] = 255 * J(r[e] / 255);
      return i.putImageData(n, 0, 0), t;
    }
    if (!e.data)
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
    {
      let t = e.data.slice(0);
      for (let e = 0; e < t.length; e++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[e] = Math.floor(255 * J(t[e] / 255)))
          : (t[e] = J(t[e]));
      return { data: t, width: e.width, height: e.height };
    }
  }
}
let Z = 0;
class Q {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: Z++ }),
      (this.uuid = C()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  toJSON(e) {
    let t = void 0 === e || "string" == typeof e;
    if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
    let i = { uuid: this.uuid, url: "" },
      n = this.data;
    if (null !== n) {
      let e;
      if (Array.isArray(n)) {
        e = [];
        for (let t = 0, i = n.length; t < i; t++)
          n[t].isDataTexture ? e.push($(n[t].image)) : e.push($(n[t]));
      } else e = $(n);
      i.url = e;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function $(e) {
  return ("undefined" != typeof HTMLImageElement &&
    e instanceof HTMLImageElement) ||
    ("undefined" != typeof HTMLCanvasElement &&
      e instanceof HTMLCanvasElement) ||
    ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
    ? K.getDataURL(e)
    : e.data
    ? {
        data: Array.from(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let ee = 0;
class et extends T {
  constructor(
    e = et.DEFAULT_IMAGE,
    t = et.DEFAULT_MAPPING,
    i = 1001,
    n = 1001,
    r = 1006,
    s = 1008,
    a = 1023,
    o = 1009,
    l = et.DEFAULT_ANISOTROPY,
    h = ""
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: ee++ }),
      (this.uuid = C()),
      (this.name = ""),
      (this.source = new Q(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = n),
      (this.magFilter = r),
      (this.minFilter = s),
      (this.anisotropy = l),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = o),
      (this.offset = new U(0, 0)),
      (this.repeat = new U(1, 1)),
      (this.center = new U(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new z()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    let t = void 0 === e || "string" == typeof e;
    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
    let i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (300 !== this.mapping) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;
        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case 1002:
          1 === Math.abs(Math.floor(e.x) % 2)
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;
        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case 1002:
          1 === Math.abs(Math.floor(e.y) % 2)
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    !0 === e && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    !0 === e && this.pmremVersion++;
  }
}
(et.DEFAULT_IMAGE = null),
  (et.DEFAULT_MAPPING = 300),
  (et.DEFAULT_ANISOTROPY = 1);
class ei {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    (ei.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = n);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, n) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = void 0 !== e.w ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * r),
      (this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * r),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    let t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, n;
    let r = e.elements,
      s = r[0],
      a = r[4],
      o = r[8],
      l = r[1],
      h = r[5],
      c = r[9],
      u = r[2],
      d = r[6],
      p = r[10];
    if (
      0.01 > Math.abs(a - l) &&
      0.01 > Math.abs(o - u) &&
      0.01 > Math.abs(c - d)
    ) {
      if (
        0.1 > Math.abs(a + l) &&
        0.1 > Math.abs(o + u) &&
        0.1 > Math.abs(c + d) &&
        0.1 > Math.abs(s + h + p - 3)
      )
        return this.set(1, 0, 0, 0), this;
      let e = (s + 1) / 2,
        r = (h + 1) / 2,
        m = (p + 1) / 2,
        f = (a + l) / 4,
        g = (o + u) / 4,
        _ = (c + d) / 4;
      return (
        e > r && e > m
          ? e < 0.01
            ? ((t = 0), (i = 0.707106781), (n = 0.707106781))
            : ((i = f / (t = Math.sqrt(e))), (n = g / t))
          : r > m
          ? r < 0.01
            ? ((t = 0.707106781), (i = 0), (n = 0.707106781))
            : ((t = f / (i = Math.sqrt(r))), (n = _ / i))
          : m < 0.01
          ? ((t = 0.707106781), (i = 0.707106781), (n = 0))
          : ((t = g / (n = Math.sqrt(m))), (i = _ / n)),
        this.set(t, i, n, Math.PI),
        this
      );
    }
    let m = Math.sqrt(
      (d - c) * (d - c) + (o - u) * (o - u) + (l - a) * (l - a)
    );
    return (
      0.001 > Math.abs(m) && (m = 1),
      (this.x = (d - c) / m),
      (this.y = (o - u) / m),
      (this.z = (l - a) / m),
      (this.w = Math.acos((s + h + p - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    let t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    let i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class en extends T {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new ei(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new ei(0, 0, e, t));
    let n = new et(
      { width: e, height: t, depth: 1 },
      (i = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: 1006,
          depthBuffer: !0,
          stencilBuffer: !1,
          resolveDepthBuffer: !0,
          resolveStencilBuffer: !0,
          depthTexture: null,
          samples: 0,
          count: 1,
        },
        i
      )).mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace
    );
    (n.flipY = !1),
      (n.generateMipmaps = i.generateMipmaps),
      (n.internalFormat = i.internalFormat),
      (this.textures = []);
    let r = i.count;
    for (let e = 0; e < r; e++)
      (this.textures[e] = n.clone()),
        (this.textures[e].isRenderTargetTexture = !0);
    (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let n = 0, r = this.textures.length; n < r; n++)
        (this.textures[n].image.width = e),
          (this.textures[n].image.height = t),
          (this.textures[n].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let t = 0, i = e.textures.length; t < i; t++)
      (this.textures[t] = e.textures[t].clone()),
        (this.textures[t].isRenderTargetTexture = !0);
    let t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Q(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class er extends en {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0);
  }
}
class es extends et {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: n }),
      (this.magFilter = 1003),
      (this.minFilter = 1003),
      (this.wrapR = 1001),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class ea {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = n);
  }
  static slerpFlat(e, t, i, n, r, s, a) {
    let o = i[n + 0],
      l = i[n + 1],
      h = i[n + 2],
      c = i[n + 3],
      u = r[s + 0],
      d = r[s + 1],
      p = r[s + 2],
      m = r[s + 3];
    if (0 === a) {
      (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = c);
      return;
    }
    if (1 === a) {
      (e[t + 0] = u), (e[t + 1] = d), (e[t + 2] = p), (e[t + 3] = m);
      return;
    }
    if (c !== m || o !== u || l !== d || h !== p) {
      let e = 1 - a,
        t = o * u + l * d + h * p + c * m,
        i = t >= 0 ? 1 : -1,
        n = 1 - t * t;
      if (n > Number.EPSILON) {
        let r = Math.sqrt(n),
          s = Math.atan2(r, t * i);
        (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
      }
      let r = a * i;
      if (
        ((o = o * e + u * r),
        (l = l * e + d * r),
        (h = h * e + p * r),
        (c = c * e + m * r),
        e === 1 - a)
      ) {
        let e = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
        (o *= e), (l *= e), (h *= e), (c *= e);
      }
    }
    (e[t] = o), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = c);
  }
  static multiplyQuaternionsFlat(e, t, i, n, r, s) {
    let a = i[n],
      o = i[n + 1],
      l = i[n + 2],
      h = i[n + 3],
      c = r[s],
      u = r[s + 1],
      d = r[s + 2],
      p = r[s + 3];
    return (
      (e[t] = a * p + h * c + o * d - l * u),
      (e[t + 1] = o * p + h * u + l * c - a * d),
      (e[t + 2] = l * p + h * d + a * u - o * c),
      (e[t + 3] = h * p - a * c - o * u - l * d),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, n) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    let i = e._x,
      n = e._y,
      r = e._z,
      s = e._order,
      a = Math.cos,
      o = Math.sin,
      l = a(i / 2),
      h = a(n / 2),
      c = a(r / 2),
      u = o(i / 2),
      d = o(n / 2),
      p = o(r / 2);
    switch (s) {
      case "XYZ":
        (this._x = u * h * c + l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c - u * d * p);
        break;
      case "YXZ":
        (this._x = u * h * c + l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c + u * d * p);
        break;
      case "ZXY":
        (this._x = u * h * c - l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c - u * d * p);
        break;
      case "ZYX":
        (this._x = u * h * c - l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c + u * d * p);
        break;
      case "YZX":
        (this._x = u * h * c + l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c - u * d * p);
        break;
      case "XZY":
        (this._x = u * h * c - l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c + u * d * p);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return !0 === t && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    let i = t / 2,
      n = Math.sin(i);
    return (
      (this._x = e.x * n),
      (this._y = e.y * n),
      (this._z = e.z * n),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    let t = e.elements,
      i = t[0],
      n = t[4],
      r = t[8],
      s = t[1],
      a = t[5],
      o = t[9],
      l = t[2],
      h = t[6],
      c = t[10],
      u = i + a + c;
    if (u > 0) {
      let e = 0.5 / Math.sqrt(u + 1);
      (this._w = 0.25 / e),
        (this._x = (h - o) * e),
        (this._y = (r - l) * e),
        (this._z = (s - n) * e);
    } else if (i > a && i > c) {
      let e = 2 * Math.sqrt(1 + i - a - c);
      (this._w = (h - o) / e),
        (this._x = 0.25 * e),
        (this._y = (n + s) / e),
        (this._z = (r + l) / e);
    } else if (a > c) {
      let e = 2 * Math.sqrt(1 + a - i - c);
      (this._w = (r - l) / e),
        (this._x = (n + s) / e),
        (this._y = 0.25 * e),
        (this._z = (o + h) / e);
    } else {
      let e = 2 * Math.sqrt(1 + c - i - a);
      (this._w = (s - n) / e),
        (this._x = (r + l) / e),
        (this._y = (o + h) / e),
        (this._z = 0.25 * e);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x)),
      (this._w = i),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(P(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    let i = this.angleTo(e);
    return 0 === i || this.slerp(e, Math.min(1, t / i)), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      0 === e
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    let i = e._x,
      n = e._y,
      r = e._z,
      s = e._w,
      a = t._x,
      o = t._y,
      l = t._z,
      h = t._w;
    return (
      (this._x = i * h + s * a + n * l - r * o),
      (this._y = n * h + s * o + r * a - i * l),
      (this._z = r * h + s * l + i * o - n * a),
      (this._w = s * h - i * a - n * o - r * l),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (0 === t) return this;
    if (1 === t) return this.copy(e);
    let i = this._x,
      n = this._y,
      r = this._z,
      s = this._w,
      a = s * e._w + i * e._x + n * e._y + r * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = s), (this._x = i), (this._y = n), (this._z = r), this;
    let o = 1 - a * a;
    if (o <= Number.EPSILON) {
      let e = 1 - t;
      return (
        (this._w = e * s + t * this._w),
        (this._x = e * i + t * this._x),
        (this._y = e * n + t * this._y),
        (this._z = e * r + t * this._z),
        this.normalize(),
        this
      );
    }
    let l = Math.sqrt(o),
      h = Math.atan2(l, a),
      c = Math.sin((1 - t) * h) / l,
      u = Math.sin(t * h) / l;
    return (
      (this._w = s * c + this._w * u),
      (this._x = i * c + this._x * u),
      (this._y = n * c + this._y * u),
      (this._z = r * c + this._z * u),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    let e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      i = Math.random(),
      n = Math.sqrt(1 - i),
      r = Math.sqrt(i);
    return this.set(
      n * Math.sin(e),
      n * Math.cos(e),
      r * Math.sin(t),
      r * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class eo {
  constructor(e = 0, t = 0, i = 0) {
    (eo.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      void 0 === i && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(eh.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(eh.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6] * n),
      (this.y = r[1] * t + r[4] * i + r[7] * n),
      (this.z = r[2] * t + r[5] * i + r[8] * n),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.elements,
      s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return (
      (this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s),
      (this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s),
      (this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.x,
      s = e.y,
      a = e.z,
      o = e.w,
      l = 2 * (s * n - a * i),
      h = 2 * (a * t - r * n),
      c = 2 * (r * i - s * t);
    return (
      (this.x = t + o * l + s * c - a * h),
      (this.y = i + o * h + a * l - r * c),
      (this.z = n + o * c + r * h - s * l),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[4] * i + r[8] * n),
      (this.y = r[1] * t + r[5] * i + r[9] * n),
      (this.z = r[2] * t + r[6] * i + r[10] * n),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    let i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    let i = e.x,
      n = e.y,
      r = e.z,
      s = t.x,
      a = t.y,
      o = t.z;
    return (
      (this.x = n * o - r * a),
      (this.y = r * s - i * o),
      (this.z = i * a - n * s),
      this
    );
  }
  projectOnVector(e) {
    let t = e.lengthSq();
    if (0 === t) return this.set(0, 0, 0);
    let i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return el.copy(this).projectOnVector(e), this.sub(el);
  }
  reflect(e) {
    return this.sub(el.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    let t = Math.sqrt(this.lengthSq() * e.lengthSq());
    return 0 === t ? Math.PI / 2 : Math.acos(P(this.dot(e) / t, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    let t = this.x - e.x,
      i = this.y - e.y,
      n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    let n = Math.sin(t) * e;
    return (
      (this.x = n * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = n * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    let t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    let t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      n = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = n), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    let e = Math.random() * Math.PI * 2,
      t = 2 * Math.random() - 1,
      i = Math.sqrt(1 - t * t);
    return (
      (this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const el = new eo(),
  eh = new ea();
class ec {
  constructor(
    e = new eo(1 / 0, 1 / 0, 1 / 0),
    t = new eo(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(ed.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(ed.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    let i = ed.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    let i = e.geometry;
    if (void 0 !== i) {
      let n = i.getAttribute("position");
      if (!0 === t && void 0 !== n && !0 !== e.isInstancedMesh)
        for (let t = 0, i = n.count; t < i; t++)
          !0 === e.isMesh
            ? e.getVertexPosition(t, ed)
            : ed.fromBufferAttribute(n, t),
            ed.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ed);
      else
        void 0 !== e.boundingBox
          ? (null === e.boundingBox && e.computeBoundingBox(),
            ep.copy(e.boundingBox))
          : (null === i.boundingBox && i.computeBoundingBox(),
            ep.copy(i.boundingBox)),
          ep.applyMatrix4(e.matrixWorld),
          this.union(ep);
    }
    let n = e.children;
    for (let e = 0, i = n.length; e < i; e++) this.expandByObject(n[e], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ed),
      ed.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(ey),
      eM.subVectors(this.max, ey),
      em.subVectors(e.a, ey),
      ef.subVectors(e.b, ey),
      eg.subVectors(e.c, ey),
      e_.subVectors(ef, em),
      ev.subVectors(eg, ef),
      ex.subVectors(em, eg);
    let t = [
      0,
      -e_.z,
      e_.y,
      0,
      -ev.z,
      ev.y,
      0,
      -ex.z,
      ex.y,
      e_.z,
      0,
      -e_.x,
      ev.z,
      0,
      -ev.x,
      ex.z,
      0,
      -ex.x,
      -e_.y,
      e_.x,
      0,
      -ev.y,
      ev.x,
      0,
      -ex.y,
      ex.x,
      0,
    ];
    return (
      !!(
        eT(t, em, ef, eg, eM) &&
        eT((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), em, ef, eg, eM)
      ) &&
      (eS.crossVectors(e_, ev), eT((t = [eS.x, eS.y, eS.z]), em, ef, eg, eM))
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ed).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = 0.5 * this.getSize(ed).length())),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return (
      this.isEmpty() ||
        (eu[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        eu[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        eu[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        eu[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        eu[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        eu[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        eu[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        eu[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(eu)),
      this
    );
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const eu = [
    new eo(),
    new eo(),
    new eo(),
    new eo(),
    new eo(),
    new eo(),
    new eo(),
    new eo(),
  ],
  ed = new eo(),
  ep = new ec(),
  em = new eo(),
  ef = new eo(),
  eg = new eo(),
  e_ = new eo(),
  ev = new eo(),
  ex = new eo(),
  ey = new eo(),
  eM = new eo(),
  eS = new eo(),
  eb = new eo();
function eT(e, t, i, n, r) {
  for (let s = 0, a = e.length - 3; s <= a; s += 3) {
    eb.fromArray(e, s);
    let a = r.x * Math.abs(eb.x) + r.y * Math.abs(eb.y) + r.z * Math.abs(eb.z),
      o = t.dot(eb),
      l = i.dot(eb),
      h = n.dot(eb);
    if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1;
  }
  return !0;
}
const eE = new ec(),
  ew = new eo(),
  eA = new eo();
class eR {
  constructor(e = new eo(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    let i = this.center;
    void 0 !== t ? i.copy(t) : eE.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let t = 0, r = e.length; t < r; t++)
      n = Math.max(n, i.distanceToSquared(e[t]));
    return (this.radius = Math.sqrt(n)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    let t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    let i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (e.set(this.center, this.center), e.expandByScalar(this.radius)),
      e
    );
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    ew.subVectors(e, this.center);
    let t = ew.lengthSq();
    if (t > this.radius * this.radius) {
      let e = Math.sqrt(t),
        i = (e - this.radius) * 0.5;
      this.center.addScaledVector(ew, i / e), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return (
      e.isEmpty() ||
        (this.isEmpty()
          ? this.copy(e)
          : !0 === this.center.equals(e.center)
          ? (this.radius = Math.max(this.radius, e.radius))
          : (eA.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(ew.copy(e.center).add(eA)),
            this.expandByPoint(ew.copy(e.center).sub(eA)))),
      this
    );
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const eC = new eo(),
  eP = new eo(),
  eL = new eo(),
  eN = new eo(),
  eI = new eo(),
  eD = new eo(),
  eO = new eo();
class eU {
  constructor(e = new eo(), t = new eo(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, eC)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    let i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    let t = eC.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (eC.copy(this.origin).addScaledVector(this.direction, t),
        eC.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    let r, s, a, o;
    eP.copy(e).add(t).multiplyScalar(0.5),
      eL.copy(t).sub(e).normalize(),
      eN.copy(this.origin).sub(eP);
    let l = 0.5 * e.distanceTo(t),
      h = -this.direction.dot(eL),
      c = eN.dot(this.direction),
      u = -eN.dot(eL),
      d = eN.lengthSq(),
      p = Math.abs(1 - h * h);
    if (p > 0) {
      if (((r = h * u - c), (s = h * c - u), (o = l * p), r >= 0)) {
        if (s >= -o) {
          if (s <= o) {
            let e = 1 / p;
            (r *= e),
              (s *= e),
              (a = r * (r + h * s + 2 * c) + s * (h * r + s + 2 * u) + d);
          } else
            a =
              -(r = Math.max(0, -(h * (s = l) + c))) * r + s * (s + 2 * u) + d;
        } else
          a = -(r = Math.max(0, -(h * (s = -l) + c))) * r + s * (s + 2 * u) + d;
      } else
        s <= -o
          ? ((s =
              (r = Math.max(0, -(-h * l + c))) > 0
                ? -l
                : Math.min(Math.max(-l, -u), l)),
            (a = -r * r + s * (s + 2 * u) + d))
          : s <= o
          ? ((r = 0),
            (a = (s = Math.min(Math.max(-l, -u), l)) * (s + 2 * u) + d))
          : ((s =
              (r = Math.max(0, -(h * l + c))) > 0
                ? l
                : Math.min(Math.max(-l, -u), l)),
            (a = -r * r + s * (s + 2 * u) + d));
    } else
      (s = h > 0 ? -l : l),
        (a = -(r = Math.max(0, -(h * s + c))) * r + s * (s + 2 * u) + d);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, r),
      n && n.copy(eP).addScaledVector(eL, s),
      a
    );
  }
  intersectSphere(e, t) {
    eC.subVectors(e.center, this.origin);
    let i = eC.dot(this.direction),
      n = eC.dot(eC) - i * i,
      r = e.radius * e.radius;
    if (n > r) return null;
    let s = Math.sqrt(r - n),
      a = i - s,
      o = i + s;
    return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    let t = e.normal.dot(this.direction);
    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
    let i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    let i = this.distanceToPlane(e);
    return null === i ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    let t = e.distanceToPoint(this.origin);
    return !!(0 === t || e.normal.dot(this.direction) * t < 0);
  }
  intersectBox(e, t) {
    let i, n, r, s, a, o;
    let l = 1 / this.direction.x,
      h = 1 / this.direction.y,
      c = 1 / this.direction.z,
      u = this.origin;
    return (l >= 0
      ? ((i = (e.min.x - u.x) * l), (n = (e.max.x - u.x) * l))
      : ((i = (e.max.x - u.x) * l), (n = (e.min.x - u.x) * l)),
    h >= 0
      ? ((r = (e.min.y - u.y) * h), (s = (e.max.y - u.y) * h))
      : ((r = (e.max.y - u.y) * h), (s = (e.min.y - u.y) * h)),
    i > s || r > n)
      ? null
      : ((r > i || isNaN(i)) && (i = r),
        (s < n || isNaN(n)) && (n = s),
        c >= 0
          ? ((a = (e.min.z - u.z) * c), (o = (e.max.z - u.z) * c))
          : ((a = (e.max.z - u.z) * c), (o = (e.min.z - u.z) * c)),
        i > o || a > n)
      ? null
      : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0)
      ? null
      : this.at(i >= 0 ? i : n, t);
  }
  intersectsBox(e) {
    return null !== this.intersectBox(e, eC);
  }
  intersectTriangle(e, t, i, n, r) {
    let s;
    eI.subVectors(t, e), eD.subVectors(i, e), eO.crossVectors(eI, eD);
    let a = this.direction.dot(eO);
    if (a > 0) {
      if (n) return null;
      s = 1;
    } else {
      if (!(a < 0)) return null;
      (s = -1), (a = -a);
    }
    eN.subVectors(this.origin, e);
    let o = s * this.direction.dot(eD.crossVectors(eN, eD));
    if (o < 0) return null;
    let l = s * this.direction.dot(eI.cross(eN));
    if (l < 0 || o + l > a) return null;
    let h = -s * eN.dot(eO);
    return h < 0 ? null : this.at(h / a, r);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ez {
  constructor(e, t, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
    (ez.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      void 0 !== e && this.set(e, t, i, n, r, s, a, o, l, h, c, u, d, p, m, f);
  }
  set(e, t, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
    let g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = i),
      (g[12] = n),
      (g[1] = r),
      (g[5] = s),
      (g[9] = a),
      (g[13] = o),
      (g[2] = l),
      (g[6] = h),
      (g[10] = c),
      (g[14] = u),
      (g[3] = d),
      (g[7] = p),
      (g[11] = m),
      (g[15] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new ez().fromArray(this.elements);
  }
  copy(e) {
    let t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    let t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    let t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    let t = this.elements,
      i = e.elements,
      n = 1 / eF.setFromMatrixColumn(e, 0).length(),
      r = 1 / eF.setFromMatrixColumn(e, 1).length(),
      s = 1 / eF.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * n),
      (t[1] = i[1] * n),
      (t[2] = i[2] * n),
      (t[3] = 0),
      (t[4] = i[4] * r),
      (t[5] = i[5] * r),
      (t[6] = i[6] * r),
      (t[7] = 0),
      (t[8] = i[8] * s),
      (t[9] = i[9] * s),
      (t[10] = i[10] * s),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    let t = this.elements,
      i = e.x,
      n = e.y,
      r = e.z,
      s = Math.cos(i),
      a = Math.sin(i),
      o = Math.cos(n),
      l = Math.sin(n),
      h = Math.cos(r),
      c = Math.sin(r);
    if ("XYZ" === e.order) {
      let e = s * h,
        i = s * c,
        n = a * h,
        r = a * c;
      (t[0] = o * h),
        (t[4] = -o * c),
        (t[8] = l),
        (t[1] = i + n * l),
        (t[5] = e - r * l),
        (t[9] = -a * o),
        (t[2] = r - e * l),
        (t[6] = n + i * l),
        (t[10] = s * o);
    } else if ("YXZ" === e.order) {
      let e = o * h,
        i = o * c,
        n = l * h,
        r = l * c;
      (t[0] = e + r * a),
        (t[4] = n * a - i),
        (t[8] = s * l),
        (t[1] = s * c),
        (t[5] = s * h),
        (t[9] = -a),
        (t[2] = i * a - n),
        (t[6] = r + e * a),
        (t[10] = s * o);
    } else if ("ZXY" === e.order) {
      let e = o * h,
        i = o * c,
        n = l * h,
        r = l * c;
      (t[0] = e - r * a),
        (t[4] = -s * c),
        (t[8] = n + i * a),
        (t[1] = i + n * a),
        (t[5] = s * h),
        (t[9] = r - e * a),
        (t[2] = -s * l),
        (t[6] = a),
        (t[10] = s * o);
    } else if ("ZYX" === e.order) {
      let e = s * h,
        i = s * c,
        n = a * h,
        r = a * c;
      (t[0] = o * h),
        (t[4] = n * l - i),
        (t[8] = e * l + r),
        (t[1] = o * c),
        (t[5] = r * l + e),
        (t[9] = i * l - n),
        (t[2] = -l),
        (t[6] = a * o),
        (t[10] = s * o);
    } else if ("YZX" === e.order) {
      let e = s * o,
        i = s * l,
        n = a * o,
        r = a * l;
      (t[0] = o * h),
        (t[4] = r - e * c),
        (t[8] = n * c + i),
        (t[1] = c),
        (t[5] = s * h),
        (t[9] = -a * h),
        (t[2] = -l * h),
        (t[6] = i * c + n),
        (t[10] = e - r * c);
    } else if ("XZY" === e.order) {
      let e = s * o,
        i = s * l,
        n = a * o,
        r = a * l;
      (t[0] = o * h),
        (t[4] = -c),
        (t[8] = l * h),
        (t[1] = e * c + r),
        (t[5] = s * h),
        (t[9] = i * c - n),
        (t[2] = n * c - i),
        (t[6] = a * h),
        (t[10] = r * c + e);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(ek, e, eH);
  }
  lookAt(e, t, i) {
    let n = this.elements;
    return (
      eW.subVectors(e, t),
      0 === eW.lengthSq() && (eW.z = 1),
      eW.normalize(),
      eV.crossVectors(i, eW),
      0 === eV.lengthSq() &&
        (1 === Math.abs(i.z) ? (eW.x += 1e-4) : (eW.z += 1e-4),
        eW.normalize(),
        eV.crossVectors(i, eW)),
      eV.normalize(),
      eG.crossVectors(eW, eV),
      (n[0] = eV.x),
      (n[4] = eG.x),
      (n[8] = eW.x),
      (n[1] = eV.y),
      (n[5] = eG.y),
      (n[9] = eW.y),
      (n[2] = eV.z),
      (n[6] = eG.z),
      (n[10] = eW.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    let i = e.elements,
      n = t.elements,
      r = this.elements,
      s = i[0],
      a = i[4],
      o = i[8],
      l = i[12],
      h = i[1],
      c = i[5],
      u = i[9],
      d = i[13],
      p = i[2],
      m = i[6],
      f = i[10],
      g = i[14],
      _ = i[3],
      v = i[7],
      x = i[11],
      y = i[15],
      M = n[0],
      S = n[4],
      b = n[8],
      T = n[12],
      E = n[1],
      w = n[5],
      A = n[9],
      R = n[13],
      C = n[2],
      P = n[6],
      L = n[10],
      N = n[14],
      I = n[3],
      D = n[7],
      O = n[11],
      U = n[15];
    return (
      (r[0] = s * M + a * E + o * C + l * I),
      (r[4] = s * S + a * w + o * P + l * D),
      (r[8] = s * b + a * A + o * L + l * O),
      (r[12] = s * T + a * R + o * N + l * U),
      (r[1] = h * M + c * E + u * C + d * I),
      (r[5] = h * S + c * w + u * P + d * D),
      (r[9] = h * b + c * A + u * L + d * O),
      (r[13] = h * T + c * R + u * N + d * U),
      (r[2] = p * M + m * E + f * C + g * I),
      (r[6] = p * S + m * w + f * P + g * D),
      (r[10] = p * b + m * A + f * L + g * O),
      (r[14] = p * T + m * R + f * N + g * U),
      (r[3] = _ * M + v * E + x * C + y * I),
      (r[7] = _ * S + v * w + x * P + y * D),
      (r[11] = _ * b + v * A + x * L + y * O),
      (r[15] = _ * T + v * R + x * N + y * U),
      this
    );
  }
  multiplyScalar(e) {
    let t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    let e = this.elements,
      t = e[0],
      i = e[4],
      n = e[8],
      r = e[12],
      s = e[1],
      a = e[5],
      o = e[9],
      l = e[13],
      h = e[2],
      c = e[6],
      u = e[10],
      d = e[14],
      p = e[3];
    return (
      p *
        (+r * o * c -
          n * l * c -
          r * a * u +
          i * l * u +
          n * a * d -
          i * o * d) +
      e[7] *
        (+t * o * d -
          t * l * u +
          r * s * u -
          n * s * d +
          n * l * h -
          r * o * h) +
      e[11] *
        (+t * l * c -
          t * a * d -
          r * s * c +
          i * s * d +
          r * a * h -
          i * l * h) +
      e[15] *
        (-n * a * h - t * o * c + t * a * u + n * s * c - i * s * u + i * o * h)
    );
  }
  transpose() {
    let e;
    let t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  setPosition(e, t, i) {
    let n = this.elements;
    return (
      e.isVector3
        ? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z))
        : ((n[12] = e), (n[13] = t), (n[14] = i)),
      this
    );
  }
  invert() {
    let e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      r = e[3],
      s = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      h = e[8],
      c = e[9],
      u = e[10],
      d = e[11],
      p = e[12],
      m = e[13],
      f = e[14],
      g = e[15],
      _ = c * f * l - m * u * l + m * o * d - a * f * d - c * o * g + a * u * g,
      v = p * u * l - h * f * l - p * o * d + s * f * d + h * o * g - s * u * g,
      x = h * m * l - p * c * l + p * a * d - s * m * d - h * a * g + s * c * g,
      y = p * c * o - h * m * o - p * a * u + s * m * u + h * a * f - s * c * f,
      M = t * _ + i * v + n * x + r * y;
    if (0 === M)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    let S = 1 / M;
    return (
      (e[0] = _ * S),
      (e[1] =
        (m * u * r -
          c * f * r -
          m * n * d +
          i * f * d +
          c * n * g -
          i * u * g) *
        S),
      (e[2] =
        (a * f * r -
          m * o * r +
          m * n * l -
          i * f * l -
          a * n * g +
          i * o * g) *
        S),
      (e[3] =
        (c * o * r -
          a * u * r -
          c * n * l +
          i * u * l +
          a * n * d -
          i * o * d) *
        S),
      (e[4] = v * S),
      (e[5] =
        (h * f * r -
          p * u * r +
          p * n * d -
          t * f * d -
          h * n * g +
          t * u * g) *
        S),
      (e[6] =
        (p * o * r -
          s * f * r -
          p * n * l +
          t * f * l +
          s * n * g -
          t * o * g) *
        S),
      (e[7] =
        (s * u * r -
          h * o * r +
          h * n * l -
          t * u * l -
          s * n * d +
          t * o * d) *
        S),
      (e[8] = x * S),
      (e[9] =
        (p * c * r -
          h * m * r -
          p * i * d +
          t * m * d +
          h * i * g -
          t * c * g) *
        S),
      (e[10] =
        (s * m * r -
          p * a * r +
          p * i * l -
          t * m * l -
          s * i * g +
          t * a * g) *
        S),
      (e[11] =
        (h * a * r -
          s * c * r -
          h * i * l +
          t * c * l +
          s * i * d -
          t * a * d) *
        S),
      (e[12] = y * S),
      (e[13] =
        (h * m * n -
          p * c * n +
          p * i * u -
          t * m * u -
          h * i * f +
          t * c * f) *
        S),
      (e[14] =
        (p * a * n -
          s * m * n -
          p * i * o +
          t * m * o +
          s * i * f -
          t * a * f) *
        S),
      (e[15] =
        (s * c * n -
          h * a * n +
          h * i * o -
          t * c * o -
          s * i * u +
          t * a * u) *
        S),
      this
    );
  }
  scale(e) {
    let t = this.elements,
      i = e.x,
      n = e.y,
      r = e.z;
    return (
      (t[0] *= i),
      (t[4] *= n),
      (t[8] *= r),
      (t[1] *= i),
      (t[5] *= n),
      (t[9] *= r),
      (t[2] *= i),
      (t[6] *= n),
      (t[10] *= r),
      (t[3] *= i),
      (t[7] *= n),
      (t[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    let e = this.elements;
    return Math.sqrt(
      Math.max(
        e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
      )
    );
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    let t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    let t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    let t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    let i = Math.cos(t),
      n = Math.sin(t),
      r = 1 - i,
      s = e.x,
      a = e.y,
      o = e.z,
      l = r * s,
      h = r * a;
    return (
      this.set(
        l * s + i,
        l * a - n * o,
        l * o + n * a,
        0,
        l * a + n * o,
        h * a + i,
        h * o - n * s,
        0,
        l * o - n * a,
        h * o + n * s,
        r * o * o + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, n, r, s) {
    return this.set(1, i, r, 0, e, 1, s, 0, t, n, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    let n = this.elements,
      r = t._x,
      s = t._y,
      a = t._z,
      o = t._w,
      l = r + r,
      h = s + s,
      c = a + a,
      u = r * l,
      d = r * h,
      p = r * c,
      m = s * h,
      f = s * c,
      g = a * c,
      _ = o * l,
      v = o * h,
      x = o * c,
      y = i.x,
      M = i.y,
      S = i.z;
    return (
      (n[0] = (1 - (m + g)) * y),
      (n[1] = (d + x) * y),
      (n[2] = (p - v) * y),
      (n[3] = 0),
      (n[4] = (d - x) * M),
      (n[5] = (1 - (u + g)) * M),
      (n[6] = (f + _) * M),
      (n[7] = 0),
      (n[8] = (p + v) * S),
      (n[9] = (f - _) * S),
      (n[10] = (1 - (u + m)) * S),
      (n[11] = 0),
      (n[12] = e.x),
      (n[13] = e.y),
      (n[14] = e.z),
      (n[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    let n = this.elements,
      r = eF.set(n[0], n[1], n[2]).length(),
      s = eF.set(n[4], n[5], n[6]).length(),
      a = eF.set(n[8], n[9], n[10]).length();
    0 > this.determinant() && (r = -r),
      (e.x = n[12]),
      (e.y = n[13]),
      (e.z = n[14]),
      eB.copy(this);
    let o = 1 / r,
      l = 1 / s,
      h = 1 / a;
    return (
      (eB.elements[0] *= o),
      (eB.elements[1] *= o),
      (eB.elements[2] *= o),
      (eB.elements[4] *= l),
      (eB.elements[5] *= l),
      (eB.elements[6] *= l),
      (eB.elements[8] *= h),
      (eB.elements[9] *= h),
      (eB.elements[10] *= h),
      t.setFromRotationMatrix(eB),
      (i.x = r),
      (i.y = s),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, n, r, s, a = 2e3) {
    let o, l;
    let h = this.elements;
    if (2e3 === a) (o = -(s + r) / (s - r)), (l = (-2 * s * r) / (s - r));
    else if (2001 === a) (o = -s / (s - r)), (l = (-s * r) / (s - r));
    else
      throw Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (h[0] = (2 * r) / (t - e)),
      (h[4] = 0),
      (h[8] = (t + e) / (t - e)),
      (h[12] = 0),
      (h[1] = 0),
      (h[5] = (2 * r) / (i - n)),
      (h[9] = (i + n) / (i - n)),
      (h[13] = 0),
      (h[2] = 0),
      (h[6] = 0),
      (h[10] = o),
      (h[14] = l),
      (h[3] = 0),
      (h[7] = 0),
      (h[11] = -1),
      (h[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, n, r, s, a = 2e3) {
    let o, l;
    let h = this.elements,
      c = 1 / (t - e),
      u = 1 / (i - n),
      d = 1 / (s - r);
    if (2e3 === a) (o = (s + r) * d), (l = -2 * d);
    else if (2001 === a) (o = r * d), (l = -1 * d);
    else
      throw Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (h[0] = 2 * c),
      (h[4] = 0),
      (h[8] = 0),
      (h[12] = -((t + e) * c)),
      (h[1] = 0),
      (h[5] = 2 * u),
      (h[9] = 0),
      (h[13] = -((i + n) * u)),
      (h[2] = 0),
      (h[6] = 0),
      (h[10] = l),
      (h[14] = -o),
      (h[3] = 0),
      (h[7] = 0),
      (h[11] = 0),
      (h[15] = 1),
      this
    );
  }
  equals(e) {
    let t = this.elements,
      i = e.elements;
    for (let e = 0; e < 16; e++) if (t[e] !== i[e]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    let i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const eF = new eo(),
  eB = new ez(),
  ek = new eo(0, 0, 0),
  eH = new eo(1, 1, 1),
  eV = new eo(),
  eG = new eo(),
  eW = new eo(),
  eX = new ez(),
  ej = new ea();
class eq {
  constructor(e = 0, t = 0, i = 0, n = eq.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = n);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    let n = e.elements,
      r = n[0],
      s = n[4],
      a = n[8],
      o = n[1],
      l = n[5],
      h = n[9],
      c = n[2],
      u = n[6],
      d = n[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(P(a, -1, 1))),
          0.9999999 > Math.abs(a)
            ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-s, r)))
            : ((this._x = Math.atan2(u, l)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-P(h, -1, 1))),
          0.9999999 > Math.abs(h)
            ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
            : ((this._y = Math.atan2(-c, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(P(u, -1, 1))),
          0.9999999 > Math.abs(u)
            ? ((this._y = Math.atan2(-c, d)), (this._z = Math.atan2(-s, l)))
            : ((this._y = 0), (this._z = Math.atan2(o, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-P(c, -1, 1))),
          0.9999999 > Math.abs(c)
            ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
            : ((this._x = 0), (this._z = Math.atan2(-s, l)));
        break;
      case "YZX":
        (this._z = Math.asin(P(o, -1, 1))),
          0.9999999 > Math.abs(o)
            ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-c, r)))
            : ((this._x = 0), (this._y = Math.atan2(a, d)));
        break;
      case "XZY":
        (this._z = Math.asin(-P(s, -1, 1))),
          0.9999999 > Math.abs(s)
            ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
            : ((this._x = Math.atan2(-h, d)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), !0 === i && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      eX.makeRotationFromQuaternion(e), this.setFromRotationMatrix(eX, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return ej.setFromEuler(this), this.setFromQuaternion(ej, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      void 0 !== e[3] && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
eq.DEFAULT_ORDER = "XYZ";
class eJ {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) != 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) != 0;
  }
}
let eY = 0;
const eK = new eo(),
  eZ = new ea(),
  eQ = new ez(),
  e$ = new eo(),
  e0 = new eo(),
  e1 = new eo(),
  e2 = new ea(),
  e3 = new eo(1, 0, 0),
  e5 = new eo(0, 1, 0),
  e4 = new eo(0, 0, 1),
  e6 = { type: "added" },
  e7 = { type: "removed" },
  e8 = { type: "childadded", child: null },
  e9 = { type: "childremoved", child: null };
class te extends T {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: eY++ }),
      (this.uuid = C()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = te.DEFAULT_UP.clone());
    let e = new eo(),
      t = new eq(),
      i = new ea(),
      n = new eo(1, 1, 1);
    t._onChange(function () {
      i.setFromEuler(t, !1);
    }),
      i._onChange(function () {
        t.setFromQuaternion(i, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: n },
        modelViewMatrix: { value: new ez() },
        normalMatrix: { value: new z() },
      }),
      (this.matrix = new ez()),
      (this.matrixWorld = new ez()),
      (this.matrixAutoUpdate = te.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = te.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new eJ()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return eZ.setFromAxisAngle(e, t), this.quaternion.multiply(eZ), this;
  }
  rotateOnWorldAxis(e, t) {
    return eZ.setFromAxisAngle(e, t), this.quaternion.premultiply(eZ), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(e3, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(e5, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(e4, e);
  }
  translateOnAxis(e, t) {
    return (
      eK.copy(e).applyQuaternion(this.quaternion),
      this.position.add(eK.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(e3, e);
  }
  translateY(e) {
    return this.translateOnAxis(e5, e);
  }
  translateZ(e) {
    return this.translateOnAxis(e4, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(eQ.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? e$.copy(e) : e$.set(e, t, i);
    let n = this.parent;
    this.updateWorldMatrix(!0, !1),
      e0.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? eQ.lookAt(e0, e$, this.up)
        : eQ.lookAt(e$, e0, this.up),
      this.quaternion.setFromRotationMatrix(eQ),
      n &&
        (eQ.extractRotation(n.matrixWorld),
        eZ.setFromRotationMatrix(eQ),
        this.quaternion.premultiply(eZ.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return (
      e === this
        ? console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            e
          )
        : e && e.isObject3D
        ? (e.removeFromParent(),
          (e.parent = this),
          this.children.push(e),
          e.dispatchEvent(e6),
          (e8.child = e),
          this.dispatchEvent(e8),
          (e8.child = null))
        : console.error(
            "THREE.Object3D.add: object not an instance of THREE.Object3D.",
            e
          ),
      this
    );
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
      return this;
    }
    let t = this.children.indexOf(e);
    return (
      -1 !== t &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(e7),
        (e9.child = e),
        this.dispatchEvent(e9),
        (e9.child = null)),
      this
    );
  }
  removeFromParent() {
    let e = this.parent;
    return null !== e && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      eQ.copy(this.matrixWorld).invert(),
      null !== e.parent &&
        (e.parent.updateWorldMatrix(!0, !1), eQ.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(eQ),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(e6),
      (e8.child = e),
      this.dispatchEvent(e8),
      (e8.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      let n = this.children[i].getObjectByProperty(e, t);
      if (void 0 !== n) return n;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    let n = this.children;
    for (let r = 0, s = n.length; r < s; r++)
      n[r].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(e0, e, e1), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(e0, e2, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    let t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    let t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (!1 === this.visible) return;
    e(this);
    let t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    let t = this.parent;
    null !== t && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (!0 === this.matrixWorldAutoUpdate &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    let t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    let i = this.parent;
    if (
      (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      !0 === this.matrixWorldAutoUpdate &&
        (null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      !0 === t)
    ) {
      let e = this.children;
      for (let t = 0, i = e.length; t < i; t++) e[t].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    let t = void 0 === e || "string" == typeof e,
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    let n = {};
    function r(t, i) {
      return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid;
    }
    if (
      ((n.uuid = this.uuid),
      (n.type = this.type),
      "" !== this.name && (n.name = this.name),
      !0 === this.castShadow && (n.castShadow = !0),
      !0 === this.receiveShadow && (n.receiveShadow = !0),
      !1 === this.visible && (n.visible = !1),
      !1 === this.frustumCulled && (n.frustumCulled = !1),
      0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      (n.layers = this.layers.mask),
      (n.matrix = this.matrix.toArray()),
      (n.up = this.up.toArray()),
      !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((n.type = "InstancedMesh"),
        (n.count = this.count),
        (n.instanceMatrix = this.instanceMatrix.toJSON()),
        null !== this.instanceColor &&
          (n.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((n.type = "BatchedMesh"),
        (n.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (n.sortObjects = this.sortObjects),
        (n.drawRanges = this._drawRanges),
        (n.reservedRanges = this._reservedRanges),
        (n.visibility = this._visibility),
        (n.active = this._active),
        (n.bounds = this._bounds.map((e) => ({
          boxInitialized: e.boxInitialized,
          boxMin: e.box.min.toArray(),
          boxMax: e.box.max.toArray(),
          sphereInitialized: e.sphereInitialized,
          sphereRadius: e.sphere.radius,
          sphereCenter: e.sphere.center.toArray(),
        }))),
        (n.maxInstanceCount = this._maxInstanceCount),
        (n.maxVertexCount = this._maxVertexCount),
        (n.maxIndexCount = this._maxIndexCount),
        (n.geometryInitialized = this._geometryInitialized),
        (n.geometryCount = this._geometryCount),
        (n.matricesTexture = this._matricesTexture.toJSON(e)),
        null !== this._colorsTexture &&
          (n.colorsTexture = this._colorsTexture.toJSON(e)),
        null !== this.boundingSphere &&
          (n.boundingSphere = {
            center: n.boundingSphere.center.toArray(),
            radius: n.boundingSphere.radius,
          }),
        null !== this.boundingBox &&
          (n.boundingBox = {
            min: n.boundingBox.min.toArray(),
            max: n.boundingBox.max.toArray(),
          })),
      this.isScene)
    )
      this.background &&
        (this.background.isColor
          ? (n.background = this.background.toJSON())
          : this.background.isTexture &&
            (n.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          !0 !== this.environment.isRenderTargetTexture &&
          (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = r(e.geometries, this.geometry);
      let t = this.geometry.parameters;
      if (void 0 !== t && void 0 !== t.shapes) {
        let i = t.shapes;
        if (Array.isArray(i))
          for (let t = 0, n = i.length; t < n; t++) {
            let n = i[t];
            r(e.shapes, n);
          }
        else r(e.shapes, i);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((n.bindMode = this.bindMode),
        (n.bindMatrix = this.bindMatrix.toArray()),
        void 0 !== this.skeleton &&
          (r(e.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
      void 0 !== this.material)
    ) {
      if (Array.isArray(this.material)) {
        let t = [];
        for (let i = 0, n = this.material.length; i < n; i++)
          t.push(r(e.materials, this.material[i]));
        n.material = t;
      } else n.material = r(e.materials, this.material);
    }
    if (this.children.length > 0) {
      n.children = [];
      for (let t = 0; t < this.children.length; t++)
        n.children.push(this.children[t].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let t = 0; t < this.animations.length; t++) {
        let i = this.animations[t];
        n.animations.push(r(e.animations, i));
      }
    }
    if (t) {
      let t = s(e.geometries),
        n = s(e.materials),
        r = s(e.textures),
        a = s(e.images),
        o = s(e.shapes),
        l = s(e.skeletons),
        h = s(e.animations),
        c = s(e.nodes);
      t.length > 0 && (i.geometries = t),
        n.length > 0 && (i.materials = n),
        r.length > 0 && (i.textures = r),
        a.length > 0 && (i.images = a),
        o.length > 0 && (i.shapes = o),
        l.length > 0 && (i.skeletons = l),
        h.length > 0 && (i.animations = h),
        c.length > 0 && (i.nodes = c);
    }
    return (i.object = n), i;
    function s(e) {
      let t = [];
      for (let i in e) {
        let n = e[i];
        delete n.metadata, t.push(n);
      }
      return t;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      !0 === t)
    )
      for (let t = 0; t < e.children.length; t++) {
        let i = e.children[t];
        this.add(i.clone());
      }
    return this;
  }
}
(te.DEFAULT_UP = new eo(0, 1, 0)),
  (te.DEFAULT_MATRIX_AUTO_UPDATE = !0),
  (te.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
const tt = new eo(),
  ti = new eo(),
  tn = new eo(),
  tr = new eo(),
  ts = new eo(),
  ta = new eo(),
  to = new eo(),
  tl = new eo(),
  th = new eo(),
  tc = new eo(),
  tu = new ei(),
  td = new ei(),
  tp = new ei();
class tm {
  constructor(e = new eo(), t = new eo(), i = new eo()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), tt.subVectors(e, t), n.cross(tt);
    let r = n.lengthSq();
    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, n, r) {
    tt.subVectors(n, t), ti.subVectors(i, t), tn.subVectors(e, t);
    let s = tt.dot(tt),
      a = tt.dot(ti),
      o = tt.dot(tn),
      l = ti.dot(ti),
      h = ti.dot(tn),
      c = s * l - a * a;
    if (0 === c) return r.set(0, 0, 0), null;
    let u = 1 / c,
      d = (l * o - a * h) * u,
      p = (s * h - a * o) * u;
    return r.set(1 - d - p, p, d);
  }
  static containsPoint(e, t, i, n) {
    return (
      null !== this.getBarycoord(e, t, i, n, tr) &&
      tr.x >= 0 &&
      tr.y >= 0 &&
      tr.x + tr.y <= 1
    );
  }
  static getInterpolation(e, t, i, n, r, s, a, o) {
    return null === this.getBarycoord(e, t, i, n, tr)
      ? ((o.x = 0),
        (o.y = 0),
        "z" in o && (o.z = 0),
        "w" in o && (o.w = 0),
        null)
      : (o.setScalar(0),
        o.addScaledVector(r, tr.x),
        o.addScaledVector(s, tr.y),
        o.addScaledVector(a, tr.z),
        o);
  }
  static getInterpolatedAttribute(e, t, i, n, r, s) {
    return (
      tu.setScalar(0),
      td.setScalar(0),
      tp.setScalar(0),
      tu.fromBufferAttribute(e, t),
      td.fromBufferAttribute(e, i),
      tp.fromBufferAttribute(e, n),
      s.setScalar(0),
      s.addScaledVector(tu, r.x),
      s.addScaledVector(td, r.y),
      s.addScaledVector(tp, r.z),
      s
    );
  }
  static isFrontFacing(e, t, i, n) {
    return tt.subVectors(i, t), ti.subVectors(e, t), 0 > tt.cross(ti).dot(n);
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, i, n) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, n),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      tt.subVectors(this.c, this.b),
      ti.subVectors(this.a, this.b),
      0.5 * tt.cross(ti).length()
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return tm.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return tm.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, n, r) {
    return tm.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
  }
  containsPoint(e) {
    return tm.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return tm.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    let i, n;
    let r = this.a,
      s = this.b,
      a = this.c;
    ts.subVectors(s, r), ta.subVectors(a, r), tl.subVectors(e, r);
    let o = ts.dot(tl),
      l = ta.dot(tl);
    if (o <= 0 && l <= 0) return t.copy(r);
    th.subVectors(e, s);
    let h = ts.dot(th),
      c = ta.dot(th);
    if (h >= 0 && c <= h) return t.copy(s);
    let u = o * c - h * l;
    if (u <= 0 && o >= 0 && h <= 0)
      return (i = o / (o - h)), t.copy(r).addScaledVector(ts, i);
    tc.subVectors(e, a);
    let d = ts.dot(tc),
      p = ta.dot(tc);
    if (p >= 0 && d <= p) return t.copy(a);
    let m = d * l - o * p;
    if (m <= 0 && l >= 0 && p <= 0)
      return (n = l / (l - p)), t.copy(r).addScaledVector(ta, n);
    let f = h * p - d * c;
    if (f <= 0 && c - h >= 0 && d - p >= 0)
      return (
        to.subVectors(a, s),
        (n = (c - h) / (c - h + (d - p))),
        t.copy(s).addScaledVector(to, n)
      );
    let g = 1 / (f + m + u);
    return (
      (i = m * g),
      (n = u * g),
      t.copy(r).addScaledVector(ts, i).addScaledVector(ta, n)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const tf = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  tg = { h: 0, s: 0, l: 0 },
  t_ = { h: 0, s: 0, l: 0 };
function tv(e, t, i) {
  return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6)
    ? e + (t - e) * 6 * i
    : i < 0.5
    ? t
    : i < 2 / 3
    ? e + (t - e) * 6 * (2 / 3 - i)
    : e;
}
class tx {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    return (
      void 0 === t && void 0 === i
        ? e && e.isColor
          ? this.copy(e)
          : "number" == typeof e
          ? this.setHex(e)
          : "string" == typeof e && this.setStyle(e)
        : this.setRGB(e, t, i),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = g) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (255 & e) / 255),
      q.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, n = q.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      q.toWorkingColorSpace(this, n),
      this
    );
  }
  setHSL(e, t, i, n = q.workingColorSpace) {
    if (((e = L(e, 1)), (t = P(t, 0, 1)), (i = P(i, 0, 1)), 0 === t))
      this.r = this.g = this.b = i;
    else {
      let n = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        r = 2 * i - n;
      (this.r = tv(r, n, e + 1 / 3)),
        (this.g = tv(r, n, e)),
        (this.b = tv(r, n, e - 1 / 3));
    }
    return q.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = g) {
    let i;
    function n(t) {
      void 0 !== t &&
        1 > parseFloat(t) &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let r;
      let s = i[1],
        a = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (r =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(r[4]),
              this.setRGB(
                Math.min(255, parseInt(r[1], 10)) / 255,
                Math.min(255, parseInt(r[2], 10)) / 255,
                Math.min(255, parseInt(r[3], 10)) / 255,
                t
              )
            );
          if (
            (r =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(r[4]),
              this.setRGB(
                Math.min(100, parseInt(r[1], 10)) / 100,
                Math.min(100, parseInt(r[2], 10)) / 100,
                Math.min(100, parseInt(r[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (r =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              n(r[4]),
              this.setHSL(
                parseFloat(r[1]) / 360,
                parseFloat(r[2]) / 100,
                parseFloat(r[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      let n = i[1],
        r = n.length;
      if (3 === r)
        return this.setRGB(
          parseInt(n.charAt(0), 16) / 15,
          parseInt(n.charAt(1), 16) / 15,
          parseInt(n.charAt(2), 16) / 15,
          t
        );
      if (6 === r) return this.setHex(parseInt(n, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = g) {
    let i = tf[e.toLowerCase()];
    return (
      void 0 !== i
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = J(e.r)), (this.g = J(e.g)), (this.b = J(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Y(e.r)), (this.g = Y(e.g)), (this.b = Y(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = g) {
    return (
      q.fromWorkingColorSpace(ty.copy(this), e),
      65536 * Math.round(P(255 * ty.r, 0, 255)) +
        256 * Math.round(P(255 * ty.g, 0, 255)) +
        Math.round(P(255 * ty.b, 0, 255))
    );
  }
  getHexString(e = g) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = q.workingColorSpace) {
    let i, n;
    q.fromWorkingColorSpace(ty.copy(this), t);
    let r = ty.r,
      s = ty.g,
      a = ty.b,
      o = Math.max(r, s, a),
      l = Math.min(r, s, a),
      h = (l + o) / 2;
    if (l === o) (i = 0), (n = 0);
    else {
      let e = o - l;
      switch (((n = h <= 0.5 ? e / (o + l) : e / (2 - o - l)), o)) {
        case r:
          i = (s - a) / e + (s < a ? 6 : 0);
          break;
        case s:
          i = (a - r) / e + 2;
          break;
        case a:
          i = (r - s) / e + 4;
      }
      i /= 6;
    }
    return (e.h = i), (e.s = n), (e.l = h), e;
  }
  getRGB(e, t = q.workingColorSpace) {
    return (
      q.fromWorkingColorSpace(ty.copy(this), t),
      (e.r = ty.r),
      (e.g = ty.g),
      (e.b = ty.b),
      e
    );
  }
  getStyle(e = g) {
    q.fromWorkingColorSpace(ty.copy(this), e);
    let t = ty.r,
      i = ty.g,
      n = ty.b;
    return e !== g
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})`
      : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(
          255 * n
        )})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(tg), this.setHSL(tg.h + e, tg.s + t, tg.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(tg), e.getHSL(t_);
    let i = N(tg.h, t_.h, t),
      n = N(tg.s, t_.s, t),
      r = N(tg.l, t_.l, t);
    return this.setHSL(i, n, r), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    let t = this.r,
      i = this.g,
      n = this.b,
      r = e.elements;
    return (
      (this.r = r[0] * t + r[3] * i + r[6] * n),
      (this.g = r[1] * t + r[4] * i + r[7] * n),
      (this.b = r[2] * t + r[5] * i + r[8] * n),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ty = new tx();
tx.NAMES = tf;
let tM = 0;
class tS extends T {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: tM++ }),
      (this.uuid = C()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = 1),
      (this.side = 0),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = 100),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new tx(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = 7680),
      (this.stencilZFail = 7680),
      (this.stencilZPass = 7680),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (void 0 !== e)
      for (let t in e) {
        let i = e[t];
        if (void 0 === i) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        let n = this[t];
        if (void 0 === n) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        n && n.isColor
          ? n.set(i)
          : n && n.isVector3 && i && i.isVector3
          ? n.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    let t = void 0 === e || "string" == typeof e;
    t && (e = { textures: {}, images: {} });
    let i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    function n(e) {
      let t = [];
      for (let i in e) {
        let n = e[i];
        delete n.metadata, t.push(n);
      }
      return t;
    }
    if (
      ((i.uuid = this.uuid),
      (i.type = this.type),
      "" !== this.name && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      void 0 !== this.roughness && (i.roughness = this.roughness),
      void 0 !== this.metalness && (i.metalness = this.metalness),
      void 0 !== this.sheen && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      void 0 !== this.sheenRoughness &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      void 0 !== this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      void 0 !== this.specularIntensity &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      void 0 !== this.shininess && (i.shininess = this.shininess),
      void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
      void 0 !== this.clearcoatRoughness &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      void 0 !== this.dispersion && (i.dispersion = this.dispersion),
      void 0 !== this.iridescence && (i.iridescence = this.iridescence),
      void 0 !== this.iridescenceIOR &&
        (i.iridescenceIOR = this.iridescenceIOR),
      void 0 !== this.iridescenceThicknessRange &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy),
      void 0 !== this.anisotropyRotation &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        void 0 !== this.combine && (i.combine = this.combine)),
      void 0 !== this.envMapRotation &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      void 0 !== this.envMapIntensity &&
        (i.envMapIntensity = this.envMapIntensity),
      void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
      void 0 !== this.refractionRatio &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      void 0 !== this.transmission && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      void 0 !== this.thickness && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      void 0 !== this.attenuationDistance &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      void 0 !== this.attenuationColor &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      void 0 !== this.size && (i.size = this.size),
      null !== this.shadowSide && (i.shadowSide = this.shadowSide),
      void 0 !== this.sizeAttenuation &&
        (i.sizeAttenuation = this.sizeAttenuation),
      1 !== this.blending && (i.blending = this.blending),
      0 !== this.side && (i.side = this.side),
      !0 === this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      !0 === this.transparent && (i.transparent = !0),
      204 !== this.blendSrc && (i.blendSrc = this.blendSrc),
      205 !== this.blendDst && (i.blendDst = this.blendDst),
      100 !== this.blendEquation && (i.blendEquation = this.blendEquation),
      null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha),
      null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha),
      null !== this.blendEquationAlpha &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha),
      3 !== this.depthFunc && (i.depthFunc = this.depthFunc),
      !1 === this.depthTest && (i.depthTest = this.depthTest),
      !1 === this.depthWrite && (i.depthWrite = this.depthWrite),
      !1 === this.colorWrite && (i.colorWrite = this.colorWrite),
      255 !== this.stencilWriteMask &&
        (i.stencilWriteMask = this.stencilWriteMask),
      519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc),
      0 !== this.stencilRef && (i.stencilRef = this.stencilRef),
      255 !== this.stencilFuncMask &&
        (i.stencilFuncMask = this.stencilFuncMask),
      7680 !== this.stencilFail && (i.stencilFail = this.stencilFail),
      7680 !== this.stencilZFail && (i.stencilZFail = this.stencilZFail),
      7680 !== this.stencilZPass && (i.stencilZPass = this.stencilZPass),
      !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite),
      void 0 !== this.rotation &&
        0 !== this.rotation &&
        (i.rotation = this.rotation),
      !0 === this.polygonOffset && (i.polygonOffset = !0),
      0 !== this.polygonOffsetFactor &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      0 !== this.polygonOffsetUnits &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      void 0 !== this.linewidth &&
        1 !== this.linewidth &&
        (i.linewidth = this.linewidth),
      void 0 !== this.dashSize && (i.dashSize = this.dashSize),
      void 0 !== this.gapSize && (i.gapSize = this.gapSize),
      void 0 !== this.scale && (i.scale = this.scale),
      !0 === this.dithering && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      !0 === this.alphaHash && (i.alphaHash = !0),
      !0 === this.alphaToCoverage && (i.alphaToCoverage = !0),
      !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0),
      !0 === this.forceSinglePass && (i.forceSinglePass = !0),
      !0 === this.wireframe && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      "round" !== this.wireframeLinecap &&
        (i.wireframeLinecap = this.wireframeLinecap),
      "round" !== this.wireframeLinejoin &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      !0 === this.flatShading && (i.flatShading = !0),
      !1 === this.visible && (i.visible = !1),
      !1 === this.toneMapped && (i.toneMapped = !1),
      !1 === this.fog && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t)
    ) {
      let t = n(e.textures),
        r = n(e.images);
      t.length > 0 && (i.textures = t), r.length > 0 && (i.images = r);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    let t = e.clippingPlanes,
      i = null;
    if (null !== t) {
      let e = t.length;
      i = Array(e);
      for (let n = 0; n !== e; ++n) i[n] = t[n].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class tb extends tS {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new tx(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new eq()),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const tT = new eo(),
  tE = new U();
class tw {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = 35044),
      (this.updateRanges = []),
      (this.gpuType = 1015),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let n = 0, r = this.itemSize; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (2 === this.itemSize)
      for (let t = 0, i = this.count; t < i; t++)
        tE.fromBufferAttribute(this, t),
          tE.applyMatrix3(e),
          this.setXY(t, tE.x, tE.y);
    else if (3 === this.itemSize)
      for (let t = 0, i = this.count; t < i; t++)
        tT.fromBufferAttribute(this, t),
          tT.applyMatrix3(e),
          this.setXYZ(t, tT.x, tT.y, tT.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      tT.fromBufferAttribute(this, t),
        tT.applyMatrix4(e),
        this.setXYZ(t, tT.x, tT.y, tT.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      tT.fromBufferAttribute(this, t),
        tT.applyNormalMatrix(e),
        this.setXYZ(t, tT.x, tT.y, tT.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      tT.fromBufferAttribute(this, t),
        tT.transformDirection(e),
        this.setXYZ(t, tT.x, tT.y, tT.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = I(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = D(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = I(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = I(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = I(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = I(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = D(t, this.array)), (i = D(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = D(t, this.array)),
        (i = D(i, this.array)),
        (n = D(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = n),
      this
    );
  }
  setXYZW(e, t, i, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = D(t, this.array)),
        (i = D(i, this.array)),
        (n = D(n, this.array)),
        (r = D(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = n),
      (this.array[e + 3] = r),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    let e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      "" !== this.name && (e.name = this.name),
      35044 !== this.usage && (e.usage = this.usage),
      e
    );
  }
}
class tA extends tw {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class tR extends tw {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class tC extends tw {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let tP = 0;
const tL = new ez(),
  tN = new te(),
  tI = new eo(),
  tD = new ec(),
  tO = new ec(),
  tU = new eo();
class tz extends T {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: tP++ }),
      (this.uuid = C()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (B(e) ? tR : tA)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return void 0 !== this.attributes[e];
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    let t = this.attributes.position;
    void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
    let i = this.attributes.normal;
    if (void 0 !== i) {
      let t = new z().getNormalMatrix(e);
      i.applyNormalMatrix(t), (i.needsUpdate = !0);
    }
    let n = this.attributes.tangent;
    return (
      void 0 !== n && (n.transformDirection(e), (n.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return tL.makeRotationFromQuaternion(e), this.applyMatrix4(tL), this;
  }
  rotateX(e) {
    return tL.makeRotationX(e), this.applyMatrix4(tL), this;
  }
  rotateY(e) {
    return tL.makeRotationY(e), this.applyMatrix4(tL), this;
  }
  rotateZ(e) {
    return tL.makeRotationZ(e), this.applyMatrix4(tL), this;
  }
  translate(e, t, i) {
    return tL.makeTranslation(e, t, i), this.applyMatrix4(tL), this;
  }
  scale(e, t, i) {
    return tL.makeScale(e, t, i), this.applyMatrix4(tL), this;
  }
  lookAt(e) {
    return tN.lookAt(e), tN.updateMatrix(), this.applyMatrix4(tN.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(tI).negate(),
      this.translate(tI.x, tI.y, tI.z),
      this
    );
  }
  setFromPoints(e) {
    let t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      let n = e[i];
      t.push(n.x, n.y, n.z || 0);
    }
    return this.setAttribute("position", new tC(t, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new ec());
    let e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new eo(-1 / 0, -1 / 0, -1 / 0),
          new eo(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (void 0 !== e) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let e = 0, i = t.length; e < i; e++) {
          let i = t[e];
          tD.setFromBufferAttribute(i),
            this.morphTargetsRelative
              ? (tU.addVectors(this.boundingBox.min, tD.min),
                this.boundingBox.expandByPoint(tU),
                tU.addVectors(this.boundingBox.max, tD.max),
                this.boundingBox.expandByPoint(tU))
              : (this.boundingBox.expandByPoint(tD.min),
                this.boundingBox.expandByPoint(tD.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new eR());
    let e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new eo(), 1 / 0);
      return;
    }
    if (e) {
      let i = this.boundingSphere.center;
      if ((tD.setFromBufferAttribute(e), t))
        for (let e = 0, i = t.length; e < i; e++) {
          let i = t[e];
          tO.setFromBufferAttribute(i),
            this.morphTargetsRelative
              ? (tU.addVectors(tD.min, tO.min),
                tD.expandByPoint(tU),
                tU.addVectors(tD.max, tO.max),
                tD.expandByPoint(tU))
              : (tD.expandByPoint(tO.min), tD.expandByPoint(tO.max));
        }
      tD.getCenter(i);
      let n = 0;
      for (let t = 0, r = e.count; t < r; t++)
        tU.fromBufferAttribute(e, t),
          (n = Math.max(n, i.distanceToSquared(tU)));
      if (t)
        for (let r = 0, s = t.length; r < s; r++) {
          let s = t[r],
            a = this.morphTargetsRelative;
          for (let t = 0, r = s.count; t < r; t++)
            tU.fromBufferAttribute(s, t),
              a && (tI.fromBufferAttribute(e, t), tU.add(tI)),
              (n = Math.max(n, i.distanceToSquared(tU)));
        }
      (this.boundingSphere.radius = Math.sqrt(n)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    let e = this.index,
      t = this.attributes;
    if (
      null === e ||
      void 0 === t.position ||
      void 0 === t.normal ||
      void 0 === t.uv
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    let i = t.position,
      n = t.normal,
      r = t.uv;
    !1 === this.hasAttribute("tangent") &&
      this.setAttribute("tangent", new tw(new Float32Array(4 * i.count), 4));
    let s = this.getAttribute("tangent"),
      a = [],
      o = [];
    for (let e = 0; e < i.count; e++) (a[e] = new eo()), (o[e] = new eo());
    let l = new eo(),
      h = new eo(),
      c = new eo(),
      u = new U(),
      d = new U(),
      p = new U(),
      m = new eo(),
      f = new eo(),
      g = this.groups;
    0 === g.length && (g = [{ start: 0, count: e.count }]);
    for (let t = 0, n = g.length; t < n; ++t) {
      let n = g[t],
        s = n.start,
        _ = n.count;
      for (let t = s, n = s + _; t < n; t += 3)
        !(function (e, t, n) {
          l.fromBufferAttribute(i, e),
            h.fromBufferAttribute(i, t),
            c.fromBufferAttribute(i, n),
            u.fromBufferAttribute(r, e),
            d.fromBufferAttribute(r, t),
            p.fromBufferAttribute(r, n),
            h.sub(l),
            c.sub(l),
            d.sub(u),
            p.sub(u);
          let s = 1 / (d.x * p.y - p.x * d.y);
          isFinite(s) &&
            (m
              .copy(h)
              .multiplyScalar(p.y)
              .addScaledVector(c, -d.y)
              .multiplyScalar(s),
            f
              .copy(c)
              .multiplyScalar(d.x)
              .addScaledVector(h, -p.x)
              .multiplyScalar(s),
            a[e].add(m),
            a[t].add(m),
            a[n].add(m),
            o[e].add(f),
            o[t].add(f),
            o[n].add(f));
        })(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2));
    }
    let _ = new eo(),
      v = new eo(),
      x = new eo(),
      y = new eo();
    function M(e) {
      x.fromBufferAttribute(n, e), y.copy(x);
      let t = a[e];
      _.copy(t),
        _.sub(x.multiplyScalar(x.dot(t))).normalize(),
        v.crossVectors(y, t);
      let i = v.dot(o[e]);
      s.setXYZW(e, _.x, _.y, _.z, i < 0 ? -1 : 1);
    }
    for (let t = 0, i = g.length; t < i; ++t) {
      let i = g[t],
        n = i.start,
        r = i.count;
      for (let t = n, i = n + r; t < i; t += 3)
        M(e.getX(t + 0)), M(e.getX(t + 1)), M(e.getX(t + 2));
    }
  }
  computeVertexNormals() {
    let e = this.index,
      t = this.getAttribute("position");
    if (void 0 !== t) {
      let i = this.getAttribute("normal");
      if (void 0 === i)
        (i = new tw(new Float32Array(3 * t.count), 3)),
          this.setAttribute("normal", i);
      else for (let e = 0, t = i.count; e < t; e++) i.setXYZ(e, 0, 0, 0);
      let n = new eo(),
        r = new eo(),
        s = new eo(),
        a = new eo(),
        o = new eo(),
        l = new eo(),
        h = new eo(),
        c = new eo();
      if (e)
        for (let u = 0, d = e.count; u < d; u += 3) {
          let d = e.getX(u + 0),
            p = e.getX(u + 1),
            m = e.getX(u + 2);
          n.fromBufferAttribute(t, d),
            r.fromBufferAttribute(t, p),
            s.fromBufferAttribute(t, m),
            h.subVectors(s, r),
            c.subVectors(n, r),
            h.cross(c),
            a.fromBufferAttribute(i, d),
            o.fromBufferAttribute(i, p),
            l.fromBufferAttribute(i, m),
            a.add(h),
            o.add(h),
            l.add(h),
            i.setXYZ(d, a.x, a.y, a.z),
            i.setXYZ(p, o.x, o.y, o.z),
            i.setXYZ(m, l.x, l.y, l.z);
        }
      else
        for (let e = 0, a = t.count; e < a; e += 3)
          n.fromBufferAttribute(t, e + 0),
            r.fromBufferAttribute(t, e + 1),
            s.fromBufferAttribute(t, e + 2),
            h.subVectors(s, r),
            c.subVectors(n, r),
            h.cross(c),
            i.setXYZ(e + 0, h.x, h.y, h.z),
            i.setXYZ(e + 1, h.x, h.y, h.z),
            i.setXYZ(e + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    let e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      tU.fromBufferAttribute(e, t),
        tU.normalize(),
        e.setXYZ(t, tU.x, tU.y, tU.z);
  }
  toNonIndexed() {
    function e(e, t) {
      let i = e.array,
        n = e.itemSize,
        r = e.normalized,
        s = new i.constructor(t.length * n),
        a = 0,
        o = 0;
      for (let r = 0, l = t.length; r < l; r++) {
        a = e.isInterleavedBufferAttribute
          ? t[r] * e.data.stride + e.offset
          : t[r] * n;
        for (let e = 0; e < n; e++) s[o++] = i[a++];
      }
      return new tw(s, n, r);
    }
    if (null === this.index)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    let t = new tz(),
      i = this.index.array,
      n = this.attributes;
    for (let r in n) {
      let s = e(n[r], i);
      t.setAttribute(r, s);
    }
    let r = this.morphAttributes;
    for (let n in r) {
      let s = [],
        a = r[n];
      for (let t = 0, n = a.length; t < n; t++) {
        let n = e(a[t], i);
        s.push(n);
      }
      t.morphAttributes[n] = s;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    let s = this.groups;
    for (let e = 0, i = s.length; e < i; e++) {
      let i = s[e];
      t.addGroup(i.start, i.count, i.materialIndex);
    }
    return t;
  }
  toJSON() {
    let e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      "" !== this.name && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      let t = this.parameters;
      for (let i in t) void 0 !== t[i] && (e[i] = t[i]);
      return e;
    }
    e.data = { attributes: {} };
    let t = this.index;
    null !== t &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    let i = this.attributes;
    for (let t in i) {
      let n = i[t];
      e.data.attributes[t] = n.toJSON(e.data);
    }
    let n = {},
      r = !1;
    for (let t in this.morphAttributes) {
      let i = this.morphAttributes[t],
        s = [];
      for (let t = 0, n = i.length; t < n; t++) {
        let n = i[t];
        s.push(n.toJSON(e.data));
      }
      s.length > 0 && ((n[t] = s), (r = !0));
    }
    r &&
      ((e.data.morphAttributes = n),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    let s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    let a = this.boundingSphere;
    return (
      null !== a &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    let t = {};
    this.name = e.name;
    let i = e.index;
    null !== i && this.setIndex(i.clone(t));
    let n = e.attributes;
    for (let e in n) {
      let i = n[e];
      this.setAttribute(e, i.clone(t));
    }
    let r = e.morphAttributes;
    for (let e in r) {
      let i = [],
        n = r[e];
      for (let e = 0, r = n.length; e < r; e++) i.push(n[e].clone(t));
      this.morphAttributes[e] = i;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    let s = e.groups;
    for (let e = 0, t = s.length; e < t; e++) {
      let t = s[e];
      this.addGroup(t.start, t.count, t.materialIndex);
    }
    let a = e.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    let o = e.boundingSphere;
    return (
      null !== o && (this.boundingSphere = o.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const tF = new ez(),
  tB = new eU(),
  tk = new eR(),
  tH = new eo(),
  tV = new eo(),
  tG = new eo(),
  tW = new eo(),
  tX = new eo(),
  tj = new eo(),
  tq = new eo(),
  tJ = new eo();
class tY extends te {
  constructor(e = new tz(), t = new tb()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      void 0 !== e.morphTargetInfluences &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      void 0 !== e.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    let e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      let i = e[t[0]];
      if (void 0 !== i) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let e = 0, t = i.length; e < t; e++) {
          let t = i[e].name || String(e);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[t] = e);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    let i = this.geometry,
      n = i.attributes.position,
      r = i.morphAttributes.position,
      s = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    let a = this.morphTargetInfluences;
    if (r && a) {
      tj.set(0, 0, 0);
      for (let i = 0, n = r.length; i < n; i++) {
        let n = a[i],
          o = r[i];
        0 !== n &&
          (tX.fromBufferAttribute(o, e),
          s ? tj.addScaledVector(tX, n) : tj.addScaledVector(tX.sub(t), n));
      }
      t.add(tj);
    }
    return t;
  }
  raycast(e, t) {
    let i = this.geometry,
      n = this.material,
      r = this.matrixWorld;
    if (void 0 !== n) {
      if (
        (null === i.boundingSphere && i.computeBoundingSphere(),
        tk.copy(i.boundingSphere),
        tk.applyMatrix4(r),
        tB.copy(e.ray).recast(e.near),
        (!1 === tk.containsPoint(tB.origin) &&
          (null === tB.intersectSphere(tk, tH) ||
            tB.origin.distanceToSquared(tH) > (e.far - e.near) ** 2)) ||
          (tF.copy(r).invert(),
          tB.copy(e.ray).applyMatrix4(tF),
          null !== i.boundingBox && !1 === tB.intersectsBox(i.boundingBox)))
      )
        return;
      this._computeIntersections(e, t, tB);
    }
  }
  _computeIntersections(e, t, i) {
    let n;
    let r = this.geometry,
      s = this.material,
      a = r.index,
      o = r.attributes.position,
      l = r.attributes.uv,
      h = r.attributes.uv1,
      c = r.attributes.normal,
      u = r.groups,
      d = r.drawRange;
    if (null !== a) {
      if (Array.isArray(s))
        for (let r = 0, o = u.length; r < o; r++) {
          let o = u[r],
            p = s[o.materialIndex],
            m = Math.max(o.start, d.start),
            f = Math.min(
              a.count,
              Math.min(o.start + o.count, d.start + d.count)
            );
          for (let r = m; r < f; r += 3)
            (n = tK(
              this,
              p,
              e,
              i,
              l,
              h,
              c,
              a.getX(r),
              a.getX(r + 1),
              a.getX(r + 2)
            )) &&
              ((n.faceIndex = Math.floor(r / 3)),
              (n.face.materialIndex = o.materialIndex),
              t.push(n));
        }
      else {
        let r = Math.max(0, d.start),
          o = Math.min(a.count, d.start + d.count);
        for (let u = r; u < o; u += 3)
          (n = tK(
            this,
            s,
            e,
            i,
            l,
            h,
            c,
            a.getX(u),
            a.getX(u + 1),
            a.getX(u + 2)
          )) && ((n.faceIndex = Math.floor(u / 3)), t.push(n));
      }
    } else if (void 0 !== o) {
      if (Array.isArray(s))
        for (let r = 0, a = u.length; r < a; r++) {
          let a = u[r],
            p = s[a.materialIndex],
            m = Math.max(a.start, d.start),
            f = Math.min(
              o.count,
              Math.min(a.start + a.count, d.start + d.count)
            );
          for (let r = m; r < f; r += 3)
            (n = tK(this, p, e, i, l, h, c, r, r + 1, r + 2)) &&
              ((n.faceIndex = Math.floor(r / 3)),
              (n.face.materialIndex = a.materialIndex),
              t.push(n));
        }
      else {
        let r = Math.max(0, d.start),
          a = Math.min(o.count, d.start + d.count);
        for (let o = r; o < a; o += 3)
          (n = tK(this, s, e, i, l, h, c, o, o + 1, o + 2)) &&
            ((n.faceIndex = Math.floor(o / 3)), t.push(n));
      }
    }
  }
}
function tK(e, t, i, n, r, s, a, o, l, h) {
  e.getVertexPosition(o, tV),
    e.getVertexPosition(l, tG),
    e.getVertexPosition(h, tW);
  let c = (function (e, t, i, n, r, s, a, o) {
    if (
      null ===
      (1 === t.side
        ? n.intersectTriangle(a, s, r, !0, o)
        : n.intersectTriangle(r, s, a, 0 === t.side, o))
    )
      return null;
    tJ.copy(o), tJ.applyMatrix4(e.matrixWorld);
    let l = i.ray.origin.distanceTo(tJ);
    return l < i.near || l > i.far
      ? null
      : { distance: l, point: tJ.clone(), object: e };
  })(e, t, i, n, tV, tG, tW, tq);
  if (c) {
    let e = new eo();
    tm.getBarycoord(tq, tV, tG, tW, e),
      r && (c.uv = tm.getInterpolatedAttribute(r, o, l, h, e, new U())),
      s && (c.uv1 = tm.getInterpolatedAttribute(s, o, l, h, e, new U())),
      a &&
        ((c.normal = tm.getInterpolatedAttribute(a, o, l, h, e, new eo())),
        c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1));
    let t = { a: o, b: l, c: h, normal: new eo(), materialIndex: 0 };
    tm.getNormal(tV, tG, tW, t.normal), (c.face = t), (c.barycoord = e);
  }
  return c;
}
class tZ extends tz {
  constructor(e = 1, t = 1, i = 1, n = 1, r = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: n,
        heightSegments: r,
        depthSegments: s,
      });
    let a = this;
    (n = Math.floor(n)), (r = Math.floor(r));
    let o = [],
      l = [],
      h = [],
      c = [],
      u = 0,
      d = 0;
    function p(e, t, i, n, r, s, p, m, f, g, _) {
      let v = s / f,
        x = p / g,
        y = s / 2,
        M = p / 2,
        S = m / 2,
        b = f + 1,
        T = g + 1,
        E = 0,
        w = 0,
        A = new eo();
      for (let s = 0; s < T; s++) {
        let a = s * x - M;
        for (let o = 0; o < b; o++) {
          let u = o * v - y;
          (A[e] = u * n),
            (A[t] = a * r),
            (A[i] = S),
            l.push(A.x, A.y, A.z),
            (A[e] = 0),
            (A[t] = 0),
            (A[i] = m > 0 ? 1 : -1),
            h.push(A.x, A.y, A.z),
            c.push(o / f),
            c.push(1 - s / g),
            (E += 1);
        }
      }
      for (let e = 0; e < g; e++)
        for (let t = 0; t < f; t++) {
          let i = u + t + b * e,
            n = u + t + b * (e + 1),
            r = u + (t + 1) + b * (e + 1),
            s = u + (t + 1) + b * e;
          o.push(i, n, s), o.push(n, r, s), (w += 6);
        }
      a.addGroup(d, w, _), (d += w), (u += E);
    }
    p("z", "y", "x", -1, -1, i, t, e, (s = Math.floor(s)), r, 0),
      p("z", "y", "x", 1, -1, i, t, -e, s, r, 1),
      p("x", "z", "y", 1, 1, e, i, t, n, s, 2),
      p("x", "z", "y", 1, -1, e, i, -t, n, s, 3),
      p("x", "y", "z", 1, -1, e, t, i, n, r, 4),
      p("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
      this.setIndex(o),
      this.setAttribute("position", new tC(l, 3)),
      this.setAttribute("normal", new tC(h, 3)),
      this.setAttribute("uv", new tC(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new tZ(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function tQ(e) {
  let t = {};
  for (let i in e)
    for (let n in ((t[i] = {}), e[i])) {
      let r = e[i][n];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (t[i][n] = null))
          : (t[i][n] = r.clone())
        : Array.isArray(r)
        ? (t[i][n] = r.slice())
        : (t[i][n] = r);
    }
  return t;
}
function t$(e) {
  let t = {};
  for (let i = 0; i < e.length; i++) {
    let n = tQ(e[i]);
    for (let e in n) t[e] = n[e];
  }
  return t;
}
function t0(e) {
  let t = e.getRenderTarget();
  return null === t
    ? e.outputColorSpace
    : !0 === t.isXRRenderTarget
    ? t.texture.colorSpace
    : q.workingColorSpace;
}
const t1 = { clone: tQ, merge: t$ };
class t2 extends tS {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader =
        "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
      (this.fragmentShader =
        "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      void 0 !== e && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = tQ(e.uniforms)),
      (this.uniformsGroups = (function (e) {
        let t = [];
        for (let i = 0; i < e.length; i++) t.push(e[i].clone());
        return t;
      })(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    let t = super.toJSON(e);
    for (let i in ((t.glslVersion = this.glslVersion),
    (t.uniforms = {}),
    this.uniforms)) {
      let n = this.uniforms[i].value;
      n && n.isTexture
        ? (t.uniforms[i] = { type: "t", value: n.toJSON(e).uuid })
        : n && n.isColor
        ? (t.uniforms[i] = { type: "c", value: n.getHex() })
        : n && n.isVector2
        ? (t.uniforms[i] = { type: "v2", value: n.toArray() })
        : n && n.isVector3
        ? (t.uniforms[i] = { type: "v3", value: n.toArray() })
        : n && n.isVector4
        ? (t.uniforms[i] = { type: "v4", value: n.toArray() })
        : n && n.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: n.toArray() })
        : n && n.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: n.toArray() })
        : (t.uniforms[i] = { value: n });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    let i = {};
    for (let e in this.extensions) !0 === this.extensions[e] && (i[e] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class t3 extends te {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new ez()),
      (this.projectionMatrix = new ez()),
      (this.projectionMatrixInverse = new ez()),
      (this.coordinateSystem = 2e3);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const t5 = new eo(),
  t4 = new U(),
  t6 = new U();
class t7 extends t3 {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = n),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = null === e.view ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    let t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = 2 * R * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    let e = Math.tan(0.5 * A * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return 2 * R * Math.atan(Math.tan(0.5 * A * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    t5.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(t5.x, t5.y).multiplyScalar(-e / t5.z),
      t5.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(t5.x, t5.y).multiplyScalar(-e / t5.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, t4, t6), t.subVectors(t6, t4);
  }
  setViewOffset(e, t, i, n, r, s) {
    (this.aspect = e / t),
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = r),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    let e = this.near,
      t = (e * Math.tan(0.5 * A * this.fov)) / this.zoom,
      i = 2 * t,
      n = this.aspect * i,
      r = -0.5 * n,
      s = this.view;
    if (null !== this.view && this.view.enabled) {
      let e = s.fullWidth,
        a = s.fullHeight;
      (r += (s.offsetX * n) / e),
        (t -= (s.offsetY * i) / a),
        (n *= s.width / e),
        (i *= s.height / a);
    }
    let a = this.filmOffset;
    0 !== a && (r += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        r,
        r + n,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    let t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      null !== this.view && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
class t8 extends te {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    let n = new t7(-90, 1, e, t);
    (n.layers = this.layers), this.add(n);
    let r = new t7(-90, 1, e, t);
    (r.layers = this.layers), this.add(r);
    let s = new t7(-90, 1, e, t);
    (s.layers = this.layers), this.add(s);
    let a = new t7(-90, 1, e, t);
    (a.layers = this.layers), this.add(a);
    let o = new t7(-90, 1, e, t);
    (o.layers = this.layers), this.add(o);
    let l = new t7(-90, 1, e, t);
    (l.layers = this.layers), this.add(l);
  }
  updateCoordinateSystem() {
    let e = this.coordinateSystem,
      t = this.children.concat(),
      [i, n, r, s, a, o] = t;
    for (let e of t) this.remove(e);
    if (2e3 === e)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        n.up.set(0, 1, 0),
        n.lookAt(-1, 0, 0),
        r.up.set(0, 0, -1),
        r.lookAt(0, 1, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, -1);
    else if (2001 === e)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        n.up.set(0, -1, 0),
        n.lookAt(1, 0, 0),
        r.up.set(0, 0, 1),
        r.lookAt(0, 1, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, -1);
    else
      throw Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (let e of t) this.add(e), e.updateMatrixWorld();
  }
  update(e, t) {
    null === this.parent && this.updateMatrixWorld();
    let { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    let [r, s, a, o, l, h] = this.children,
      c = e.getRenderTarget(),
      u = e.getActiveCubeFace(),
      d = e.getActiveMipmapLevel(),
      p = e.xr.enabled;
    e.xr.enabled = !1;
    let m = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, n),
      e.render(t, r),
      e.setRenderTarget(i, 1, n),
      e.render(t, s),
      e.setRenderTarget(i, 2, n),
      e.render(t, a),
      e.setRenderTarget(i, 3, n),
      e.render(t, o),
      e.setRenderTarget(i, 4, n),
      e.render(t, l),
      (i.texture.generateMipmaps = m),
      e.setRenderTarget(i, 5, n),
      e.render(t, h),
      e.setRenderTarget(c, u, d),
      (e.xr.enabled = p),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class t9 extends et {
  constructor(e, t, i, n, r, s, a, o, l, h) {
    super(
      (e = void 0 !== e ? e : []),
      (t = void 0 !== t ? t : 301),
      i,
      n,
      r,
      s,
      a,
      o,
      l,
      h
    ),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class ie extends er {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    let i = { width: e, height: e, depth: 1 };
    (this.texture = new t9(
      [i, i, i, i, i, i],
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        void 0 !== t.generateMipmaps && t.generateMipmaps),
      (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : 1006);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    let i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      n = new tZ(5, 5, 5),
      r = new t2({
        name: "CubemapFromEquirect",
        uniforms: tQ(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: 1,
        blending: 0,
      });
    r.uniforms.tEquirect.value = t;
    let s = new tY(n, r),
      a = t.minFilter;
    return (
      1008 === t.minFilter && (t.minFilter = 1006),
      new t8(1, 10, this).update(e, s),
      (t.minFilter = a),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, t, i, n) {
    let r = e.getRenderTarget();
    for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, i, n);
    e.setRenderTarget(r);
  }
}
const it = new eo(),
  ii = new eo(),
  ir = new z();
class is {
  constructor(e = new eo(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), (this.constant = n), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    let n = it.subVectors(i, t).cross(ii.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    let e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    let i = e.delta(it),
      n = this.normal.dot(i);
    if (0 === n)
      return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
    let r = -(e.start.dot(this.normal) + this.constant) / n;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
  }
  intersectsLine(e) {
    let t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    let i = t || ir.getNormalMatrix(e),
      n = this.coplanarPoint(it).applyMatrix4(e),
      r = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -n.dot(r)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ia = new eR(),
  io = new eo();
class il {
  constructor(
    e = new is(),
    t = new is(),
    i = new is(),
    n = new is(),
    r = new is(),
    s = new is()
  ) {
    this.planes = [e, t, i, n, r, s];
  }
  set(e, t, i, n, r, s) {
    let a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(n),
      a[4].copy(r),
      a[5].copy(s),
      this
    );
  }
  copy(e) {
    let t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = 2e3) {
    let i = this.planes,
      n = e.elements,
      r = n[0],
      s = n[1],
      a = n[2],
      o = n[3],
      l = n[4],
      h = n[5],
      c = n[6],
      u = n[7],
      d = n[8],
      p = n[9],
      m = n[10],
      f = n[11],
      g = n[12],
      _ = n[13],
      v = n[14],
      x = n[15];
    if (
      (i[0].setComponents(o - r, u - l, f - d, x - g).normalize(),
      i[1].setComponents(o + r, u + l, f + d, x + g).normalize(),
      i[2].setComponents(o + s, u + h, f + p, x + _).normalize(),
      i[3].setComponents(o - s, u - h, f - p, x - _).normalize(),
      i[4].setComponents(o - a, u - c, f - m, x - v).normalize(),
      2e3 === t)
    )
      i[5].setComponents(o + a, u + c, f + m, x + v).normalize();
    else if (2001 === t) i[5].setComponents(a, c, m, v).normalize();
    else
      throw Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (void 0 !== e.boundingSphere)
      null === e.boundingSphere && e.computeBoundingSphere(),
        ia.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      let t = e.geometry;
      null === t.boundingSphere && t.computeBoundingSphere(),
        ia.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ia);
  }
  intersectsSprite(e) {
    return (
      ia.center.set(0, 0, 0),
      (ia.radius = 0.7071067811865476),
      ia.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(ia)
    );
  }
  intersectsSphere(e) {
    let t = this.planes,
      i = e.center,
      n = -e.radius;
    for (let e = 0; e < 6; e++) if (t[e].distanceToPoint(i) < n) return !1;
    return !0;
  }
  intersectsBox(e) {
    let t = this.planes;
    for (let i = 0; i < 6; i++) {
      let n = t[i];
      if (
        ((io.x = n.normal.x > 0 ? e.max.x : e.min.x),
        (io.y = n.normal.y > 0 ? e.max.y : e.min.y),
        (io.z = n.normal.z > 0 ? e.max.z : e.min.z),
        0 > n.distanceToPoint(io))
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    let t = this.planes;
    for (let i = 0; i < 6; i++) if (0 > t[i].distanceToPoint(e)) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function ih() {
  let e = null,
    t = !1,
    i = null,
    n = null;
  function r(t, s) {
    i(t, s), (n = e.requestAnimationFrame(r));
  }
  return {
    start: function () {
      !0 !== t && null !== i && ((n = e.requestAnimationFrame(r)), (t = !0));
    },
    stop: function () {
      e.cancelAnimationFrame(n), (t = !1);
    },
    setAnimationLoop: function (e) {
      i = e;
    },
    setContext: function (t) {
      e = t;
    },
  };
}
function ic(e) {
  let t = new WeakMap();
  return {
    get: function (e) {
      return e.isInterleavedBufferAttribute && (e = e.data), t.get(e);
    },
    remove: function (i) {
      i.isInterleavedBufferAttribute && (i = i.data);
      let n = t.get(i);
      n && (e.deleteBuffer(n.buffer), t.delete(i));
    },
    update: function (i, n) {
      if (
        (i.isInterleavedBufferAttribute && (i = i.data), i.isGLBufferAttribute)
      ) {
        let e = t.get(i);
        (!e || e.version < i.version) &&
          t.set(i, {
            buffer: i.buffer,
            type: i.type,
            bytesPerElement: i.elementSize,
            version: i.version,
          });
        return;
      }
      let r = t.get(i);
      if (void 0 === r)
        t.set(
          i,
          (function (t, i) {
            let n;
            let r = t.array,
              s = t.usage,
              a = r.byteLength,
              o = e.createBuffer();
            if (
              (e.bindBuffer(i, o),
              e.bufferData(i, r, s),
              t.onUploadCallback(),
              r instanceof Float32Array)
            )
              n = e.FLOAT;
            else if (r instanceof Uint16Array)
              n = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
            else if (r instanceof Int16Array) n = e.SHORT;
            else if (r instanceof Uint32Array) n = e.UNSIGNED_INT;
            else if (r instanceof Int32Array) n = e.INT;
            else if (r instanceof Int8Array) n = e.BYTE;
            else if (r instanceof Uint8Array) n = e.UNSIGNED_BYTE;
            else if (r instanceof Uint8ClampedArray) n = e.UNSIGNED_BYTE;
            else
              throw Error(
                "THREE.WebGLAttributes: Unsupported buffer data format: " + r
              );
            return {
              buffer: o,
              type: n,
              bytesPerElement: r.BYTES_PER_ELEMENT,
              version: t.version,
              size: a,
            };
          })(i, n)
        );
      else if (r.version < i.version) {
        if (r.size !== i.array.byteLength)
          throw Error(
            "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
          );
        !(function (t, i, n) {
          let r = i.array,
            s = i.updateRanges;
          if ((e.bindBuffer(n, t), 0 === s.length)) e.bufferSubData(n, 0, r);
          else {
            s.sort((e, t) => e.start - t.start);
            let t = 0;
            for (let e = 1; e < s.length; e++) {
              let i = s[t],
                n = s[e];
              n.start <= i.start + i.count + 1
                ? (i.count = Math.max(i.count, n.start + n.count - i.start))
                : (s[++t] = n);
            }
            s.length = t + 1;
            for (let t = 0, i = s.length; t < i; t++) {
              let i = s[t];
              e.bufferSubData(
                n,
                i.start * r.BYTES_PER_ELEMENT,
                r,
                i.start,
                i.count
              );
            }
            i.clearUpdateRanges();
          }
          i.onUploadCallback();
        })(r.buffer, i, n),
          (r.version = i.version);
      }
    },
  };
}
class iu extends tz {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: n,
      });
    let r = e / 2,
      s = t / 2,
      a = Math.floor(i),
      o = Math.floor(n),
      l = a + 1,
      h = o + 1,
      c = e / a,
      u = t / o,
      d = [],
      p = [],
      m = [],
      f = [];
    for (let e = 0; e < h; e++) {
      let t = e * u - s;
      for (let i = 0; i < l; i++) {
        let n = i * c - r;
        p.push(n, -t, 0), m.push(0, 0, 1), f.push(i / a), f.push(1 - e / o);
      }
    }
    for (let e = 0; e < o; e++)
      for (let t = 0; t < a; t++) {
        let i = t + l * e,
          n = t + l * (e + 1),
          r = t + 1 + l * (e + 1),
          s = t + 1 + l * e;
        d.push(i, n, s), d.push(n, r, s);
      }
    this.setIndex(d),
      this.setAttribute("position", new tC(p, 3)),
      this.setAttribute("normal", new tC(m, 3)),
      this.setAttribute("uv", new tC(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new iu(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
const id = {
    alphahash_fragment:
      "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
    alphahash_pars_fragment:
      "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif",
    alphamap_fragment:
      "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
    alphamap_pars_fragment:
      "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
    alphatest_fragment:
      "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif",
    alphatest_pars_fragment:
      "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
    aomap_fragment:
      "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
    aomap_pars_fragment:
      "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
    batching_pars_vertex:
      "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif",
    batching_vertex:
      "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
    begin_vertex:
      "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif",
    beginnormal_vertex:
      "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs:
      "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated",
    iridescence_fragment:
      "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",
    bumpmap_pars_fragment:
      "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
    clipping_planes_fragment:
      "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif",
    clipping_planes_pars_fragment:
      "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex:
      "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex:
      "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment:
      "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment:
      "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
    color_pars_vertex:
      "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif",
    color_vertex:
      "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif",
    common:
      "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
    cube_uv_reflection_fragment:
      "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
    defaultnormal_vertex:
      "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
    displacementmap_pars_vertex:
      "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
    displacementmap_vertex:
      "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment:
      "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment:
      "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    colorspace_pars_fragment:
      "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
    envmap_fragment:
      "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
    envmap_common_pars_fragment:
      "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
    envmap_pars_fragment:
      "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
    envmap_pars_vertex:
      "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
    envmap_physical_pars_fragment:
      "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif",
    envmap_vertex:
      "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
    fog_fragment:
      "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment:
      "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
    gradientmap_pars_fragment:
      "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",
    lightmap_pars_fragment:
      "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
    lights_lambert_fragment:
      "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
    lights_lambert_pars_fragment:
      "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert",
    lights_pars_begin:
      "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
    lights_toon_fragment:
      "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment:
      "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon",
    lights_phong_fragment:
      "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment:
      "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
    lights_physical_fragment:
      "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
    lights_physical_pars_fragment:
      "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin:
      "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps:
      "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
    lights_fragment_end:
      "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
    logdepthbuf_fragment:
      "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment:
      "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex:
      "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
    logdepthbuf_vertex:
      "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
    map_fragment:
      "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
    map_particle_fragment:
      "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment:
      "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment:
      "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment:
      "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
    morphinstance_vertex:
      "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif",
    morphcolor_vertex:
      "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
    morphnormal_vertex:
      "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif",
    morphtarget_pars_vertex:
      "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif",
    morphtarget_vertex:
      "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif",
    normal_fragment_begin:
      "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
    normal_fragment_maps:
      "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normal_pars_fragment:
      "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
    normal_pars_vertex:
      "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
    normal_vertex:
      "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
    normalmap_pars_fragment:
      "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif",
    clearcoat_normal_fragment_begin:
      "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
    clearcoat_normal_fragment_maps:
      "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
    clearcoat_pars_fragment:
      "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif",
    iridescence_pars_fragment:
      "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",
    opaque_fragment:
      "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    packing:
      "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}",
    premultiplied_alpha_fragment:
      "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex:
      "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment:
      "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment:
      "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
    roughnessmap_fragment:
      "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment:
      "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment:
      "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif",
    shadowmap_pars_vertex:
      "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
    shadowmap_vertex:
      "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif",
    shadowmask_pars_fragment:
      "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
    skinbase_vertex:
      "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex:
      "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif",
    skinning_vertex:
      "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex:
      "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
    specularmap_fragment:
      "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
    specularmap_pars_fragment:
      "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
    tonemapping_fragment:
      "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment:
      "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmission_fragment:
      "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
    transmission_pars_fragment:
      "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif",
    uv_pars_fragment:
      "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
    uv_pars_vertex:
      "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
    uv_vertex:
      "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
    worldpos_vertex:
      "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
    background_vert:
      "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    background_frag:
      "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
    backgroundCube_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
    backgroundCube_frag:
      "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
    cube_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
    cube_frag:
      "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
    depth_vert:
      "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
    depth_frag:
      "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}",
    distanceRGBA_vert:
      "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
    distanceRGBA_frag:
      "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
    equirect_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
    equirect_frag:
      "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
    linedashed_vert:
      "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
    linedashed_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert:
      "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
    meshbasic_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshlambert_vert:
      "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshlambert_frag:
      "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshmatcap_vert:
      "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
    meshmatcap_frag:
      "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshnormal_vert:
      "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
    meshnormal_frag:
      "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
    meshphong_vert:
      "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshphong_frag:
      "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshphysical_vert:
      "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
    meshphysical_frag:
      "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshtoon_vert:
      "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshtoon_frag:
      "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    points_vert:
      "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
    points_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    shadow_vert:
      "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    shadow_frag:
      "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",
    sprite_vert:
      "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
    sprite_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",
  },
  ip = {
    common: {
      diffuse: { value: new tx(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new z() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new z() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new z() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new z() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new z() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new z() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new z() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new z() },
      normalScale: { value: new U(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new z() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new z() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new z() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new z() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new tx(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new tx(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new z() },
      alphaTest: { value: 0 },
      uvTransform: { value: new z() },
    },
    sprite: {
      diffuse: { value: new tx(16777215) },
      opacity: { value: 1 },
      center: { value: new U(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new z() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new z() },
      alphaTest: { value: 0 },
    },
  },
  im = {
    basic: {
      uniforms: t$([
        ip.common,
        ip.specularmap,
        ip.envmap,
        ip.aomap,
        ip.lightmap,
        ip.fog,
      ]),
      vertexShader: id.meshbasic_vert,
      fragmentShader: id.meshbasic_frag,
    },
    lambert: {
      uniforms: t$([
        ip.common,
        ip.specularmap,
        ip.envmap,
        ip.aomap,
        ip.lightmap,
        ip.emissivemap,
        ip.bumpmap,
        ip.normalmap,
        ip.displacementmap,
        ip.fog,
        ip.lights,
        { emissive: { value: new tx(0) } },
      ]),
      vertexShader: id.meshlambert_vert,
      fragmentShader: id.meshlambert_frag,
    },
    phong: {
      uniforms: t$([
        ip.common,
        ip.specularmap,
        ip.envmap,
        ip.aomap,
        ip.lightmap,
        ip.emissivemap,
        ip.bumpmap,
        ip.normalmap,
        ip.displacementmap,
        ip.fog,
        ip.lights,
        {
          emissive: { value: new tx(0) },
          specular: { value: new tx(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: id.meshphong_vert,
      fragmentShader: id.meshphong_frag,
    },
    standard: {
      uniforms: t$([
        ip.common,
        ip.envmap,
        ip.aomap,
        ip.lightmap,
        ip.emissivemap,
        ip.bumpmap,
        ip.normalmap,
        ip.displacementmap,
        ip.roughnessmap,
        ip.metalnessmap,
        ip.fog,
        ip.lights,
        {
          emissive: { value: new tx(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: id.meshphysical_vert,
      fragmentShader: id.meshphysical_frag,
    },
    toon: {
      uniforms: t$([
        ip.common,
        ip.aomap,
        ip.lightmap,
        ip.emissivemap,
        ip.bumpmap,
        ip.normalmap,
        ip.displacementmap,
        ip.gradientmap,
        ip.fog,
        ip.lights,
        { emissive: { value: new tx(0) } },
      ]),
      vertexShader: id.meshtoon_vert,
      fragmentShader: id.meshtoon_frag,
    },
    matcap: {
      uniforms: t$([
        ip.common,
        ip.bumpmap,
        ip.normalmap,
        ip.displacementmap,
        ip.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: id.meshmatcap_vert,
      fragmentShader: id.meshmatcap_frag,
    },
    points: {
      uniforms: t$([ip.points, ip.fog]),
      vertexShader: id.points_vert,
      fragmentShader: id.points_frag,
    },
    dashed: {
      uniforms: t$([
        ip.common,
        ip.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: id.linedashed_vert,
      fragmentShader: id.linedashed_frag,
    },
    depth: {
      uniforms: t$([ip.common, ip.displacementmap]),
      vertexShader: id.depth_vert,
      fragmentShader: id.depth_frag,
    },
    normal: {
      uniforms: t$([
        ip.common,
        ip.bumpmap,
        ip.normalmap,
        ip.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: id.meshnormal_vert,
      fragmentShader: id.meshnormal_frag,
    },
    sprite: {
      uniforms: t$([ip.sprite, ip.fog]),
      vertexShader: id.sprite_vert,
      fragmentShader: id.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new z() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: id.background_vert,
      fragmentShader: id.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new z() },
      },
      vertexShader: id.backgroundCube_vert,
      fragmentShader: id.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: id.cube_vert,
      fragmentShader: id.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: id.equirect_vert,
      fragmentShader: id.equirect_frag,
    },
    distanceRGBA: {
      uniforms: t$([
        ip.common,
        ip.displacementmap,
        {
          referencePosition: { value: new eo() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: id.distanceRGBA_vert,
      fragmentShader: id.distanceRGBA_frag,
    },
    shadow: {
      uniforms: t$([
        ip.lights,
        ip.fog,
        { color: { value: new tx(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: id.shadow_vert,
      fragmentShader: id.shadow_frag,
    },
  };
im.physical = {
  uniforms: t$([
    im.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new z() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new z() },
      clearcoatNormalScale: { value: new U(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new z() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new z() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new z() },
      sheen: { value: 0 },
      sheenColor: { value: new tx(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new z() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new z() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new z() },
      transmissionSamplerSize: { value: new U() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new z() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new tx(0) },
      specularColor: { value: new tx(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new z() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new z() },
      anisotropyVector: { value: new U() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new z() },
    },
  ]),
  vertexShader: id.meshphysical_vert,
  fragmentShader: id.meshphysical_frag,
};
const ig = { r: 0, b: 0, g: 0 },
  i_ = new eq(),
  iv = new ez();
function ix(e, t, i, n, r, s, a) {
  let o, l;
  let h = new tx(0),
    c = !0 === s ? 0 : 1,
    u = null,
    d = 0,
    p = null;
  function m(e) {
    let n = !0 === e.isScene ? e.background : null;
    return (
      n && n.isTexture && (n = (e.backgroundBlurriness > 0 ? i : t).get(n)), n
    );
  }
  function f(t, i) {
    t.getRGB(ig, t0(e)), n.buffers.color.setClear(ig.r, ig.g, ig.b, i, a);
  }
  return {
    getClearColor: function () {
      return h;
    },
    setClearColor: function (e, t = 1) {
      h.set(e), f(h, (c = t));
    },
    getClearAlpha: function () {
      return c;
    },
    setClearAlpha: function (e) {
      f(h, (c = e));
    },
    render: function (t) {
      let i = !1,
        r = m(t);
      null === r ? f(h, c) : r && r.isColor && (f(r, 1), (i = !0));
      let s = e.xr.getEnvironmentBlendMode();
      "additive" === s
        ? n.buffers.color.setClear(0, 0, 0, 1, a)
        : "alpha-blend" === s && n.buffers.color.setClear(0, 0, 0, 0, a),
        (e.autoClear || i) &&
          (n.buffers.depth.setTest(!0),
          n.buffers.depth.setMask(!0),
          n.buffers.color.setMask(!0),
          e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil));
    },
    addToRenderList: function (t, i) {
      let n = m(i);
      n && (n.isCubeTexture || 306 === n.mapping)
        ? (void 0 === l &&
            ((l = new tY(
              new tZ(1, 1, 1),
              new t2({
                name: "BackgroundCubeMaterial",
                uniforms: tQ(im.backgroundCube.uniforms),
                vertexShader: im.backgroundCube.vertexShader,
                fragmentShader: im.backgroundCube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )).geometry.deleteAttribute("normal"),
            l.geometry.deleteAttribute("uv"),
            (l.onBeforeRender = function (e, t, i) {
              this.matrixWorld.copyPosition(i.matrixWorld);
            }),
            Object.defineProperty(l.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(l)),
          i_.copy(i.backgroundRotation),
          (i_.x *= -1),
          (i_.y *= -1),
          (i_.z *= -1),
          n.isCubeTexture &&
            !1 === n.isRenderTargetTexture &&
            ((i_.y *= -1), (i_.z *= -1)),
          (l.material.uniforms.envMap.value = n),
          (l.material.uniforms.flipEnvMap.value =
            n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1),
          (l.material.uniforms.backgroundBlurriness.value =
            i.backgroundBlurriness),
          (l.material.uniforms.backgroundIntensity.value =
            i.backgroundIntensity),
          l.material.uniforms.backgroundRotation.value.setFromMatrix4(
            iv.makeRotationFromEuler(i_)
          ),
          (l.material.toneMapped = q.getTransfer(n.colorSpace) !== M),
          (u !== n || d !== n.version || p !== e.toneMapping) &&
            ((l.material.needsUpdate = !0),
            (u = n),
            (d = n.version),
            (p = e.toneMapping)),
          l.layers.enableAll(),
          t.unshift(l, l.geometry, l.material, 0, 0, null))
        : n &&
          n.isTexture &&
          (void 0 === o &&
            ((o = new tY(
              new iu(2, 2),
              new t2({
                name: "BackgroundMaterial",
                uniforms: tQ(im.background.uniforms),
                vertexShader: im.background.vertexShader,
                fragmentShader: im.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )).geometry.deleteAttribute("normal"),
            Object.defineProperty(o.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(o)),
          (o.material.uniforms.t2D.value = n),
          (o.material.uniforms.backgroundIntensity.value =
            i.backgroundIntensity),
          (o.material.toneMapped = q.getTransfer(n.colorSpace) !== M),
          !0 === n.matrixAutoUpdate && n.updateMatrix(),
          o.material.uniforms.uvTransform.value.copy(n.matrix),
          (u !== n || d !== n.version || p !== e.toneMapping) &&
            ((o.material.needsUpdate = !0),
            (u = n),
            (d = n.version),
            (p = e.toneMapping)),
          o.layers.enableAll(),
          t.unshift(o, o.geometry, o.material, 0, 0, null));
    },
  };
}
function iy(e, t) {
  let i = e.getParameter(e.MAX_VERTEX_ATTRIBS),
    n = {},
    r = h(null),
    s = r,
    a = !1;
  function o(t) {
    return e.bindVertexArray(t);
  }
  function l(t) {
    return e.deleteVertexArray(t);
  }
  function h(e) {
    let t = [],
      n = [],
      r = [];
    for (let e = 0; e < i; e++) (t[e] = 0), (n[e] = 0), (r[e] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: t,
      enabledAttributes: n,
      attributeDivisors: r,
      object: e,
      attributes: {},
      index: null,
    };
  }
  function c() {
    let e = s.newAttributes;
    for (let t = 0, i = e.length; t < i; t++) e[t] = 0;
  }
  function u(e) {
    d(e, 0);
  }
  function d(t, i) {
    let n = s.newAttributes,
      r = s.enabledAttributes,
      a = s.attributeDivisors;
    (n[t] = 1),
      0 === r[t] && (e.enableVertexAttribArray(t), (r[t] = 1)),
      a[t] !== i && (e.vertexAttribDivisor(t, i), (a[t] = i));
  }
  function p() {
    let t = s.newAttributes,
      i = s.enabledAttributes;
    for (let n = 0, r = i.length; n < r; n++)
      i[n] !== t[n] && (e.disableVertexAttribArray(n), (i[n] = 0));
  }
  function m(t, i, n, r, s, a, o) {
    !0 === o
      ? e.vertexAttribIPointer(t, i, n, s, a)
      : e.vertexAttribPointer(t, i, n, r, s, a);
  }
  function f() {
    g(), (a = !0), s !== r && o((s = r).object);
  }
  function g() {
    (r.geometry = null), (r.program = null), (r.wireframe = !1);
  }
  return {
    setup: function (i, r, l, f, g) {
      let _ = !1,
        v = (function (t, i, r) {
          let s = !0 === r.wireframe,
            a = n[t.id];
          void 0 === a && ((a = {}), (n[t.id] = a));
          let o = a[i.id];
          void 0 === o && ((o = {}), (a[i.id] = o));
          let l = o[s];
          return (
            void 0 === l && ((l = h(e.createVertexArray())), (o[s] = l)), l
          );
        })(f, l, r);
      s !== v && o((s = v).object),
        (_ = (function (e, t, i, n) {
          let r = s.attributes,
            a = t.attributes,
            o = 0,
            l = i.getAttributes();
          for (let t in l)
            if (l[t].location >= 0) {
              let i = r[t],
                n = a[t];
              if (
                (void 0 === n &&
                  ("instanceMatrix" === t &&
                    e.instanceMatrix &&
                    (n = e.instanceMatrix),
                  "instanceColor" === t &&
                    e.instanceColor &&
                    (n = e.instanceColor)),
                void 0 === i || i.attribute !== n || (n && i.data !== n.data))
              )
                return !0;
              o++;
            }
          return s.attributesNum !== o || s.index !== n;
        })(i, f, l, g)) &&
          (function (e, t, i, n) {
            let r = {},
              a = t.attributes,
              o = 0,
              l = i.getAttributes();
            for (let t in l)
              if (l[t].location >= 0) {
                let i = a[t];
                void 0 === i &&
                  ("instanceMatrix" === t &&
                    e.instanceMatrix &&
                    (i = e.instanceMatrix),
                  "instanceColor" === t &&
                    e.instanceColor &&
                    (i = e.instanceColor));
                let n = {};
                (n.attribute = i),
                  i && i.data && (n.data = i.data),
                  (r[t] = n),
                  o++;
              }
            (s.attributes = r), (s.attributesNum = o), (s.index = n);
          })(i, f, l, g),
        null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
        (_ || a) &&
          ((a = !1),
          (function (i, n, r, s) {
            c();
            let a = s.attributes,
              o = r.getAttributes(),
              l = n.defaultAttributeValues;
            for (let n in o) {
              let r = o[n];
              if (r.location >= 0) {
                let o = a[n];
                if (
                  (void 0 === o &&
                    ("instanceMatrix" === n &&
                      i.instanceMatrix &&
                      (o = i.instanceMatrix),
                    "instanceColor" === n &&
                      i.instanceColor &&
                      (o = i.instanceColor)),
                  void 0 !== o)
                ) {
                  let n = o.normalized,
                    a = o.itemSize,
                    l = t.get(o);
                  if (void 0 === l) continue;
                  let h = l.buffer,
                    c = l.type,
                    p = l.bytesPerElement,
                    f =
                      c === e.INT || c === e.UNSIGNED_INT || 1013 === o.gpuType;
                  if (o.isInterleavedBufferAttribute) {
                    let t = o.data,
                      l = t.stride,
                      g = o.offset;
                    if (t.isInstancedInterleavedBuffer) {
                      for (let e = 0; e < r.locationSize; e++)
                        d(r.location + e, t.meshPerAttribute);
                      !0 !== i.isInstancedMesh &&
                        void 0 === s._maxInstanceCount &&
                        (s._maxInstanceCount = t.meshPerAttribute * t.count);
                    } else
                      for (let e = 0; e < r.locationSize; e++)
                        u(r.location + e);
                    e.bindBuffer(e.ARRAY_BUFFER, h);
                    for (let e = 0; e < r.locationSize; e++)
                      m(
                        r.location + e,
                        a / r.locationSize,
                        c,
                        n,
                        l * p,
                        (g + (a / r.locationSize) * e) * p,
                        f
                      );
                  } else {
                    if (o.isInstancedBufferAttribute) {
                      for (let e = 0; e < r.locationSize; e++)
                        d(r.location + e, o.meshPerAttribute);
                      !0 !== i.isInstancedMesh &&
                        void 0 === s._maxInstanceCount &&
                        (s._maxInstanceCount = o.meshPerAttribute * o.count);
                    } else
                      for (let e = 0; e < r.locationSize; e++)
                        u(r.location + e);
                    e.bindBuffer(e.ARRAY_BUFFER, h);
                    for (let e = 0; e < r.locationSize; e++)
                      m(
                        r.location + e,
                        a / r.locationSize,
                        c,
                        n,
                        a * p,
                        (a / r.locationSize) * e * p,
                        f
                      );
                  }
                } else if (void 0 !== l) {
                  let t = l[n];
                  if (void 0 !== t)
                    switch (t.length) {
                      case 2:
                        e.vertexAttrib2fv(r.location, t);
                        break;
                      case 3:
                        e.vertexAttrib3fv(r.location, t);
                        break;
                      case 4:
                        e.vertexAttrib4fv(r.location, t);
                        break;
                      default:
                        e.vertexAttrib1fv(r.location, t);
                    }
                }
              }
            }
            p();
          })(i, r, l, f),
          null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer));
    },
    reset: f,
    resetDefaultState: g,
    dispose: function () {
      for (let e in (f(), n)) {
        let t = n[e];
        for (let e in t) {
          let i = t[e];
          for (let e in i) l(i[e].object), delete i[e];
          delete t[e];
        }
        delete n[e];
      }
    },
    releaseStatesOfGeometry: function (e) {
      if (void 0 === n[e.id]) return;
      let t = n[e.id];
      for (let e in t) {
        let i = t[e];
        for (let e in i) l(i[e].object), delete i[e];
        delete t[e];
      }
      delete n[e.id];
    },
    releaseStatesOfProgram: function (e) {
      for (let t in n) {
        let i = n[t];
        if (void 0 === i[e.id]) continue;
        let r = i[e.id];
        for (let e in r) l(r[e].object), delete r[e];
        delete i[e.id];
      }
    },
    initAttributes: c,
    enableAttribute: u,
    disableUnusedAttributes: p,
  };
}
function iM(e, t, i) {
  let n;
  function r(t, r, s) {
    0 !== s && (e.drawArraysInstanced(n, t, r, s), i.update(r, n, s));
  }
  (this.setMode = function (e) {
    n = e;
  }),
    (this.render = function (t, r) {
      e.drawArrays(n, t, r), i.update(r, n, 1);
    }),
    (this.renderInstances = r),
    (this.renderMultiDraw = function (e, r, s) {
      if (0 === s) return;
      t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, e, 0, r, 0, s);
      let a = 0;
      for (let e = 0; e < s; e++) a += r[e];
      i.update(a, n, 1);
    }),
    (this.renderMultiDrawInstances = function (e, s, a, o) {
      if (0 === a) return;
      let l = t.get("WEBGL_multi_draw");
      if (null === l) for (let t = 0; t < e.length; t++) r(e[t], s[t], o[t]);
      else {
        l.multiDrawArraysInstancedWEBGL(n, e, 0, s, 0, o, 0, a);
        let t = 0;
        for (let e = 0; e < a; e++) t += s[e];
        for (let e = 0; e < o.length; e++) i.update(t, n, o[e]);
      }
    });
}
function iS(e, t, i, n) {
  let r;
  function s(t) {
    if ("highp" === t) {
      if (
        e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision >
          0 &&
        e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      t = "mediump";
    }
    return "mediump" === t &&
      e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision >
        0 &&
      e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let a = void 0 !== i.precision ? i.precision : "highp",
    o = s(a);
  o !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      o,
      "instead."
    ),
    (a = o));
  let l = !0 === i.logarithmicDepthBuffer,
    h = !0 === i.reverseDepthBuffer && t.has("EXT_clip_control");
  if (!0 === h) {
    let e = t.get("EXT_clip_control");
    e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT);
  }
  let c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
    u = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    d = e.getParameter(e.MAX_TEXTURE_SIZE),
    p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
    m = e.getParameter(e.MAX_VERTEX_ATTRIBS),
    f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: function () {
      if (void 0 !== r) return r;
      if (!0 === t.has("EXT_texture_filter_anisotropic")) {
        let i = t.get("EXT_texture_filter_anisotropic");
        r = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else r = 0;
      return r;
    },
    getMaxPrecision: s,
    textureFormatReadable: function (t) {
      return (
        1023 === t ||
        n.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
      );
    },
    textureTypeReadable: function (i) {
      let r =
        1016 === i &&
        (t.has("EXT_color_buffer_half_float") ||
          t.has("EXT_color_buffer_float"));
      return (
        1009 === i ||
        n.convert(i) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) ||
        1015 === i ||
        !!r
      );
    },
    precision: a,
    logarithmicDepthBuffer: l,
    reverseDepthBuffer: h,
    maxTextures: c,
    maxVertexTextures: u,
    maxTextureSize: d,
    maxCubemapSize: p,
    maxAttributes: m,
    maxVertexUniforms: f,
    maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
    maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
    vertexTextures: u > 0,
    maxSamples: e.getParameter(e.MAX_SAMPLES),
  };
}
function ib(e) {
  let t = this,
    i = null,
    n = 0,
    r = !1,
    s = !1,
    a = new is(),
    o = new z(),
    l = { value: null, needsUpdate: !1 };
  function h(e, i, n, r) {
    let s = null !== e ? e.length : 0,
      h = null;
    if (0 !== s) {
      if (((h = l.value), !0 !== r || null === h)) {
        let t = n + 4 * s,
          r = i.matrixWorldInverse;
        o.getNormalMatrix(r),
          (null === h || h.length < t) && (h = new Float32Array(t));
        for (let t = 0, i = n; t !== s; ++t, i += 4)
          a.copy(e[t]).applyMatrix4(r, o),
            a.normal.toArray(h, i),
            (h[i + 3] = a.constant);
      }
      (l.value = h), (l.needsUpdate = !0);
    }
    return (t.numPlanes = s), (t.numIntersection = 0), h;
  }
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (e, t) {
      let i = 0 !== e.length || t || 0 !== n || r;
      return (r = t), (n = e.length), i;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (e, t) {
      i = h(e, t, 0);
    }),
    (this.setState = function (a, o, c) {
      let u = a.clippingPlanes,
        d = a.clipIntersection,
        p = a.clipShadows,
        m = e.get(a);
      if (r && null !== u && 0 !== u.length && (!s || p)) {
        let e = s ? 0 : n,
          t = 4 * e,
          r = m.clippingState || null;
        (l.value = r), (r = h(u, o, t, c));
        for (let e = 0; e !== t; ++e) r[e] = i[e];
        (m.clippingState = r),
          (this.numIntersection = d ? this.numPlanes : 0),
          (this.numPlanes += e);
      } else
        s
          ? h(null)
          : (l.value !== i && ((l.value = i), (l.needsUpdate = n > 0)),
            (t.numPlanes = n),
            (t.numIntersection = 0));
    });
}
function iT(e) {
  let t = new WeakMap();
  function i(e, t) {
    return 303 === t ? (e.mapping = 301) : 304 === t && (e.mapping = 302), e;
  }
  function n(e) {
    let i = e.target;
    i.removeEventListener("dispose", n);
    let r = t.get(i);
    void 0 !== r && (t.delete(i), r.dispose());
  }
  return {
    get: function (r) {
      if (r && r.isTexture) {
        let s = r.mapping;
        if (303 === s || 304 === s) {
          if (t.has(r)) return i(t.get(r).texture, r.mapping);
          {
            let s = r.image;
            if (!s || !(s.height > 0)) return null;
            {
              let a = new ie(s.height);
              return (
                a.fromEquirectangularTexture(e, r),
                t.set(r, a),
                r.addEventListener("dispose", n),
                i(a.texture, r.mapping)
              );
            }
          }
        }
      }
      return r;
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
class iE extends t3 {
  constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, s = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = n),
      (this.near = r),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = null === e.view ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, n, r, s) {
    null === this.view &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = r),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    let e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      n = (this.top + this.bottom) / 2,
      r = i - e,
      s = i + e,
      a = n + t,
      o = n - t;
    if (null !== this.view && this.view.enabled) {
      let e = (this.right - this.left) / this.view.fullWidth / this.zoom,
        t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += e * this.view.offsetX),
        (s = r + e * this.view.width),
        (a -= t * this.view.offsetY),
        (o = a - t * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      r,
      s,
      a,
      o,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    let t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      null !== this.view && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const iw = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  iA = new iE(),
  iR = new tx();
let iC = null,
  iP = 0,
  iL = 0,
  iN = !1;
const iI = (1 + Math.sqrt(5)) / 2,
  iD = 1 / iI,
  iO = [
    new eo(-iI, iD, 0),
    new eo(iI, iD, 0),
    new eo(-iD, 0, iI),
    new eo(iD, 0, iI),
    new eo(0, iI, -iD),
    new eo(0, iI, iD),
    new eo(-1, 1, -1),
    new eo(1, 1, -1),
    new eo(-1, 1, 1),
    new eo(1, 1, 1),
  ];
class iU {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, n = 100) {
    (iC = this._renderer.getRenderTarget()),
      (iP = this._renderer.getActiveCubeFace()),
      (iL = this._renderer.getActiveMipmapLevel()),
      (iN = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    let r = this._allocateTargets();
    return (
      (r.depthBuffer = !0),
      this._sceneToCubeUV(e, i, n, r),
      t > 0 && this._blur(r, 0, 0, t),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    null === this._cubemapMaterial &&
      ((this._cubemapMaterial = ik()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    null === this._equirectMaterial &&
      ((this._equirectMaterial = iB()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
      null !== this._equirectMaterial && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    null !== this._blurMaterial && this._blurMaterial.dispose(),
      null !== this._pingPongRenderTarget &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(iC, iP, iL),
      (this._renderer.xr.enabled = iN),
      (e.scissorTest = !1),
      iF(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    301 === e.mapping || 302 === e.mapping
      ? this._setSize(
          0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (iC = this._renderer.getRenderTarget()),
      (iP = this._renderer.getActiveCubeFace()),
      (iL = this._renderer.getActiveMipmapLevel()),
      (iN = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    let i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    let e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: 1006,
        minFilter: 1006,
        generateMipmaps: !1,
        type: 1016,
        format: 1023,
        colorSpace: _,
        depthBuffer: !1,
      },
      n = iz(e, t, i);
    if (
      null === this._pingPongRenderTarget ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      null !== this._pingPongRenderTarget && this._dispose(),
        (this._pingPongRenderTarget = iz(e, t, i));
      let { _lodMax: n } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = (function (e) {
        let t = [],
          i = [],
          n = [],
          r = e,
          s = e - 4 + 1 + iw.length;
        for (let a = 0; a < s; a++) {
          let s = Math.pow(2, r);
          i.push(s);
          let o = 1 / s;
          a > e - 4 ? (o = iw[a - e + 4 - 1]) : 0 === a && (o = 0), n.push(o);
          let l = 1 / (s - 2),
            h = -l,
            c = 1 + l,
            u = [h, h, c, h, c, c, h, h, c, c, h, c],
            d = new Float32Array(108),
            p = new Float32Array(72),
            m = new Float32Array(36);
          for (let e = 0; e < 6; e++) {
            let t = ((e % 3) * 2) / 3 - 1,
              i = e > 2 ? 0 : -1,
              n = [
                t,
                i,
                0,
                t + 2 / 3,
                i,
                0,
                t + 2 / 3,
                i + 1,
                0,
                t,
                i,
                0,
                t + 2 / 3,
                i + 1,
                0,
                t,
                i + 1,
                0,
              ];
            d.set(n, 18 * e), p.set(u, 12 * e);
            let r = [e, e, e, e, e, e];
            m.set(r, 6 * e);
          }
          let f = new tz();
          f.setAttribute("position", new tw(d, 3)),
            f.setAttribute("uv", new tw(p, 2)),
            f.setAttribute("faceIndex", new tw(m, 1)),
            t.push(f),
            r > 4 && r--;
        }
        return { lodPlanes: t, sizeLods: i, sigmas: n };
      })(n)),
        (this._blurMaterial = new t2({
          name: "SphericalGaussianBlur",
          defines: {
            n: 20,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`,
          },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: new Float32Array(20) },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: new eo(0, 1, 0) },
          },
          vertexShader: iH(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        }));
    }
    return n;
  }
  _compileMaterial(e) {
    let t = new tY(this._lodPlanes[0], e);
    this._renderer.compile(t, iA);
  }
  _sceneToCubeUV(e, t, i, n) {
    let r = new t7(90, 1, t, i),
      s = [1, -1, 1, 1, 1, 1],
      a = [1, 1, 1, -1, -1, -1],
      o = this._renderer,
      l = o.autoClear,
      h = o.toneMapping;
    o.getClearColor(iR), (o.toneMapping = 0), (o.autoClear = !1);
    let c = new tb({
        name: "PMREM.Background",
        side: 1,
        depthWrite: !1,
        depthTest: !1,
      }),
      u = new tY(new tZ(), c),
      d = !1,
      p = e.background;
    p
      ? p.isColor && (c.color.copy(p), (e.background = null), (d = !0))
      : (c.color.copy(iR), (d = !0));
    for (let t = 0; t < 6; t++) {
      let i = t % 3;
      0 === i
        ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0))
        : 1 === i
        ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0))
        : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t]));
      let l = this._cubeSize;
      iF(n, i * l, t > 2 ? l : 0, l, l),
        o.setRenderTarget(n),
        d && o.render(u, r),
        o.render(e, r);
    }
    u.geometry.dispose(),
      u.material.dispose(),
      (o.toneMapping = h),
      (o.autoClear = l),
      (e.background = p);
  }
  _textureToCubeUV(e, t) {
    let i = this._renderer,
      n = 301 === e.mapping || 302 === e.mapping;
    n
      ? (null === this._cubemapMaterial && (this._cubemapMaterial = ik()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          !1 === e.isRenderTargetTexture ? -1 : 1))
      : null === this._equirectMaterial && (this._equirectMaterial = iB());
    let r = n ? this._cubemapMaterial : this._equirectMaterial,
      s = new tY(this._lodPlanes[0], r);
    r.uniforms.envMap.value = e;
    let a = this._cubeSize;
    iF(t, 0, 0, 3 * a, 2 * a), i.setRenderTarget(t), i.render(s, iA);
  }
  _applyPMREM(e) {
    let t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    let n = this._lodPlanes.length;
    for (let t = 1; t < n; t++) {
      let i = Math.sqrt(
          this._sigmas[t] * this._sigmas[t] -
            this._sigmas[t - 1] * this._sigmas[t - 1]
        ),
        r = iO[(n - t - 1) % iO.length];
      this._blur(e, t - 1, t, i, r);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, n, r) {
    let s = this._pingPongRenderTarget;
    this._halfBlur(e, s, t, i, n, "latitudinal", r),
      this._halfBlur(s, e, i, i, n, "longitudinal", r);
  }
  _halfBlur(e, t, i, n, r, s, a) {
    let o = this._renderer,
      l = this._blurMaterial;
    "latitudinal" !== s &&
      "longitudinal" !== s &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    let h = new tY(this._lodPlanes[n], l),
      c = l.uniforms,
      u = this._sizeLods[i] - 1,
      d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
      p = r / d,
      m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
    m > 20 &&
      console.warn(
        `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
      );
    let f = [],
      g = 0;
    for (let e = 0; e < 20; ++e) {
      let t = e / p,
        i = Math.exp((-t * t) / 2);
      f.push(i), 0 === e ? (g += i) : e < m && (g += 2 * i);
    }
    for (let e = 0; e < f.length; e++) f[e] = f[e] / g;
    (c.envMap.value = e.texture),
      (c.samples.value = m),
      (c.weights.value = f),
      (c.latitudinal.value = "latitudinal" === s),
      a && (c.poleAxis.value = a);
    let { _lodMax: _ } = this;
    (c.dTheta.value = d), (c.mipInt.value = _ - i);
    let v = this._sizeLods[n],
      x = 4 * (this._cubeSize - v);
    iF(t, 3 * v * (n > _ - 4 ? n - _ + 4 : 0), x, 3 * v, 2 * v),
      o.setRenderTarget(t),
      o.render(h, iA);
  }
}
function iz(e, t, i) {
  let n = new er(e, t, i);
  return (
    (n.texture.mapping = 306),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function iF(e, t, i, n, r) {
  e.viewport.set(t, i, n, r), e.scissor.set(t, i, n, r);
}
function iB() {
  return new t2({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: iH(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ik() {
  return new t2({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: iH(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function iH() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function iV(e) {
  let t = new WeakMap(),
    i = null;
  function n(e) {
    let i = e.target;
    i.removeEventListener("dispose", n);
    let r = t.get(i);
    void 0 !== r && (t.delete(i), r.dispose());
  }
  return {
    get: function (r) {
      if (r && r.isTexture) {
        let s = r.mapping,
          a = 303 === s || 304 === s,
          o = 301 === s || 302 === s;
        if (a || o) {
          let s = t.get(r),
            l = void 0 !== s ? s.texture.pmremVersion : 0;
          if (r.isRenderTargetTexture && r.pmremVersion !== l)
            return (
              null === i && (i = new iU(e)),
              ((s = a
                ? i.fromEquirectangular(r, s)
                : i.fromCubemap(r, s)).texture.pmremVersion = r.pmremVersion),
              t.set(r, s),
              s.texture
            );
          if (void 0 !== s) return s.texture;
          {
            let l = r.image;
            return (a && l && l.height > 0) ||
              (o &&
                l &&
                (function (e) {
                  let t = 0;
                  for (let i = 0; i < 6; i++) void 0 !== e[i] && t++;
                  return 6 === t;
                })(l))
              ? (null === i && (i = new iU(e)),
                ((s = a
                  ? i.fromEquirectangular(r)
                  : i.fromCubemap(r)).texture.pmremVersion = r.pmremVersion),
                t.set(r, s),
                r.addEventListener("dispose", n),
                s.texture)
              : null;
          }
        }
      }
      return r;
    },
    dispose: function () {
      (t = new WeakMap()), null !== i && (i.dispose(), (i = null));
    },
  };
}
function iG(e) {
  let t = {};
  function i(i) {
    let n;
    if (void 0 !== t[i]) return t[i];
    switch (i) {
      case "WEBGL_depth_texture":
        n =
          e.getExtension("WEBGL_depth_texture") ||
          e.getExtension("MOZ_WEBGL_depth_texture") ||
          e.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n =
          e.getExtension("EXT_texture_filter_anisotropic") ||
          e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n =
          e.getExtension("WEBGL_compressed_texture_s3tc") ||
          e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n =
          e.getExtension("WEBGL_compressed_texture_pvrtc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = e.getExtension(i);
    }
    return (t[i] = n), n;
  }
  return {
    has: function (e) {
      return null !== i(e);
    },
    init: function () {
      i("EXT_color_buffer_float"),
        i("WEBGL_clip_cull_distance"),
        i("OES_texture_float_linear"),
        i("EXT_color_buffer_half_float"),
        i("WEBGL_multisampled_render_to_texture"),
        i("WEBGL_render_shared_exponent");
    },
    get: function (e) {
      let t = i(e);
      return (
        null === t &&
          V("THREE.WebGLRenderer: " + e + " extension not supported."),
        t
      );
    },
  };
}
function iW(e, t, i, n) {
  let r = {},
    s = new WeakMap();
  function a(e) {
    let o = e.target;
    for (let e in (null !== o.index && t.remove(o.index), o.attributes))
      t.remove(o.attributes[e]);
    for (let e in o.morphAttributes) {
      let i = o.morphAttributes[e];
      for (let e = 0, n = i.length; e < n; e++) t.remove(i[e]);
    }
    o.removeEventListener("dispose", a), delete r[o.id];
    let l = s.get(o);
    l && (t.remove(l), s.delete(o)),
      n.releaseStatesOfGeometry(o),
      !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
      i.memory.geometries--;
  }
  function o(e) {
    let i = [],
      n = e.index,
      r = e.attributes.position,
      a = 0;
    if (null !== n) {
      let e = n.array;
      a = n.version;
      for (let t = 0, n = e.length; t < n; t += 3) {
        let n = e[t + 0],
          r = e[t + 1],
          s = e[t + 2];
        i.push(n, r, r, s, s, n);
      }
    } else {
      if (void 0 === r) return;
      let e = r.array;
      a = r.version;
      for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
        let e = t + 0,
          n = t + 1,
          r = t + 2;
        i.push(e, n, n, r, r, e);
      }
    }
    let o = new (B(i) ? tR : tA)(i, 1);
    o.version = a;
    let l = s.get(e);
    l && t.remove(l), s.set(e, o);
  }
  return {
    get: function (e, t) {
      return (
        !0 === r[t.id] ||
          (t.addEventListener("dispose", a),
          (r[t.id] = !0),
          i.memory.geometries++),
        t
      );
    },
    update: function (i) {
      let n = i.attributes;
      for (let i in n) t.update(n[i], e.ARRAY_BUFFER);
      let r = i.morphAttributes;
      for (let i in r) {
        let n = r[i];
        for (let i = 0, r = n.length; i < r; i++)
          t.update(n[i], e.ARRAY_BUFFER);
      }
    },
    getWireframeAttribute: function (e) {
      let t = s.get(e);
      if (t) {
        let i = e.index;
        null !== i && t.version < i.version && o(e);
      } else o(e);
      return s.get(e);
    },
  };
}
function iX(e, t, i) {
  let n, r, s;
  function a(t, a, o) {
    0 !== o && (e.drawElementsInstanced(n, a, r, t * s, o), i.update(a, n, o));
  }
  (this.setMode = function (e) {
    n = e;
  }),
    (this.setIndex = function (e) {
      (r = e.type), (s = e.bytesPerElement);
    }),
    (this.render = function (t, a) {
      e.drawElements(n, a, r, t * s), i.update(a, n, 1);
    }),
    (this.renderInstances = a),
    (this.renderMultiDraw = function (e, s, a) {
      if (0 === a) return;
      t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, s, 0, r, e, 0, a);
      let o = 0;
      for (let e = 0; e < a; e++) o += s[e];
      i.update(o, n, 1);
    }),
    (this.renderMultiDrawInstances = function (e, o, l, h) {
      if (0 === l) return;
      let c = t.get("WEBGL_multi_draw");
      if (null === c)
        for (let t = 0; t < e.length; t++) a(e[t] / s, o[t], h[t]);
      else {
        c.multiDrawElementsInstancedWEBGL(n, o, 0, r, e, 0, h, 0, l);
        let t = 0;
        for (let e = 0; e < l; e++) t += o[e];
        for (let e = 0; e < h.length; e++) i.update(t, n, h[e]);
      }
    });
}
function ij(e) {
  let t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return {
    memory: { geometries: 0, textures: 0 },
    render: t,
    programs: null,
    autoReset: !0,
    reset: function () {
      (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
    },
    update: function (i, n, r) {
      switch ((t.calls++, n)) {
        case e.TRIANGLES:
          t.triangles += (i / 3) * r;
          break;
        case e.LINES:
          t.lines += (i / 2) * r;
          break;
        case e.LINE_STRIP:
          t.lines += r * (i - 1);
          break;
        case e.LINE_LOOP:
          t.lines += r * i;
          break;
        case e.POINTS:
          t.points += r * i;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n);
      }
    },
  };
}
function iq(e, t, i) {
  let n = new WeakMap(),
    r = new ei();
  return {
    update: function (s, a, o) {
      let l = s.morphTargetInfluences,
        h =
          a.morphAttributes.position ||
          a.morphAttributes.normal ||
          a.morphAttributes.color,
        c = void 0 !== h ? h.length : 0,
        u = n.get(a);
      if (void 0 === u || u.count !== c) {
        void 0 !== u && u.texture.dispose();
        let e = void 0 !== a.morphAttributes.position,
          i = void 0 !== a.morphAttributes.normal,
          s = void 0 !== a.morphAttributes.color,
          o = a.morphAttributes.position || [],
          l = a.morphAttributes.normal || [],
          h = a.morphAttributes.color || [],
          d = 0;
        !0 === e && (d = 1), !0 === i && (d = 2), !0 === s && (d = 3);
        let p = a.attributes.position.count * d,
          m = 1;
        p > t.maxTextureSize &&
          ((m = Math.ceil(p / t.maxTextureSize)), (p = t.maxTextureSize));
        let f = new Float32Array(p * m * 4 * c),
          g = new es(f, p, m, c);
        (g.type = 1015), (g.needsUpdate = !0);
        let _ = 4 * d;
        for (let t = 0; t < c; t++) {
          let n = o[t],
            a = l[t],
            c = h[t],
            u = p * m * 4 * t;
          for (let t = 0; t < n.count; t++) {
            let o = t * _;
            !0 === e &&
              (r.fromBufferAttribute(n, t),
              (f[u + o + 0] = r.x),
              (f[u + o + 1] = r.y),
              (f[u + o + 2] = r.z),
              (f[u + o + 3] = 0)),
              !0 === i &&
                (r.fromBufferAttribute(a, t),
                (f[u + o + 4] = r.x),
                (f[u + o + 5] = r.y),
                (f[u + o + 6] = r.z),
                (f[u + o + 7] = 0)),
              !0 === s &&
                (r.fromBufferAttribute(c, t),
                (f[u + o + 8] = r.x),
                (f[u + o + 9] = r.y),
                (f[u + o + 10] = r.z),
                (f[u + o + 11] = 4 === c.itemSize ? r.w : 1));
          }
        }
        (u = { count: c, texture: g, size: new U(p, m) }),
          n.set(a, u),
          a.addEventListener("dispose", function e() {
            g.dispose(), n.delete(a), a.removeEventListener("dispose", e);
          });
      }
      if (!0 === s.isInstancedMesh && null !== s.morphTexture)
        o.getUniforms().setValue(e, "morphTexture", s.morphTexture, i);
      else {
        let t = 0;
        for (let e = 0; e < l.length; e++) t += l[e];
        let i = a.morphTargetsRelative ? 1 : 1 - t;
        o.getUniforms().setValue(e, "morphTargetBaseInfluence", i),
          o.getUniforms().setValue(e, "morphTargetInfluences", l);
      }
      o.getUniforms().setValue(e, "morphTargetsTexture", u.texture, i),
        o.getUniforms().setValue(e, "morphTargetsTextureSize", u.size);
    },
  };
}
function iJ(e, t, i, n) {
  let r = new WeakMap();
  function s(e) {
    let t = e.target;
    t.removeEventListener("dispose", s),
      i.remove(t.instanceMatrix),
      null !== t.instanceColor && i.remove(t.instanceColor);
  }
  return {
    update: function (a) {
      let o = n.render.frame,
        l = a.geometry,
        h = t.get(a, l);
      if (
        (r.get(h) !== o && (t.update(h), r.set(h, o)),
        a.isInstancedMesh &&
          (!1 === a.hasEventListener("dispose", s) &&
            a.addEventListener("dispose", s),
          r.get(a) !== o &&
            (i.update(a.instanceMatrix, e.ARRAY_BUFFER),
            null !== a.instanceColor &&
              i.update(a.instanceColor, e.ARRAY_BUFFER),
            r.set(a, o))),
        a.isSkinnedMesh)
      ) {
        let e = a.skeleton;
        r.get(e) !== o && (e.update(), r.set(e, o));
      }
      return h;
    },
    dispose: function () {
      r = new WeakMap();
    },
  };
}
class iY extends et {
  constructor(e, t, i, n, r, s, a, o, l, h = 1026) {
    if (1026 !== h && 1027 !== h)
      throw Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    void 0 === i && 1026 === h && (i = 1014),
      void 0 === i && 1027 === h && (i = 1020),
      super(null, n, r, s, a, o, h, i, l),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = void 0 !== a ? a : 1003),
      (this.minFilter = void 0 !== o ? o : 1003),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    let t = super.toJSON(e);
    return (
      null !== this.compareFunction &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const iK = new et(),
  iZ = new iY(1, 1),
  iQ = new es(),
  i$ = new (class extends et {
    constructor(e = null, t = 1, i = 1, n = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: e, width: t, height: i, depth: n }),
        (this.magFilter = 1003),
        (this.minFilter = 1003),
        (this.wrapR = 1001),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  })(),
  i0 = new t9(),
  i1 = [],
  i2 = [],
  i3 = new Float32Array(16),
  i5 = new Float32Array(9),
  i4 = new Float32Array(4);
function i6(e, t, i) {
  let n = e[0];
  if (n <= 0 || n > 0) return e;
  let r = t * i,
    s = i1[r];
  if ((void 0 === s && ((s = new Float32Array(r)), (i1[r] = s)), 0 !== t)) {
    n.toArray(s, 0);
    for (let n = 1, r = 0; n !== t; ++n) (r += i), e[n].toArray(s, r);
  }
  return s;
}
function i7(e, t) {
  if (e.length !== t.length) return !1;
  for (let i = 0, n = e.length; i < n; i++) if (e[i] !== t[i]) return !1;
  return !0;
}
function i8(e, t) {
  for (let i = 0, n = t.length; i < n; i++) e[i] = t[i];
}
function i9(e, t) {
  let i = i2[t];
  void 0 === i && ((i = new Int32Array(t)), (i2[t] = i));
  for (let n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
  return i;
}
function ne(e, t) {
  let i = this.cache;
  i[0] !== t && (e.uniform1f(this.addr, t), (i[0] = t));
}
function nt(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y) &&
      (e.uniform2f(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (i7(i, t)) return;
    e.uniform2fv(this.addr, t), i8(i, t);
  }
}
function ni(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) &&
      (e.uniform3f(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else if (void 0 !== t.r)
    (i[0] !== t.r || i[1] !== t.g || i[2] !== t.b) &&
      (e.uniform3f(this.addr, t.r, t.g, t.b),
      (i[0] = t.r),
      (i[1] = t.g),
      (i[2] = t.b));
  else {
    if (i7(i, t)) return;
    e.uniform3fv(this.addr, t), i8(i, t);
  }
}
function nn(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) &&
      (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (i7(i, t)) return;
    e.uniform4fv(this.addr, t), i8(i, t);
  }
}
function nr(e, t) {
  let i = this.cache,
    n = t.elements;
  if (void 0 === n) {
    if (i7(i, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), i8(i, t);
  } else {
    if (i7(i, n)) return;
    i4.set(n), e.uniformMatrix2fv(this.addr, !1, i4), i8(i, n);
  }
}
function ns(e, t) {
  let i = this.cache,
    n = t.elements;
  if (void 0 === n) {
    if (i7(i, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), i8(i, t);
  } else {
    if (i7(i, n)) return;
    i5.set(n), e.uniformMatrix3fv(this.addr, !1, i5), i8(i, n);
  }
}
function na(e, t) {
  let i = this.cache,
    n = t.elements;
  if (void 0 === n) {
    if (i7(i, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), i8(i, t);
  } else {
    if (i7(i, n)) return;
    i3.set(n), e.uniformMatrix4fv(this.addr, !1, i3), i8(i, n);
  }
}
function no(e, t) {
  let i = this.cache;
  i[0] !== t && (e.uniform1i(this.addr, t), (i[0] = t));
}
function nl(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y) &&
      (e.uniform2i(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (i7(i, t)) return;
    e.uniform2iv(this.addr, t), i8(i, t);
  }
}
function nh(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) &&
      (e.uniform3i(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else {
    if (i7(i, t)) return;
    e.uniform3iv(this.addr, t), i8(i, t);
  }
}
function nc(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) &&
      (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (i7(i, t)) return;
    e.uniform4iv(this.addr, t), i8(i, t);
  }
}
function nu(e, t) {
  let i = this.cache;
  i[0] !== t && (e.uniform1ui(this.addr, t), (i[0] = t));
}
function nd(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y) &&
      (e.uniform2ui(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (i7(i, t)) return;
    e.uniform2uiv(this.addr, t), i8(i, t);
  }
}
function np(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) &&
      (e.uniform3ui(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else {
    if (i7(i, t)) return;
    e.uniform3uiv(this.addr, t), i8(i, t);
  }
}
function nm(e, t) {
  let i = this.cache;
  if (void 0 !== t.x)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) &&
      (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (i7(i, t)) return;
    e.uniform4uiv(this.addr, t), i8(i, t);
  }
}
function nf(e, t, i) {
  let n;
  let r = this.cache,
    s = i.allocateTextureUnit();
  r[0] !== s && (e.uniform1i(this.addr, s), (r[0] = s)),
    this.type === e.SAMPLER_2D_SHADOW
      ? ((iZ.compareFunction = 515), (n = iZ))
      : (n = iK),
    i.setTexture2D(t || n, s);
}
function ng(e, t, i) {
  let n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture3D(t || i$, r);
}
function n_(e, t, i) {
  let n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
    i.setTextureCube(t || i0, r);
}
function nv(e, t, i) {
  let n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (e.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture2DArray(t || iQ, r);
}
function nx(e, t) {
  e.uniform1fv(this.addr, t);
}
function ny(e, t) {
  let i = i6(t, this.size, 2);
  e.uniform2fv(this.addr, i);
}
function nM(e, t) {
  let i = i6(t, this.size, 3);
  e.uniform3fv(this.addr, i);
}
function nS(e, t) {
  let i = i6(t, this.size, 4);
  e.uniform4fv(this.addr, i);
}
function nb(e, t) {
  let i = i6(t, this.size, 4);
  e.uniformMatrix2fv(this.addr, !1, i);
}
function nT(e, t) {
  let i = i6(t, this.size, 9);
  e.uniformMatrix3fv(this.addr, !1, i);
}
function nE(e, t) {
  let i = i6(t, this.size, 16);
  e.uniformMatrix4fv(this.addr, !1, i);
}
function nw(e, t) {
  e.uniform1iv(this.addr, t);
}
function nA(e, t) {
  e.uniform2iv(this.addr, t);
}
function nR(e, t) {
  e.uniform3iv(this.addr, t);
}
function nC(e, t) {
  e.uniform4iv(this.addr, t);
}
function nP(e, t) {
  e.uniform1uiv(this.addr, t);
}
function nL(e, t) {
  e.uniform2uiv(this.addr, t);
}
function nN(e, t) {
  e.uniform3uiv(this.addr, t);
}
function nI(e, t) {
  e.uniform4uiv(this.addr, t);
}
function nD(e, t, i) {
  let n = this.cache,
    r = t.length,
    s = i9(i, r);
  i7(n, s) || (e.uniform1iv(this.addr, s), i8(n, s));
  for (let e = 0; e !== r; ++e) i.setTexture2D(t[e] || iK, s[e]);
}
function nO(e, t, i) {
  let n = this.cache,
    r = t.length,
    s = i9(i, r);
  i7(n, s) || (e.uniform1iv(this.addr, s), i8(n, s));
  for (let e = 0; e !== r; ++e) i.setTexture3D(t[e] || i$, s[e]);
}
function nU(e, t, i) {
  let n = this.cache,
    r = t.length,
    s = i9(i, r);
  i7(n, s) || (e.uniform1iv(this.addr, s), i8(n, s));
  for (let e = 0; e !== r; ++e) i.setTextureCube(t[e] || i0, s[e]);
}
function nz(e, t, i) {
  let n = this.cache,
    r = t.length,
    s = i9(i, r);
  i7(n, s) || (e.uniform1iv(this.addr, s), i8(n, s));
  for (let e = 0; e !== r; ++e) i.setTexture2DArray(t[e] || iQ, s[e]);
}
class nF {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = (function (e) {
        switch (e) {
          case 5126:
            return ne;
          case 35664:
            return nt;
          case 35665:
            return ni;
          case 35666:
            return nn;
          case 35674:
            return nr;
          case 35675:
            return ns;
          case 35676:
            return na;
          case 5124:
          case 35670:
            return no;
          case 35667:
          case 35671:
            return nl;
          case 35668:
          case 35672:
            return nh;
          case 35669:
          case 35673:
            return nc;
          case 5125:
            return nu;
          case 36294:
            return nd;
          case 36295:
            return np;
          case 36296:
            return nm;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return nf;
          case 35679:
          case 36299:
          case 36307:
            return ng;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return n_;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return nv;
        }
      })(t.type));
  }
}
class nB {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = (function (e) {
        switch (e) {
          case 5126:
            return nx;
          case 35664:
            return ny;
          case 35665:
            return nM;
          case 35666:
            return nS;
          case 35674:
            return nb;
          case 35675:
            return nT;
          case 35676:
            return nE;
          case 5124:
          case 35670:
            return nw;
          case 35667:
          case 35671:
            return nA;
          case 35668:
          case 35672:
            return nR;
          case 35669:
          case 35673:
            return nC;
          case 5125:
            return nP;
          case 36294:
            return nL;
          case 36295:
            return nN;
          case 36296:
            return nI;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return nD;
          case 35679:
          case 36299:
          case 36307:
            return nO;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return nU;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return nz;
        }
      })(t.type));
  }
}
class nk {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    let n = this.seq;
    for (let r = 0, s = n.length; r !== s; ++r) {
      let s = n[r];
      s.setValue(e, t[s.id], i);
    }
  }
}
const nH = /(\w+)(\])?(\[|\.)?/g;
function nV(e, t) {
  e.seq.push(t), (e.map[t.id] = t);
}
class nG {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    let i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; ++n) {
      let i = e.getActiveUniform(t, n),
        r = e.getUniformLocation(t, i.name);
      !(function (e, t, i) {
        let n = e.name,
          r = n.length;
        for (nH.lastIndex = 0; ; ) {
          let s = nH.exec(n),
            a = nH.lastIndex,
            o = s[1],
            l = "]" === s[2],
            h = s[3];
          if ((l && (o |= 0), void 0 === h || ("[" === h && a + 2 === r))) {
            nV(i, void 0 === h ? new nF(o, e, t) : new nB(o, e, t));
            break;
          }
          {
            let e = i.map[o];
            void 0 === e && nV(i, (e = new nk(o))), (i = e);
          }
        }
      })(i, r, this);
    }
  }
  setValue(e, t, i, n) {
    let r = this.map[t];
    void 0 !== r && r.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    let n = t[i];
    void 0 !== n && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let r = 0, s = t.length; r !== s; ++r) {
      let s = t[r],
        a = i[s.id];
      !1 !== a.needsUpdate && s.setValue(e, a.value, n);
    }
  }
  static seqWithValue(e, t) {
    let i = [];
    for (let n = 0, r = e.length; n !== r; ++n) {
      let r = e[n];
      r.id in t && i.push(r);
    }
    return i;
  }
}
function nW(e, t, i) {
  let n = e.createShader(t);
  return e.shaderSource(n, i), e.compileShader(n), n;
}
let nX = 0;
function nj(e, t, i) {
  let n = e.getShaderParameter(t, e.COMPILE_STATUS),
    r = e.getShaderInfoLog(t).trim();
  if (n && "" === r) return "";
  let s = /ERROR: 0:(\d+)/.exec(r);
  if (!s) return r;
  {
    let n = parseInt(s[1]);
    return (
      i.toUpperCase() +
      "\n\n" +
      r +
      "\n\n" +
      (function (e, t) {
        let i = e.split("\n"),
          n = [],
          r = Math.max(t - 6, 0),
          s = Math.min(t + 6, i.length);
        for (let e = r; e < s; e++) {
          let r = e + 1;
          n.push(`${r === t ? ">" : " "} ${r}: ${i[e]}`);
        }
        return n.join("\n");
      })(e.getShaderSource(t), n)
    );
  }
}
const nq = new eo();
function nJ(e) {
  return "" !== e;
}
function nY(e, t) {
  let i =
    t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return e
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, i)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function nK(e, t) {
  return e
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection
    );
}
const nZ = /^[ \t]*#include +<([\w\d./]+)>/gm;
function nQ(e) {
  return e.replace(nZ, n0);
}
const n$ = new Map();
function n0(e, t) {
  let i = id[t];
  if (void 0 === i) {
    let e = n$.get(t);
    if (void 0 !== e)
      (i = id[e]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          t,
          e
        );
    else throw Error("Can not resolve #include <" + t + ">");
  }
  return nQ(i);
}
const n1 =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function n2(e) {
  return e.replace(n1, n3);
}
function n3(e, t, i, n) {
  let r = "";
  for (let e = parseInt(t); e < parseInt(i); e++)
    r += n
      .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, e);
  return r;
}
function n5(e) {
  let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`;
  return (
    "highp" === e.precision
      ? (t += "\n#define HIGH_PRECISION")
      : "mediump" === e.precision
      ? (t += "\n#define MEDIUM_PRECISION")
      : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
    t
  );
}
function n4(e, t, i, n) {
  let r, s, a, o, l, h;
  let c = e.getContext(),
    u = i.defines,
    d = i.vertexShader,
    p = i.fragmentShader,
    m =
      ((l = "SHADOWMAP_TYPE_BASIC"),
      1 === i.shadowMapType
        ? (l = "SHADOWMAP_TYPE_PCF")
        : 2 === i.shadowMapType
        ? (l = "SHADOWMAP_TYPE_PCF_SOFT")
        : 3 === i.shadowMapType && (l = "SHADOWMAP_TYPE_VSM"),
      l),
    f = (function (e) {
      let t = "ENVMAP_TYPE_CUBE";
      if (e.envMap)
        switch (e.envMapMode) {
          case 301:
          case 302:
            t = "ENVMAP_TYPE_CUBE";
            break;
          case 306:
            t = "ENVMAP_TYPE_CUBE_UV";
        }
      return t;
    })(i),
    y =
      ((h = "ENVMAP_MODE_REFLECTION"),
      i.envMap && 302 === i.envMapMode && (h = "ENVMAP_MODE_REFRACTION"),
      h),
    M = (function (e) {
      let t = "ENVMAP_BLENDING_NONE";
      if (e.envMap)
        switch (e.combine) {
          case 0:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            t = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            t = "ENVMAP_BLENDING_ADD";
        }
      return t;
    })(i),
    T = (function (e) {
      let t = e.envMapCubeUVHeight;
      if (null === t) return null;
      let i = Math.log2(t) - 2;
      return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
        texelHeight: 1 / t,
        maxMip: i,
      };
    })(i),
    E = [
      i.extensionClipCullDistance
        ? "#extension GL_ANGLE_clip_cull_distance : require"
        : "",
      i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
    ]
      .filter(nJ)
      .join("\n"),
    w = (function (e) {
      let t = [];
      for (let i in e) {
        let n = e[i];
        !1 !== n && t.push("#define " + i + " " + n);
      }
      return t.join("\n");
    })(u),
    A = c.createProgram(),
    R = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
  i.isRawShaderMaterial
    ? ((r = [
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        w,
      ]
        .filter(nJ)
        .join("\n")).length > 0 && (r += "\n"),
      (s = [
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        w,
      ]
        .filter(nJ)
        .join("\n")).length > 0 && (s += "\n"))
    : ((r = [
        n5(i),
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        w,
        i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        i.batching ? "#define USE_BATCHING" : "",
        i.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        i.instancing ? "#define USE_INSTANCING" : "",
        i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        i.useFog && i.fog ? "#define USE_FOG" : "",
        i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
        i.map ? "#define USE_MAP" : "",
        i.envMap ? "#define USE_ENVMAP" : "",
        i.envMap ? "#define " + y : "",
        i.lightMap ? "#define USE_LIGHTMAP" : "",
        i.aoMap ? "#define USE_AOMAP" : "",
        i.bumpMap ? "#define USE_BUMPMAP" : "",
        i.normalMap ? "#define USE_NORMALMAP" : "",
        i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        i.anisotropy ? "#define USE_ANISOTROPY" : "",
        i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        i.specularMap ? "#define USE_SPECULARMAP" : "",
        i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        i.metalnessMap ? "#define USE_METALNESSMAP" : "",
        i.alphaMap ? "#define USE_ALPHAMAP" : "",
        i.alphaHash ? "#define USE_ALPHAHASH" : "",
        i.transmission ? "#define USE_TRANSMISSION" : "",
        i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        i.mapUv ? "#define MAP_UV " + i.mapUv : "",
        i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
        i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
        i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
        i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
        i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
        i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
        i.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv
          : "",
        i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
        i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
        i.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv
          : "",
        i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
        i.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv
          : "",
        i.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv
          : "",
        i.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv
          : "",
        i.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv
          : "",
        i.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv
          : "",
        i.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv
          : "",
        i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
        i.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv
          : "",
        i.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv
          : "",
        i.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv
          : "",
        i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
        i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "",
        i.vertexColors ? "#define USE_COLOR" : "",
        i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        i.vertexUv1s ? "#define USE_UV1" : "",
        i.vertexUv2s ? "#define USE_UV2" : "",
        i.vertexUv3s ? "#define USE_UV3" : "",
        i.pointsUvs ? "#define USE_POINTS_UV" : "",
        i.flatShading ? "#define FLAT_SHADED" : "",
        i.skinning ? "#define USE_SKINNING" : "",
        i.morphTargets ? "#define USE_MORPHTARGETS" : "",
        i.morphNormals && !1 === i.flatShading
          ? "#define USE_MORPHNORMALS"
          : "",
        i.morphColors ? "#define USE_MORPHCOLORS" : "",
        i.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride
          : "",
        i.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount
          : "",
        i.doubleSided ? "#define DOUBLE_SIDED" : "",
        i.flipSided ? "#define FLIP_SIDED" : "",
        i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        i.shadowMapEnabled ? "#define " + m : "",
        i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n",
      ]
        .filter(nJ)
        .join("\n")),
      (s = [
        n5(i),
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        w,
        i.useFog && i.fog ? "#define USE_FOG" : "",
        i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
        i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        i.map ? "#define USE_MAP" : "",
        i.matcap ? "#define USE_MATCAP" : "",
        i.envMap ? "#define USE_ENVMAP" : "",
        i.envMap ? "#define " + f : "",
        i.envMap ? "#define " + y : "",
        i.envMap ? "#define " + M : "",
        T ? "#define CUBEUV_TEXEL_WIDTH " + T.texelWidth : "",
        T ? "#define CUBEUV_TEXEL_HEIGHT " + T.texelHeight : "",
        T ? "#define CUBEUV_MAX_MIP " + T.maxMip + ".0" : "",
        i.lightMap ? "#define USE_LIGHTMAP" : "",
        i.aoMap ? "#define USE_AOMAP" : "",
        i.bumpMap ? "#define USE_BUMPMAP" : "",
        i.normalMap ? "#define USE_NORMALMAP" : "",
        i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        i.anisotropy ? "#define USE_ANISOTROPY" : "",
        i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        i.clearcoat ? "#define USE_CLEARCOAT" : "",
        i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        i.dispersion ? "#define USE_DISPERSION" : "",
        i.iridescence ? "#define USE_IRIDESCENCE" : "",
        i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        i.specularMap ? "#define USE_SPECULARMAP" : "",
        i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        i.metalnessMap ? "#define USE_METALNESSMAP" : "",
        i.alphaMap ? "#define USE_ALPHAMAP" : "",
        i.alphaTest ? "#define USE_ALPHATEST" : "",
        i.alphaHash ? "#define USE_ALPHAHASH" : "",
        i.sheen ? "#define USE_SHEEN" : "",
        i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        i.transmission ? "#define USE_TRANSMISSION" : "",
        i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "",
        i.vertexColors || i.instancingColor || i.batchingColor
          ? "#define USE_COLOR"
          : "",
        i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        i.vertexUv1s ? "#define USE_UV1" : "",
        i.vertexUv2s ? "#define USE_UV2" : "",
        i.vertexUv3s ? "#define USE_UV3" : "",
        i.pointsUvs ? "#define USE_POINTS_UV" : "",
        i.gradientMap ? "#define USE_GRADIENTMAP" : "",
        i.flatShading ? "#define FLAT_SHADED" : "",
        i.doubleSided ? "#define DOUBLE_SIDED" : "",
        i.flipSided ? "#define FLIP_SIDED" : "",
        i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        i.shadowMapEnabled ? "#define " + m : "",
        i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        0 !== i.toneMapping ? "#define TONE_MAPPING" : "",
        0 !== i.toneMapping ? id.tonemapping_pars_fragment : "",
        0 !== i.toneMapping
          ? (function (e, t) {
              let i;
              switch (t) {
                case 1:
                  i = "Linear";
                  break;
                case 2:
                  i = "Reinhard";
                  break;
                case 3:
                  i = "Cineon";
                  break;
                case 4:
                  i = "ACESFilmic";
                  break;
                case 6:
                  i = "AgX";
                  break;
                case 7:
                  i = "Neutral";
                  break;
                case 5:
                  i = "Custom";
                  break;
                default:
                  console.warn(
                    "THREE.WebGLProgram: Unsupported toneMapping:",
                    t
                  ),
                    (i = "Linear");
              }
              return (
                "vec3 " +
                e +
                "( vec3 color ) { return " +
                i +
                "ToneMapping( color ); }"
              );
            })("toneMapping", i.toneMapping)
          : "",
        i.dithering ? "#define DITHERING" : "",
        i.opaque ? "#define OPAQUE" : "",
        id.colorspace_pars_fragment,
        (function (e, t) {
          let i = (function (e) {
            let t;
            let i = q.getPrimaries(q.workingColorSpace),
              n = q.getPrimaries(e);
            switch (
              (i === n
                ? (t = "")
                : "p3" === i && n === S
                ? (t = "LinearDisplayP3ToLinearSRGB")
                : i === S && "p3" === n && (t = "LinearSRGBToLinearDisplayP3"),
              e)
            ) {
              case _:
              case x:
                return [t, "LinearTransferOETF"];
              case g:
              case v:
                return [t, "sRGBTransferOETF"];
              default:
                return (
                  console.warn(
                    "THREE.WebGLProgram: Unsupported color space:",
                    e
                  ),
                  [t, "LinearTransferOETF"]
                );
            }
          })(t);
          return `vec4 ${e}( vec4 value ) { return ${i[0]}( ${i[1]}( value ) ); }`;
        })("linearToOutputTexel", i.outputColorSpace),
        (function () {
          q.getLuminanceCoefficients(nq);
          let e = nq.x.toFixed(4),
            t = nq.y.toFixed(4),
            i = nq.z.toFixed(4);
          return `float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( ${e}, ${t}, ${i} );
	return dot( weights, rgb );
}`;
        })(),
        i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
        "\n",
      ]
        .filter(nJ)
        .join("\n"))),
    (d = nK((d = nY((d = nQ(d)), i)), i)),
    (p = nK((p = nY((p = nQ(p)), i)), i)),
    (d = n2(d)),
    (p = n2(p)),
    !0 !== i.isRawShaderMaterial &&
      ((R = "#version 300 es\n"),
      (r =
        [
          E,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join("\n") +
        "\n" +
        r),
      (s =
        [
          "#define varying in",
          i.glslVersion === b
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          i.glslVersion === b ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join("\n") +
        "\n" +
        s));
  let C = R + r + d,
    P = R + s + p,
    L = nW(c, c.VERTEX_SHADER, C),
    N = nW(c, c.FRAGMENT_SHADER, P);
  function I(t) {
    if (e.debug.checkShaderErrors) {
      let i = c.getProgramInfoLog(A).trim(),
        n = c.getShaderInfoLog(L).trim(),
        a = c.getShaderInfoLog(N).trim(),
        o = !0,
        l = !0;
      if (!1 === c.getProgramParameter(A, c.LINK_STATUS)) {
        if (((o = !1), "function" == typeof e.debug.onShaderError))
          e.debug.onShaderError(c, A, L, N);
        else {
          let e = nj(c, L, "vertex"),
            n = nj(c, N, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              c.getError() +
              " - VALIDATE_STATUS " +
              c.getProgramParameter(A, c.VALIDATE_STATUS) +
              "\n\nMaterial Name: " +
              t.name +
              "\nMaterial Type: " +
              t.type +
              "\n\nProgram Info Log: " +
              i +
              "\n" +
              e +
              "\n" +
              n
          );
        }
      } else
        "" !== i
          ? console.warn("THREE.WebGLProgram: Program Info Log:", i)
          : ("" === n || "" === a) && (l = !1);
      l &&
        (t.diagnostics = {
          runnable: o,
          programLog: i,
          vertexShader: { log: n, prefix: r },
          fragmentShader: { log: a, prefix: s },
        });
    }
    c.deleteShader(L),
      c.deleteShader(N),
      (a = new nG(c, A)),
      (o = (function (e, t) {
        let i = {},
          n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
        for (let r = 0; r < n; r++) {
          let n = e.getActiveAttrib(t, r),
            s = n.name,
            a = 1;
          n.type === e.FLOAT_MAT2 && (a = 2),
            n.type === e.FLOAT_MAT3 && (a = 3),
            n.type === e.FLOAT_MAT4 && (a = 4),
            (i[s] = {
              type: n.type,
              location: e.getAttribLocation(t, s),
              locationSize: a,
            });
        }
        return i;
      })(c, A));
  }
  c.attachShader(A, L),
    c.attachShader(A, N),
    void 0 !== i.index0AttributeName
      ? c.bindAttribLocation(A, 0, i.index0AttributeName)
      : !0 === i.morphTargets && c.bindAttribLocation(A, 0, "position"),
    c.linkProgram(A),
    (this.getUniforms = function () {
      return void 0 === a && I(this), a;
    }),
    (this.getAttributes = function () {
      return void 0 === o && I(this), o;
    });
  let D = !1 === i.rendererExtensionParallelShaderCompile;
  return (
    (this.isReady = function () {
      return !1 === D && (D = c.getProgramParameter(A, 37297)), D;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        c.deleteProgram(A),
        (this.program = void 0);
    }),
    (this.type = i.shaderType),
    (this.name = i.shaderName),
    (this.id = nX++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = A),
    (this.vertexShader = L),
    (this.fragmentShader = N),
    this
  );
}
let n6 = 0;
class n7 {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    let t = e.vertexShader,
      i = e.fragmentShader,
      n = this._getShaderStage(t),
      r = this._getShaderStage(i),
      s = this._getShaderCacheForMaterial(e);
    return (
      !1 === s.has(n) && (s.add(n), n.usedTimes++),
      !1 === s.has(r) && (s.add(r), r.usedTimes++),
      this
    );
  }
  remove(e) {
    for (let t of this.materialCache.get(e))
      t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    let t = this.materialCache,
      i = t.get(e);
    return void 0 === i && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    let t = this.shaderCache,
      i = t.get(e);
    return void 0 === i && ((i = new n8(e)), t.set(e, i)), i;
  }
}
class n8 {
  constructor(e) {
    (this.id = n6++), (this.code = e), (this.usedTimes = 0);
  }
}
function n9(e, t, i, n, r, s, a) {
  let o = new eJ(),
    l = new n7(),
    h = new Set(),
    c = [],
    u = r.logarithmicDepthBuffer,
    d = r.reverseDepthBuffer,
    p = r.vertexTextures,
    m = r.precision,
    f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
  function g(e) {
    return (h.add(e), 0 === e) ? "uv" : `uv${e}`;
  }
  return {
    getParameters: function (s, o, c, v, x) {
      let y, S, b, T;
      let E = v.fog,
        w = x.geometry,
        A = s.isMeshStandardMaterial ? v.environment : null,
        R = (s.isMeshStandardMaterial ? i : t).get(s.envMap || A),
        C = R && 306 === R.mapping ? R.image.height : null,
        P = f[s.type];
      null !== s.precision &&
        (m = r.getMaxPrecision(s.precision)) !== s.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          s.precision,
          "not supported, using",
          m,
          "instead."
        );
      let L =
          w.morphAttributes.position ||
          w.morphAttributes.normal ||
          w.morphAttributes.color,
        N = void 0 !== L ? L.length : 0,
        I = 0;
      if (
        (void 0 !== w.morphAttributes.position && (I = 1),
        void 0 !== w.morphAttributes.normal && (I = 2),
        void 0 !== w.morphAttributes.color && (I = 3),
        P)
      ) {
        let e = im[P];
        (y = e.vertexShader), (S = e.fragmentShader);
      } else
        (y = s.vertexShader),
          (S = s.fragmentShader),
          l.update(s),
          (b = l.getVertexShaderID(s)),
          (T = l.getFragmentShaderID(s));
      let D = e.getRenderTarget(),
        O = !0 === x.isInstancedMesh,
        U = !0 === x.isBatchedMesh,
        z = !!s.map,
        F = !!s.matcap,
        B = !!R,
        k = !!s.aoMap,
        H = !!s.lightMap,
        V = !!s.bumpMap,
        G = !!s.normalMap,
        W = !!s.displacementMap,
        X = !!s.emissiveMap,
        j = !!s.metalnessMap,
        J = !!s.roughnessMap,
        Y = s.anisotropy > 0,
        K = s.clearcoat > 0,
        Z = s.dispersion > 0,
        Q = s.iridescence > 0,
        $ = s.sheen > 0,
        ee = s.transmission > 0,
        et = Y && !!s.anisotropyMap,
        ei = K && !!s.clearcoatMap,
        en = K && !!s.clearcoatNormalMap,
        er = K && !!s.clearcoatRoughnessMap,
        es = Q && !!s.iridescenceMap,
        ea = Q && !!s.iridescenceThicknessMap,
        eo = $ && !!s.sheenColorMap,
        el = $ && !!s.sheenRoughnessMap,
        eh = !!s.specularMap,
        ec = !!s.specularColorMap,
        eu = !!s.specularIntensityMap,
        ed = ee && !!s.transmissionMap,
        ep = ee && !!s.thicknessMap,
        em = !!s.gradientMap,
        ef = !!s.alphaMap,
        eg = s.alphaTest > 0,
        e_ = !!s.alphaHash,
        ev = !!s.extensions,
        ex = 0;
      s.toneMapped &&
        (null === D || !0 === D.isXRRenderTarget) &&
        (ex = e.toneMapping);
      let ey = {
        shaderID: P,
        shaderType: s.type,
        shaderName: s.name,
        vertexShader: y,
        fragmentShader: S,
        defines: s.defines,
        customVertexShaderID: b,
        customFragmentShaderID: T,
        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
        glslVersion: s.glslVersion,
        precision: m,
        batching: U,
        batchingColor: U && null !== x._colorsTexture,
        instancing: O,
        instancingColor: O && null !== x.instanceColor,
        instancingMorph: O && null !== x.morphTexture,
        supportsVertexTextures: p,
        outputColorSpace:
          null === D
            ? e.outputColorSpace
            : !0 === D.isXRRenderTarget
            ? D.texture.colorSpace
            : _,
        alphaToCoverage: !!s.alphaToCoverage,
        map: z,
        matcap: F,
        envMap: B,
        envMapMode: B && R.mapping,
        envMapCubeUVHeight: C,
        aoMap: k,
        lightMap: H,
        bumpMap: V,
        normalMap: G,
        displacementMap: p && W,
        emissiveMap: X,
        normalMapObjectSpace: G && 1 === s.normalMapType,
        normalMapTangentSpace: G && 0 === s.normalMapType,
        metalnessMap: j,
        roughnessMap: J,
        anisotropy: Y,
        anisotropyMap: et,
        clearcoat: K,
        clearcoatMap: ei,
        clearcoatNormalMap: en,
        clearcoatRoughnessMap: er,
        dispersion: Z,
        iridescence: Q,
        iridescenceMap: es,
        iridescenceThicknessMap: ea,
        sheen: $,
        sheenColorMap: eo,
        sheenRoughnessMap: el,
        specularMap: eh,
        specularColorMap: ec,
        specularIntensityMap: eu,
        transmission: ee,
        transmissionMap: ed,
        thicknessMap: ep,
        gradientMap: em,
        opaque:
          !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage,
        alphaMap: ef,
        alphaTest: eg,
        alphaHash: e_,
        combine: s.combine,
        mapUv: z && g(s.map.channel),
        aoMapUv: k && g(s.aoMap.channel),
        lightMapUv: H && g(s.lightMap.channel),
        bumpMapUv: V && g(s.bumpMap.channel),
        normalMapUv: G && g(s.normalMap.channel),
        displacementMapUv: W && g(s.displacementMap.channel),
        emissiveMapUv: X && g(s.emissiveMap.channel),
        metalnessMapUv: j && g(s.metalnessMap.channel),
        roughnessMapUv: J && g(s.roughnessMap.channel),
        anisotropyMapUv: et && g(s.anisotropyMap.channel),
        clearcoatMapUv: ei && g(s.clearcoatMap.channel),
        clearcoatNormalMapUv: en && g(s.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: er && g(s.clearcoatRoughnessMap.channel),
        iridescenceMapUv: es && g(s.iridescenceMap.channel),
        iridescenceThicknessMapUv: ea && g(s.iridescenceThicknessMap.channel),
        sheenColorMapUv: eo && g(s.sheenColorMap.channel),
        sheenRoughnessMapUv: el && g(s.sheenRoughnessMap.channel),
        specularMapUv: eh && g(s.specularMap.channel),
        specularColorMapUv: ec && g(s.specularColorMap.channel),
        specularIntensityMapUv: eu && g(s.specularIntensityMap.channel),
        transmissionMapUv: ed && g(s.transmissionMap.channel),
        thicknessMapUv: ep && g(s.thicknessMap.channel),
        alphaMapUv: ef && g(s.alphaMap.channel),
        vertexTangents: !!w.attributes.tangent && (G || Y),
        vertexColors: s.vertexColors,
        vertexAlphas:
          !0 === s.vertexColors &&
          !!w.attributes.color &&
          4 === w.attributes.color.itemSize,
        pointsUvs: !0 === x.isPoints && !!w.attributes.uv && (z || ef),
        fog: !!E,
        useFog: !0 === s.fog,
        fogExp2: !!E && E.isFogExp2,
        flatShading: !0 === s.flatShading,
        sizeAttenuation: !0 === s.sizeAttenuation,
        logarithmicDepthBuffer: u,
        reverseDepthBuffer: d,
        skinning: !0 === x.isSkinnedMesh,
        morphTargets: void 0 !== w.morphAttributes.position,
        morphNormals: void 0 !== w.morphAttributes.normal,
        morphColors: void 0 !== w.morphAttributes.color,
        morphTargetsCount: N,
        morphTextureStride: I,
        numDirLights: o.directional.length,
        numPointLights: o.point.length,
        numSpotLights: o.spot.length,
        numSpotLightMaps: o.spotLightMap.length,
        numRectAreaLights: o.rectArea.length,
        numHemiLights: o.hemi.length,
        numDirLightShadows: o.directionalShadowMap.length,
        numPointLightShadows: o.pointShadowMap.length,
        numSpotLightShadows: o.spotShadowMap.length,
        numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
        numLightProbes: o.numLightProbes,
        numClippingPlanes: a.numPlanes,
        numClipIntersection: a.numIntersection,
        dithering: s.dithering,
        shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
        shadowMapType: e.shadowMap.type,
        toneMapping: ex,
        decodeVideoTexture:
          z &&
          !0 === s.map.isVideoTexture &&
          q.getTransfer(s.map.colorSpace) === M,
        premultipliedAlpha: s.premultipliedAlpha,
        doubleSided: 2 === s.side,
        flipSided: 1 === s.side,
        useDepthPacking: s.depthPacking >= 0,
        depthPacking: s.depthPacking || 0,
        index0AttributeName: s.index0AttributeName,
        extensionClipCullDistance:
          ev &&
          !0 === s.extensions.clipCullDistance &&
          n.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw:
          ((ev && !0 === s.extensions.multiDraw) || U) &&
          n.has("WEBGL_multi_draw"),
        rendererExtensionParallelShaderCompile: n.has(
          "KHR_parallel_shader_compile"
        ),
        customProgramCacheKey: s.customProgramCacheKey(),
      };
      return (
        (ey.vertexUv1s = h.has(1)),
        (ey.vertexUv2s = h.has(2)),
        (ey.vertexUv3s = h.has(3)),
        h.clear(),
        ey
      );
    },
    getProgramCacheKey: function (t) {
      let i = [];
      if (
        (t.shaderID
          ? i.push(t.shaderID)
          : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)),
        void 0 !== t.defines)
      )
        for (let e in t.defines) i.push(e), i.push(t.defines[e]);
      return (
        !1 === t.isRawShaderMaterial &&
          (i.push(t.precision),
          i.push(t.outputColorSpace),
          i.push(t.envMapMode),
          i.push(t.envMapCubeUVHeight),
          i.push(t.mapUv),
          i.push(t.alphaMapUv),
          i.push(t.lightMapUv),
          i.push(t.aoMapUv),
          i.push(t.bumpMapUv),
          i.push(t.normalMapUv),
          i.push(t.displacementMapUv),
          i.push(t.emissiveMapUv),
          i.push(t.metalnessMapUv),
          i.push(t.roughnessMapUv),
          i.push(t.anisotropyMapUv),
          i.push(t.clearcoatMapUv),
          i.push(t.clearcoatNormalMapUv),
          i.push(t.clearcoatRoughnessMapUv),
          i.push(t.iridescenceMapUv),
          i.push(t.iridescenceThicknessMapUv),
          i.push(t.sheenColorMapUv),
          i.push(t.sheenRoughnessMapUv),
          i.push(t.specularMapUv),
          i.push(t.specularColorMapUv),
          i.push(t.specularIntensityMapUv),
          i.push(t.transmissionMapUv),
          i.push(t.thicknessMapUv),
          i.push(t.combine),
          i.push(t.fogExp2),
          i.push(t.sizeAttenuation),
          i.push(t.morphTargetsCount),
          i.push(t.morphAttributeCount),
          i.push(t.numDirLights),
          i.push(t.numPointLights),
          i.push(t.numSpotLights),
          i.push(t.numSpotLightMaps),
          i.push(t.numHemiLights),
          i.push(t.numRectAreaLights),
          i.push(t.numDirLightShadows),
          i.push(t.numPointLightShadows),
          i.push(t.numSpotLightShadows),
          i.push(t.numSpotLightShadowsWithMaps),
          i.push(t.numLightProbes),
          i.push(t.shadowMapType),
          i.push(t.toneMapping),
          i.push(t.numClippingPlanes),
          i.push(t.numClipIntersection),
          i.push(t.depthPacking),
          o.disableAll(),
          t.supportsVertexTextures && o.enable(0),
          t.instancing && o.enable(1),
          t.instancingColor && o.enable(2),
          t.instancingMorph && o.enable(3),
          t.matcap && o.enable(4),
          t.envMap && o.enable(5),
          t.normalMapObjectSpace && o.enable(6),
          t.normalMapTangentSpace && o.enable(7),
          t.clearcoat && o.enable(8),
          t.iridescence && o.enable(9),
          t.alphaTest && o.enable(10),
          t.vertexColors && o.enable(11),
          t.vertexAlphas && o.enable(12),
          t.vertexUv1s && o.enable(13),
          t.vertexUv2s && o.enable(14),
          t.vertexUv3s && o.enable(15),
          t.vertexTangents && o.enable(16),
          t.anisotropy && o.enable(17),
          t.alphaHash && o.enable(18),
          t.batching && o.enable(19),
          t.dispersion && o.enable(20),
          t.batchingColor && o.enable(21),
          i.push(o.mask),
          o.disableAll(),
          t.fog && o.enable(0),
          t.useFog && o.enable(1),
          t.flatShading && o.enable(2),
          t.logarithmicDepthBuffer && o.enable(3),
          t.reverseDepthBuffer && o.enable(4),
          t.skinning && o.enable(5),
          t.morphTargets && o.enable(6),
          t.morphNormals && o.enable(7),
          t.morphColors && o.enable(8),
          t.premultipliedAlpha && o.enable(9),
          t.shadowMapEnabled && o.enable(10),
          t.doubleSided && o.enable(11),
          t.flipSided && o.enable(12),
          t.useDepthPacking && o.enable(13),
          t.dithering && o.enable(14),
          t.transmission && o.enable(15),
          t.sheen && o.enable(16),
          t.opaque && o.enable(17),
          t.pointsUvs && o.enable(18),
          t.decodeVideoTexture && o.enable(19),
          t.alphaToCoverage && o.enable(20),
          i.push(o.mask),
          i.push(e.outputColorSpace)),
        i.push(t.customProgramCacheKey),
        i.join()
      );
    },
    getUniforms: function (e) {
      let t;
      let i = f[e.type];
      if (i) {
        let e = im[i];
        t = t1.clone(e.uniforms);
      } else t = e.uniforms;
      return t;
    },
    acquireProgram: function (t, i) {
      let n;
      for (let e = 0, t = c.length; e < t; e++) {
        let t = c[e];
        if (t.cacheKey === i) {
          (n = t), ++n.usedTimes;
          break;
        }
      }
      return void 0 === n && ((n = new n4(e, i, t, s)), c.push(n)), n;
    },
    releaseProgram: function (e) {
      if (0 == --e.usedTimes) {
        let t = c.indexOf(e);
        (c[t] = c[c.length - 1]), c.pop(), e.destroy();
      }
    },
    releaseShaderCache: function (e) {
      l.remove(e);
    },
    programs: c,
    dispose: function () {
      l.dispose();
    },
  };
}
function re() {
  let e = new WeakMap();
  return {
    has: function (t) {
      return e.has(t);
    },
    get: function (t) {
      let i = e.get(t);
      return void 0 === i && ((i = {}), e.set(t, i)), i;
    },
    remove: function (t) {
      e.delete(t);
    },
    update: function (t, i, n) {
      e.get(t)[i] = n;
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function rt(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.material.id !== t.material.id
    ? e.material.id - t.material.id
    : e.z !== t.z
    ? e.z - t.z
    : e.id - t.id;
}
function ri(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.z !== t.z
    ? t.z - e.z
    : e.id - t.id;
}
function rn() {
  let e = [],
    t = 0,
    i = [],
    n = [],
    r = [];
  function s(i, n, r, s, a, o) {
    let l = e[t];
    return (
      void 0 === l
        ? ((l = {
            id: i.id,
            object: i,
            geometry: n,
            material: r,
            groupOrder: s,
            renderOrder: i.renderOrder,
            z: a,
            group: o,
          }),
          (e[t] = l))
        : ((l.id = i.id),
          (l.object = i),
          (l.geometry = n),
          (l.material = r),
          (l.groupOrder = s),
          (l.renderOrder = i.renderOrder),
          (l.z = a),
          (l.group = o)),
      t++,
      l
    );
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: r,
    init: function () {
      (t = 0), (i.length = 0), (n.length = 0), (r.length = 0);
    },
    push: function (e, t, a, o, l, h) {
      let c = s(e, t, a, o, l, h);
      a.transmission > 0
        ? n.push(c)
        : !0 === a.transparent
        ? r.push(c)
        : i.push(c);
    },
    unshift: function (e, t, a, o, l, h) {
      let c = s(e, t, a, o, l, h);
      a.transmission > 0
        ? n.unshift(c)
        : !0 === a.transparent
        ? r.unshift(c)
        : i.unshift(c);
    },
    finish: function () {
      for (let i = t, n = e.length; i < n; i++) {
        let t = e[i];
        if (null === t.id) break;
        (t.id = null),
          (t.object = null),
          (t.geometry = null),
          (t.material = null),
          (t.group = null);
      }
    },
    sort: function (e, t) {
      i.length > 1 && i.sort(e || rt),
        n.length > 1 && n.sort(t || ri),
        r.length > 1 && r.sort(t || ri);
    },
  };
}
function rr() {
  let e = new WeakMap();
  return {
    get: function (t, i) {
      let n;
      let r = e.get(t);
      return (
        void 0 === r
          ? ((n = new rn()), e.set(t, [n]))
          : i >= r.length
          ? ((n = new rn()), r.push(n))
          : (n = r[i]),
        n
      );
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function rs() {
  let e = {};
  return {
    get: function (t) {
      let i;
      if (void 0 !== e[t.id]) return e[t.id];
      switch (t.type) {
        case "DirectionalLight":
          i = { direction: new eo(), color: new tx() };
          break;
        case "SpotLight":
          i = {
            position: new eo(),
            direction: new eo(),
            color: new tx(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          i = { position: new eo(), color: new tx(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          i = {
            direction: new eo(),
            skyColor: new tx(),
            groundColor: new tx(),
          };
          break;
        case "RectAreaLight":
          i = {
            color: new tx(),
            position: new eo(),
            halfWidth: new eo(),
            halfHeight: new eo(),
          };
      }
      return (e[t.id] = i), i;
    },
  };
}
let ra = 0;
function ro(e, t) {
  return (
    (t.castShadow ? 2 : 0) -
    (e.castShadow ? 2 : 0) +
    (t.map ? 1 : 0) -
    (e.map ? 1 : 0)
  );
}
function rl(e) {
  let t = new rs(),
    i = (function () {
      let e = {};
      return {
        get: function (t) {
          let i;
          if (void 0 !== e[t.id]) return e[t.id];
          switch (t.type) {
            case "DirectionalLight":
            case "SpotLight":
              i = {
                shadowIntensity: 1,
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new U(),
              };
              break;
            case "PointLight":
              i = {
                shadowIntensity: 1,
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new U(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3,
              };
          }
          return (e[t.id] = i), i;
        },
      };
    })(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let e = 0; e < 9; e++) n.probe.push(new eo());
  let r = new eo(),
    s = new ez(),
    a = new ez();
  return {
    setup: function (r) {
      let s = 0,
        a = 0,
        o = 0;
      for (let e = 0; e < 9; e++) n.probe[e].set(0, 0, 0);
      let l = 0,
        h = 0,
        c = 0,
        u = 0,
        d = 0,
        p = 0,
        m = 0,
        f = 0,
        g = 0,
        _ = 0,
        v = 0;
      r.sort(ro);
      for (let e = 0, x = r.length; e < x; e++) {
        let x = r[e],
          y = x.color,
          M = x.intensity,
          S = x.distance,
          b = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
        if (x.isAmbientLight) (s += y.r * M), (a += y.g * M), (o += y.b * M);
        else if (x.isLightProbe) {
          for (let e = 0; e < 9; e++)
            n.probe[e].addScaledVector(x.sh.coefficients[e], M);
          v++;
        } else if (x.isDirectionalLight) {
          let e = t.get(x);
          if (
            (e.color.copy(x.color).multiplyScalar(x.intensity), x.castShadow)
          ) {
            let e = x.shadow,
              t = i.get(x);
            (t.shadowIntensity = e.intensity),
              (t.shadowBias = e.bias),
              (t.shadowNormalBias = e.normalBias),
              (t.shadowRadius = e.radius),
              (t.shadowMapSize = e.mapSize),
              (n.directionalShadow[l] = t),
              (n.directionalShadowMap[l] = b),
              (n.directionalShadowMatrix[l] = x.shadow.matrix),
              p++;
          }
          (n.directional[l] = e), l++;
        } else if (x.isSpotLight) {
          let e = t.get(x);
          e.position.setFromMatrixPosition(x.matrixWorld),
            e.color.copy(y).multiplyScalar(M),
            (e.distance = S),
            (e.coneCos = Math.cos(x.angle)),
            (e.penumbraCos = Math.cos(x.angle * (1 - x.penumbra))),
            (e.decay = x.decay),
            (n.spot[c] = e);
          let r = x.shadow;
          if (
            (x.map &&
              ((n.spotLightMap[g] = x.map),
              g++,
              r.updateMatrices(x),
              x.castShadow && _++),
            (n.spotLightMatrix[c] = r.matrix),
            x.castShadow)
          ) {
            let e = i.get(x);
            (e.shadowIntensity = r.intensity),
              (e.shadowBias = r.bias),
              (e.shadowNormalBias = r.normalBias),
              (e.shadowRadius = r.radius),
              (e.shadowMapSize = r.mapSize),
              (n.spotShadow[c] = e),
              (n.spotShadowMap[c] = b),
              f++;
          }
          c++;
        } else if (x.isRectAreaLight) {
          let e = t.get(x);
          e.color.copy(y).multiplyScalar(M),
            e.halfWidth.set(0.5 * x.width, 0, 0),
            e.halfHeight.set(0, 0.5 * x.height, 0),
            (n.rectArea[u] = e),
            u++;
        } else if (x.isPointLight) {
          let e = t.get(x);
          if (
            (e.color.copy(x.color).multiplyScalar(x.intensity),
            (e.distance = x.distance),
            (e.decay = x.decay),
            x.castShadow)
          ) {
            let e = x.shadow,
              t = i.get(x);
            (t.shadowIntensity = e.intensity),
              (t.shadowBias = e.bias),
              (t.shadowNormalBias = e.normalBias),
              (t.shadowRadius = e.radius),
              (t.shadowMapSize = e.mapSize),
              (t.shadowCameraNear = e.camera.near),
              (t.shadowCameraFar = e.camera.far),
              (n.pointShadow[h] = t),
              (n.pointShadowMap[h] = b),
              (n.pointShadowMatrix[h] = x.shadow.matrix),
              m++;
          }
          (n.point[h] = e), h++;
        } else if (x.isHemisphereLight) {
          let e = t.get(x);
          e.skyColor.copy(x.color).multiplyScalar(M),
            e.groundColor.copy(x.groundColor).multiplyScalar(M),
            (n.hemi[d] = e),
            d++;
        }
      }
      u > 0 &&
        (!0 === e.has("OES_texture_float_linear")
          ? ((n.rectAreaLTC1 = ip.LTC_FLOAT_1),
            (n.rectAreaLTC2 = ip.LTC_FLOAT_2))
          : ((n.rectAreaLTC1 = ip.LTC_HALF_1),
            (n.rectAreaLTC2 = ip.LTC_HALF_2))),
        (n.ambient[0] = s),
        (n.ambient[1] = a),
        (n.ambient[2] = o);
      let x = n.hash;
      (x.directionalLength !== l ||
        x.pointLength !== h ||
        x.spotLength !== c ||
        x.rectAreaLength !== u ||
        x.hemiLength !== d ||
        x.numDirectionalShadows !== p ||
        x.numPointShadows !== m ||
        x.numSpotShadows !== f ||
        x.numSpotMaps !== g ||
        x.numLightProbes !== v) &&
        ((n.directional.length = l),
        (n.spot.length = c),
        (n.rectArea.length = u),
        (n.point.length = h),
        (n.hemi.length = d),
        (n.directionalShadow.length = p),
        (n.directionalShadowMap.length = p),
        (n.pointShadow.length = m),
        (n.pointShadowMap.length = m),
        (n.spotShadow.length = f),
        (n.spotShadowMap.length = f),
        (n.directionalShadowMatrix.length = p),
        (n.pointShadowMatrix.length = m),
        (n.spotLightMatrix.length = f + g - _),
        (n.spotLightMap.length = g),
        (n.numSpotLightShadowsWithMaps = _),
        (n.numLightProbes = v),
        (x.directionalLength = l),
        (x.pointLength = h),
        (x.spotLength = c),
        (x.rectAreaLength = u),
        (x.hemiLength = d),
        (x.numDirectionalShadows = p),
        (x.numPointShadows = m),
        (x.numSpotShadows = f),
        (x.numSpotMaps = g),
        (x.numLightProbes = v),
        (n.version = ra++));
    },
    setupView: function (e, t) {
      let i = 0,
        o = 0,
        l = 0,
        h = 0,
        c = 0,
        u = t.matrixWorldInverse;
      for (let t = 0, d = e.length; t < d; t++) {
        let d = e[t];
        if (d.isDirectionalLight) {
          let e = n.directional[i];
          e.direction.setFromMatrixPosition(d.matrixWorld),
            r.setFromMatrixPosition(d.target.matrixWorld),
            e.direction.sub(r),
            e.direction.transformDirection(u),
            i++;
        } else if (d.isSpotLight) {
          let e = n.spot[l];
          e.position.setFromMatrixPosition(d.matrixWorld),
            e.position.applyMatrix4(u),
            e.direction.setFromMatrixPosition(d.matrixWorld),
            r.setFromMatrixPosition(d.target.matrixWorld),
            e.direction.sub(r),
            e.direction.transformDirection(u),
            l++;
        } else if (d.isRectAreaLight) {
          let e = n.rectArea[h];
          e.position.setFromMatrixPosition(d.matrixWorld),
            e.position.applyMatrix4(u),
            a.identity(),
            s.copy(d.matrixWorld),
            s.premultiply(u),
            a.extractRotation(s),
            e.halfWidth.set(0.5 * d.width, 0, 0),
            e.halfHeight.set(0, 0.5 * d.height, 0),
            e.halfWidth.applyMatrix4(a),
            e.halfHeight.applyMatrix4(a),
            h++;
        } else if (d.isPointLight) {
          let e = n.point[o];
          e.position.setFromMatrixPosition(d.matrixWorld),
            e.position.applyMatrix4(u),
            o++;
        } else if (d.isHemisphereLight) {
          let e = n.hemi[c];
          e.direction.setFromMatrixPosition(d.matrixWorld),
            e.direction.transformDirection(u),
            c++;
        }
      }
    },
    state: n,
  };
}
function rh(e) {
  let t = new rl(e),
    i = [],
    n = [],
    r = {
      lightsArray: i,
      shadowsArray: n,
      camera: null,
      lights: t,
      transmissionRenderTarget: {},
    };
  return {
    init: function (e) {
      (r.camera = e), (i.length = 0), (n.length = 0);
    },
    state: r,
    setupLights: function () {
      t.setup(i);
    },
    setupLightsView: function (e) {
      t.setupView(i, e);
    },
    pushLight: function (e) {
      i.push(e);
    },
    pushShadow: function (e) {
      n.push(e);
    },
  };
}
function rc(e) {
  let t = new WeakMap();
  return {
    get: function (i, n = 0) {
      let r;
      let s = t.get(i);
      return (
        void 0 === s
          ? ((r = new rh(e)), t.set(i, [r]))
          : n >= s.length
          ? ((r = new rh(e)), s.push(r))
          : (r = s[n]),
        r
      );
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
class ru extends tS {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = 3200),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class rd extends tS {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
function rp(e, t, i) {
  let n = new il(),
    r = new U(),
    s = new U(),
    a = new ei(),
    o = new ru({ depthPacking: 3201 }),
    l = new rd(),
    h = {},
    c = i.maxTextureSize,
    u = { 0: 1, 1: 0, 2: 2 },
    d = new t2({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new U() },
        radius: { value: 4 },
      },
      vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
      fragmentShader:
        "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
    }),
    p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  let m = new tz();
  m.setAttribute(
    "position",
    new tw(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  let f = new tY(m, d),
    g = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = 1);
  let _ = this.type;
  function v(t, i, n, r) {
    let s = null,
      a =
        !0 === n.isPointLight
          ? t.customDistanceMaterial
          : t.customDepthMaterial;
    if (void 0 !== a) s = a;
    else if (
      ((s = !0 === n.isPointLight ? l : o),
      (e.localClippingEnabled &&
        !0 === i.clipShadows &&
        Array.isArray(i.clippingPlanes) &&
        0 !== i.clippingPlanes.length) ||
        (i.displacementMap && 0 !== i.displacementScale) ||
        (i.alphaMap && i.alphaTest > 0) ||
        (i.map && i.alphaTest > 0))
    ) {
      let e = s.uuid,
        t = i.uuid,
        n = h[e];
      void 0 === n && ((n = {}), (h[e] = n));
      let r = n[t];
      void 0 === r &&
        ((r = s.clone()), (n[t] = r), i.addEventListener("dispose", x)),
        (s = r);
    }
    return (
      (s.visible = i.visible),
      (s.wireframe = i.wireframe),
      3 === r
        ? (s.side = null !== i.shadowSide ? i.shadowSide : i.side)
        : (s.side = null !== i.shadowSide ? i.shadowSide : u[i.side]),
      (s.alphaMap = i.alphaMap),
      (s.alphaTest = i.alphaTest),
      (s.map = i.map),
      (s.clipShadows = i.clipShadows),
      (s.clippingPlanes = i.clippingPlanes),
      (s.clipIntersection = i.clipIntersection),
      (s.displacementMap = i.displacementMap),
      (s.displacementScale = i.displacementScale),
      (s.displacementBias = i.displacementBias),
      (s.wireframeLinewidth = i.wireframeLinewidth),
      (s.linewidth = i.linewidth),
      !0 === n.isPointLight &&
        !0 === s.isMeshDistanceMaterial &&
        (e.properties.get(s).light = n),
      s
    );
  }
  function x(e) {
    for (let t in (e.target.removeEventListener("dispose", x), h)) {
      let i = h[t],
        n = e.target.uuid;
      n in i && (i[n].dispose(), delete i[n]);
    }
  }
  this.render = function (i, o, l) {
    if (
      !1 === g.enabled ||
      (!1 === g.autoUpdate && !1 === g.needsUpdate) ||
      0 === i.length
    )
      return;
    let h = e.getRenderTarget(),
      u = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      x = e.state;
    x.setBlending(0),
      x.buffers.color.setClear(1, 1, 1, 1),
      x.buffers.depth.setTest(!0),
      x.setScissorTest(!1);
    let y = 3 !== _ && 3 === this.type,
      M = 3 === _ && 3 !== this.type;
    for (let h = 0, u = i.length; h < u; h++) {
      let u = i[h],
        m = u.shadow;
      if (void 0 === m) {
        console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
        continue;
      }
      if (!1 === m.autoUpdate && !1 === m.needsUpdate) continue;
      r.copy(m.mapSize);
      let g = m.getFrameExtents();
      if (
        (r.multiply(g),
        s.copy(m.mapSize),
        (r.x > c || r.y > c) &&
          (r.x > c &&
            ((s.x = Math.floor(c / g.x)),
            (r.x = s.x * g.x),
            (m.mapSize.x = s.x)),
          r.y > c &&
            ((s.y = Math.floor(c / g.y)),
            (r.y = s.y * g.y),
            (m.mapSize.y = s.y))),
        null === m.map || !0 === y || !0 === M)
      ) {
        let e = 3 !== this.type ? { minFilter: 1003, magFilter: 1003 } : {};
        null !== m.map && m.map.dispose(),
          (m.map = new er(r.x, r.y, e)),
          (m.map.texture.name = u.name + ".shadowMap"),
          m.camera.updateProjectionMatrix();
      }
      e.setRenderTarget(m.map), e.clear();
      let _ = m.getViewportCount();
      for (let i = 0; i < _; i++) {
        let r = m.getViewport(i);
        a.set(s.x * r.x, s.y * r.y, s.x * r.z, s.y * r.w),
          x.viewport(a),
          m.updateMatrices(u, i),
          (n = m.getFrustum()),
          (function i(r, s, a, o, l) {
            if (!1 === r.visible) return;
            if (
              r.layers.test(s.layers) &&
              (r.isMesh || r.isLine || r.isPoints) &&
              (r.castShadow || (r.receiveShadow && 3 === l)) &&
              (!r.frustumCulled || n.intersectsObject(r))
            ) {
              r.modelViewMatrix.multiplyMatrices(
                a.matrixWorldInverse,
                r.matrixWorld
              );
              let i = t.update(r),
                n = r.material;
              if (Array.isArray(n)) {
                let t = i.groups;
                for (let h = 0, c = t.length; h < c; h++) {
                  let c = t[h],
                    u = n[c.materialIndex];
                  if (u && u.visible) {
                    let t = v(r, u, o, l);
                    r.onBeforeShadow(e, r, s, a, i, t, c),
                      e.renderBufferDirect(a, null, i, t, r, c),
                      r.onAfterShadow(e, r, s, a, i, t, c);
                  }
                }
              } else if (n.visible) {
                let t = v(r, n, o, l);
                r.onBeforeShadow(e, r, s, a, i, t, null),
                  e.renderBufferDirect(a, null, i, t, r, null),
                  r.onAfterShadow(e, r, s, a, i, t, null);
              }
            }
            let h = r.children;
            for (let e = 0, t = h.length; e < t; e++) i(h[e], s, a, o, l);
          })(o, l, m.camera, u, this.type);
      }
      !0 !== m.isPointLightShadow &&
        3 === this.type &&
        (function (i, n) {
          let s = t.update(f);
          d.defines.VSM_SAMPLES !== i.blurSamples &&
            ((d.defines.VSM_SAMPLES = i.blurSamples),
            (p.defines.VSM_SAMPLES = i.blurSamples),
            (d.needsUpdate = !0),
            (p.needsUpdate = !0)),
            null === i.mapPass && (i.mapPass = new er(r.x, r.y)),
            (d.uniforms.shadow_pass.value = i.map.texture),
            (d.uniforms.resolution.value = i.mapSize),
            (d.uniforms.radius.value = i.radius),
            e.setRenderTarget(i.mapPass),
            e.clear(),
            e.renderBufferDirect(n, null, s, d, f, null),
            (p.uniforms.shadow_pass.value = i.mapPass.texture),
            (p.uniforms.resolution.value = i.mapSize),
            (p.uniforms.radius.value = i.radius),
            e.setRenderTarget(i.map),
            e.clear(),
            e.renderBufferDirect(n, null, s, p, f, null);
        })(m, l),
        (m.needsUpdate = !1);
    }
    (_ = this.type), (g.needsUpdate = !1), e.setRenderTarget(h, u, m);
  };
}
const rm = { 0: 1, 2: 6, 4: 7, 3: 5, 1: 0, 6: 2, 7: 4, 5: 3 };
function rf(e) {
  let t = new (function () {
      let t = !1,
        i = new ei(),
        n = null,
        r = new ei(0, 0, 0, 0);
      return {
        setMask: function (i) {
          n === i || t || (e.colorMask(i, i, i, i), (n = i));
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t, n, s, a, o) {
          !0 === o && ((t *= a), (n *= a), (s *= a)),
            i.set(t, n, s, a),
            !1 === r.equals(i) && (e.clearColor(t, n, s, a), r.copy(i));
        },
        reset: function () {
          (t = !1), (n = null), r.set(-1, 0, 0, 0);
        },
      };
    })(),
    i = new (function () {
      let t = !1,
        i = !1,
        n = null,
        r = null,
        s = null;
      return {
        setReversed: function (e) {
          i = e;
        },
        setTest: function (t) {
          t ? F(e.DEPTH_TEST) : B(e.DEPTH_TEST);
        },
        setMask: function (i) {
          n === i || t || (e.depthMask(i), (n = i));
        },
        setFunc: function (t) {
          if ((i && (t = rm[t]), r !== t)) {
            switch (t) {
              case 0:
                e.depthFunc(e.NEVER);
                break;
              case 1:
                e.depthFunc(e.ALWAYS);
                break;
              case 2:
                e.depthFunc(e.LESS);
                break;
              case 3:
              default:
                e.depthFunc(e.LEQUAL);
                break;
              case 4:
                e.depthFunc(e.EQUAL);
                break;
              case 5:
                e.depthFunc(e.GEQUAL);
                break;
              case 6:
                e.depthFunc(e.GREATER);
                break;
              case 7:
                e.depthFunc(e.NOTEQUAL);
            }
            r = t;
          }
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t) {
          s !== t && (e.clearDepth(t), (s = t));
        },
        reset: function () {
          (t = !1), (n = null), (r = null), (s = null);
        },
      };
    })(),
    n = new (function () {
      let t = !1,
        i = null,
        n = null,
        r = null,
        s = null,
        a = null,
        o = null,
        l = null,
        h = null;
      return {
        setTest: function (i) {
          t || (i ? F(e.STENCIL_TEST) : B(e.STENCIL_TEST));
        },
        setMask: function (n) {
          i === n || t || (e.stencilMask(n), (i = n));
        },
        setFunc: function (t, i, a) {
          (n !== t || r !== i || s !== a) &&
            (e.stencilFunc(t, i, a), (n = t), (r = i), (s = a));
        },
        setOp: function (t, i, n) {
          (a !== t || o !== i || l !== n) &&
            (e.stencilOp(t, i, n), (a = t), (o = i), (l = n));
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t) {
          h !== t && (e.clearStencil(t), (h = t));
        },
        reset: function () {
          (t = !1),
            (i = null),
            (n = null),
            (r = null),
            (s = null),
            (a = null),
            (o = null),
            (l = null),
            (h = null);
        },
      };
    })(),
    r = new WeakMap(),
    s = new WeakMap(),
    a = {},
    o = {},
    l = new WeakMap(),
    h = [],
    c = null,
    u = !1,
    d = null,
    p = null,
    m = null,
    f = null,
    g = null,
    _ = null,
    v = null,
    x = new tx(0, 0, 0),
    y = 0,
    M = !1,
    S = null,
    b = null,
    T = null,
    E = null,
    w = null,
    A = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    R = !1,
    C = e.getParameter(e.VERSION);
  -1 !== C.indexOf("WebGL")
    ? (R = parseFloat(/^WebGL (\d)/.exec(C)[1]) >= 1)
    : -1 !== C.indexOf("OpenGL ES") &&
      (R = parseFloat(/^OpenGL ES (\d)/.exec(C)[1]) >= 2);
  let P = null,
    L = {},
    N = e.getParameter(e.SCISSOR_BOX),
    I = e.getParameter(e.VIEWPORT),
    D = new ei().fromArray(N),
    O = new ei().fromArray(I);
  function U(t, i, n, r) {
    let s = new Uint8Array(4),
      a = e.createTexture();
    e.bindTexture(t, a),
      e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
      e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
    for (let a = 0; a < n; a++)
      t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY
        ? e.texImage3D(i, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, s)
        : e.texImage2D(i + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s);
    return a;
  }
  let z = {};
  function F(t) {
    !0 !== a[t] && (e.enable(t), (a[t] = !0));
  }
  function B(t) {
    !1 !== a[t] && (e.disable(t), (a[t] = !1));
  }
  (z[e.TEXTURE_2D] = U(e.TEXTURE_2D, e.TEXTURE_2D, 1)),
    (z[e.TEXTURE_CUBE_MAP] = U(
      e.TEXTURE_CUBE_MAP,
      e.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (z[e.TEXTURE_2D_ARRAY] = U(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1)),
    (z[e.TEXTURE_3D] = U(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)),
    t.setClear(0, 0, 0, 1),
    i.setClear(1),
    n.setClear(0),
    F(e.DEPTH_TEST),
    i.setFunc(3),
    G(!1),
    W(1),
    F(e.CULL_FACE),
    V(0);
  let k = {
    100: e.FUNC_ADD,
    101: e.FUNC_SUBTRACT,
    102: e.FUNC_REVERSE_SUBTRACT,
  };
  (k[103] = e.MIN), (k[104] = e.MAX);
  let H = {
    200: e.ZERO,
    201: e.ONE,
    202: e.SRC_COLOR,
    204: e.SRC_ALPHA,
    210: e.SRC_ALPHA_SATURATE,
    208: e.DST_COLOR,
    206: e.DST_ALPHA,
    203: e.ONE_MINUS_SRC_COLOR,
    205: e.ONE_MINUS_SRC_ALPHA,
    209: e.ONE_MINUS_DST_COLOR,
    207: e.ONE_MINUS_DST_ALPHA,
    211: e.CONSTANT_COLOR,
    212: e.ONE_MINUS_CONSTANT_COLOR,
    213: e.CONSTANT_ALPHA,
    214: e.ONE_MINUS_CONSTANT_ALPHA,
  };
  function V(t, i, n, r, s, a, o, l, h, c) {
    if (0 === t) {
      !0 === u && (B(e.BLEND), (u = !1));
      return;
    }
    if ((!1 === u && (F(e.BLEND), (u = !0)), 5 !== t)) {
      if (t !== d || c !== M) {
        if (
          ((100 !== p || 100 !== g) &&
            (e.blendEquation(e.FUNC_ADD), (p = 100), (g = 100)),
          c)
        )
          switch (t) {
            case 1:
              e.blendFuncSeparate(
                e.ONE,
                e.ONE_MINUS_SRC_ALPHA,
                e.ONE,
                e.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 2:
              e.blendFunc(e.ONE, e.ONE);
              break;
            case 3:
              e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
              break;
            case 4:
              e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t);
          }
        else
          switch (t) {
            case 1:
              e.blendFuncSeparate(
                e.SRC_ALPHA,
                e.ONE_MINUS_SRC_ALPHA,
                e.ONE,
                e.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 2:
              e.blendFunc(e.SRC_ALPHA, e.ONE);
              break;
            case 3:
              e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
              break;
            case 4:
              e.blendFunc(e.ZERO, e.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t);
          }
        (m = null),
          (f = null),
          (_ = null),
          (v = null),
          x.set(0, 0, 0),
          (y = 0),
          (d = t),
          (M = c);
      }
      return;
    }
    (s = s || i),
      (a = a || n),
      (o = o || r),
      (i !== p || s !== g) &&
        (e.blendEquationSeparate(k[i], k[s]), (p = i), (g = s)),
      (n !== m || r !== f || a !== _ || o !== v) &&
        (e.blendFuncSeparate(H[n], H[r], H[a], H[o]),
        (m = n),
        (f = r),
        (_ = a),
        (v = o)),
      (!1 === l.equals(x) || h !== y) &&
        (e.blendColor(l.r, l.g, l.b, h), x.copy(l), (y = h)),
      (d = t),
      (M = !1);
  }
  function G(t) {
    S !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), (S = t));
  }
  function W(t) {
    0 !== t
      ? (F(e.CULL_FACE),
        t !== b &&
          (1 === t
            ? e.cullFace(e.BACK)
            : 2 === t
            ? e.cullFace(e.FRONT)
            : e.cullFace(e.FRONT_AND_BACK)))
      : B(e.CULL_FACE),
      (b = t);
  }
  function X(t, i, n) {
    t
      ? (F(e.POLYGON_OFFSET_FILL),
        (E !== i || w !== n) && (e.polygonOffset(i, n), (E = i), (w = n)))
      : B(e.POLYGON_OFFSET_FILL);
  }
  return {
    buffers: { color: t, depth: i, stencil: n },
    enable: F,
    disable: B,
    bindFramebuffer: function (t, i) {
      return (
        o[t] !== i &&
        (e.bindFramebuffer(t, i),
        (o[t] = i),
        t === e.DRAW_FRAMEBUFFER && (o[e.FRAMEBUFFER] = i),
        t === e.FRAMEBUFFER && (o[e.DRAW_FRAMEBUFFER] = i),
        !0)
      );
    },
    drawBuffers: function (t, i) {
      let n = h,
        r = !1;
      if (t) {
        void 0 === (n = l.get(i)) && ((n = []), l.set(i, n));
        let s = t.textures;
        if (n.length !== s.length || n[0] !== e.COLOR_ATTACHMENT0) {
          for (let t = 0, i = s.length; t < i; t++)
            n[t] = e.COLOR_ATTACHMENT0 + t;
          (n.length = s.length), (r = !0);
        }
      } else n[0] !== e.BACK && ((n[0] = e.BACK), (r = !0));
      r && e.drawBuffers(n);
    },
    useProgram: function (t) {
      return c !== t && (e.useProgram(t), (c = t), !0);
    },
    setBlending: V,
    setMaterial: function (r, s) {
      2 === r.side ? B(e.CULL_FACE) : F(e.CULL_FACE);
      let a = 1 === r.side;
      s && (a = !a),
        G(a),
        1 === r.blending && !1 === r.transparent
          ? V(0)
          : V(
              r.blending,
              r.blendEquation,
              r.blendSrc,
              r.blendDst,
              r.blendEquationAlpha,
              r.blendSrcAlpha,
              r.blendDstAlpha,
              r.blendColor,
              r.blendAlpha,
              r.premultipliedAlpha
            ),
        i.setFunc(r.depthFunc),
        i.setTest(r.depthTest),
        i.setMask(r.depthWrite),
        t.setMask(r.colorWrite);
      let o = r.stencilWrite;
      n.setTest(o),
        o &&
          (n.setMask(r.stencilWriteMask),
          n.setFunc(r.stencilFunc, r.stencilRef, r.stencilFuncMask),
          n.setOp(r.stencilFail, r.stencilZFail, r.stencilZPass)),
        X(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits),
        !0 === r.alphaToCoverage
          ? F(e.SAMPLE_ALPHA_TO_COVERAGE)
          : B(e.SAMPLE_ALPHA_TO_COVERAGE);
    },
    setFlipSided: G,
    setCullFace: W,
    setLineWidth: function (t) {
      t !== T && (R && e.lineWidth(t), (T = t));
    },
    setPolygonOffset: X,
    setScissorTest: function (t) {
      t ? F(e.SCISSOR_TEST) : B(e.SCISSOR_TEST);
    },
    activeTexture: function (t) {
      void 0 === t && (t = e.TEXTURE0 + A - 1),
        P !== t && (e.activeTexture(t), (P = t));
    },
    bindTexture: function (t, i, n) {
      void 0 === n && (n = null === P ? e.TEXTURE0 + A - 1 : P);
      let r = L[n];
      void 0 === r && ((r = { type: void 0, texture: void 0 }), (L[n] = r)),
        (r.type !== t || r.texture !== i) &&
          (P !== n && (e.activeTexture(n), (P = n)),
          e.bindTexture(t, i || z[t]),
          (r.type = t),
          (r.texture = i));
    },
    unbindTexture: function () {
      let t = L[P];
      void 0 !== t &&
        void 0 !== t.type &&
        (e.bindTexture(t.type, null), (t.type = void 0), (t.texture = void 0));
    },
    compressedTexImage2D: function () {
      try {
        e.compressedTexImage2D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    compressedTexImage3D: function () {
      try {
        e.compressedTexImage3D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    texImage2D: function () {
      try {
        e.texImage2D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    texImage3D: function () {
      try {
        e.texImage3D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    updateUBOMapping: function (t, i) {
      let n = s.get(i);
      void 0 === n && ((n = new WeakMap()), s.set(i, n));
      let r = n.get(t);
      void 0 === r && ((r = e.getUniformBlockIndex(i, t.name)), n.set(t, r));
    },
    uniformBlockBinding: function (t, i) {
      let n = s.get(i).get(t);
      r.get(i) !== n &&
        (e.uniformBlockBinding(i, n, t.__bindingPointIndex), r.set(i, n));
    },
    texStorage2D: function () {
      try {
        e.texStorage2D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    texStorage3D: function () {
      try {
        e.texStorage3D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    texSubImage2D: function () {
      try {
        e.texSubImage2D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    texSubImage3D: function () {
      try {
        e.texSubImage3D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    compressedTexSubImage2D: function () {
      try {
        e.compressedTexSubImage2D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    compressedTexSubImage3D: function () {
      try {
        e.compressedTexSubImage3D.apply(e, arguments);
      } catch (e) {
        console.error("THREE.WebGLState:", e);
      }
    },
    scissor: function (t) {
      !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), D.copy(t));
    },
    viewport: function (t) {
      !1 === O.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), O.copy(t));
    },
    reset: function () {
      e.disable(e.BLEND),
        e.disable(e.CULL_FACE),
        e.disable(e.DEPTH_TEST),
        e.disable(e.POLYGON_OFFSET_FILL),
        e.disable(e.SCISSOR_TEST),
        e.disable(e.STENCIL_TEST),
        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
        e.blendEquation(e.FUNC_ADD),
        e.blendFunc(e.ONE, e.ZERO),
        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
        e.blendColor(0, 0, 0, 0),
        e.colorMask(!0, !0, !0, !0),
        e.clearColor(0, 0, 0, 0),
        e.depthMask(!0),
        e.depthFunc(e.LESS),
        e.clearDepth(1),
        e.stencilMask(4294967295),
        e.stencilFunc(e.ALWAYS, 0, 4294967295),
        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
        e.clearStencil(0),
        e.cullFace(e.BACK),
        e.frontFace(e.CCW),
        e.polygonOffset(0, 0),
        e.activeTexture(e.TEXTURE0),
        e.bindFramebuffer(e.FRAMEBUFFER, null),
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
        e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
        e.useProgram(null),
        e.lineWidth(1),
        e.scissor(0, 0, e.canvas.width, e.canvas.height),
        e.viewport(0, 0, e.canvas.width, e.canvas.height),
        (a = {}),
        (P = null),
        (L = {}),
        (o = {}),
        (l = new WeakMap()),
        (h = []),
        (c = null),
        (u = !1),
        (d = null),
        (p = null),
        (m = null),
        (f = null),
        (g = null),
        (_ = null),
        (v = null),
        (x = new tx(0, 0, 0)),
        (y = 0),
        (M = !1),
        (S = null),
        (b = null),
        (T = null),
        (E = null),
        (w = null),
        D.set(0, 0, e.canvas.width, e.canvas.height),
        O.set(0, 0, e.canvas.width, e.canvas.height),
        t.reset(),
        i.reset(),
        n.reset();
    },
  };
}
function rg(e, t, i, n) {
  let r = (function (e) {
    switch (e) {
      case 1009:
      case 1010:
        return { byteLength: 1, components: 1 };
      case 1012:
      case 1011:
      case 1016:
        return { byteLength: 2, components: 1 };
      case 1017:
      case 1018:
        return { byteLength: 2, components: 4 };
      case 1014:
      case 1013:
      case 1015:
        return { byteLength: 4, components: 1 };
      case 35902:
        return { byteLength: 4, components: 3 };
    }
    throw Error(`Unknown texture type ${e}.`);
  })(n);
  switch (i) {
    case 1021:
    case 1024:
      return e * t;
    case 1025:
      return e * t * 2;
    case 1028:
    case 1029:
      return ((e * t) / r.components) * r.byteLength;
    case 1030:
    case 1031:
      return ((e * t * 2) / r.components) * r.byteLength;
    case 1022:
      return ((e * t * 3) / r.components) * r.byteLength;
    case 1023:
    case 1033:
      return ((e * t * 4) / r.components) * r.byteLength;
    case 33776:
    case 33777:
    case 36196:
    case 37492:
      return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case 33778:
    case 33779:
    case 37496:
    case 37808:
      return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case 35841:
    case 35843:
      return (Math.max(e, 16) * Math.max(t, 8)) / 4;
    case 35840:
    case 35842:
      return (Math.max(e, 8) * Math.max(t, 8)) / 2;
    case 37809:
      return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case 37810:
      return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case 37811:
      return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case 37812:
      return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case 37813:
      return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case 37814:
      return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case 37815:
      return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case 37816:
      return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case 37817:
      return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case 37818:
      return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case 37819:
      return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case 37820:
      return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case 37821:
      return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case 36492:
    case 36494:
    case 36495:
    case 36285:
    case 36286:
      return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
    case 36283:
    case 36284:
      return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
  }
  throw Error(`Unable to determine texture byte length for ${i} format.`);
}
function r_(e, t, i, n, r, s, a) {
  let o;
  let l = t.has("WEBGL_multisampled_render_to_texture")
      ? t.get("WEBGL_multisampled_render_to_texture")
      : null,
    h =
      "undefined" != typeof navigator &&
      /OculusBrowser/g.test(navigator.userAgent),
    c = new U(),
    u = new WeakMap(),
    d = new WeakMap(),
    p = !1;
  try {
    p =
      "undefined" != typeof OffscreenCanvas &&
      null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (e) {}
  function m(e, t) {
    return p ? new OffscreenCanvas(e, t) : k("canvas");
  }
  function f(e, t, i) {
    let n = 1,
      r = X(e);
    if (
      ((r.width > i || r.height > i) && (n = i / Math.max(r.width, r.height)),
      n < 1)
    ) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap) ||
        ("undefined" != typeof VideoFrame && e instanceof VideoFrame)
      ) {
        let i = Math.floor(n * r.width),
          s = Math.floor(n * r.height);
        void 0 === o && (o = m(i, s));
        let a = t ? m(i, s) : o;
        return (
          (a.width = i),
          (a.height = s),
          a.getContext("2d").drawImage(e, 0, 0, i, s),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              r.width +
              "x" +
              r.height +
              ") to (" +
              i +
              "x" +
              s +
              ")."
          ),
          a
        );
      }
      "data" in e &&
        console.warn(
          "THREE.WebGLRenderer: Image in DataTexture is too big (" +
            r.width +
            "x" +
            r.height +
            ")."
        );
    }
    return e;
  }
  function g(e) {
    return e.generateMipmaps && 1003 !== e.minFilter && 1006 !== e.minFilter;
  }
  function v(t) {
    e.generateMipmap(t);
  }
  function x(i, n, r, s, a = !1) {
    if (null !== i) {
      if (void 0 !== e[i]) return e[i];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          i +
          "'"
      );
    }
    let o = n;
    if (
      (n === e.RED &&
        (r === e.FLOAT && (o = e.R32F),
        r === e.HALF_FLOAT && (o = e.R16F),
        r === e.UNSIGNED_BYTE && (o = e.R8)),
      n === e.RED_INTEGER &&
        (r === e.UNSIGNED_BYTE && (o = e.R8UI),
        r === e.UNSIGNED_SHORT && (o = e.R16UI),
        r === e.UNSIGNED_INT && (o = e.R32UI),
        r === e.BYTE && (o = e.R8I),
        r === e.SHORT && (o = e.R16I),
        r === e.INT && (o = e.R32I)),
      n === e.RG &&
        (r === e.FLOAT && (o = e.RG32F),
        r === e.HALF_FLOAT && (o = e.RG16F),
        r === e.UNSIGNED_BYTE && (o = e.RG8)),
      n === e.RG_INTEGER &&
        (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
        r === e.UNSIGNED_SHORT && (o = e.RG16UI),
        r === e.UNSIGNED_INT && (o = e.RG32UI),
        r === e.BYTE && (o = e.RG8I),
        r === e.SHORT && (o = e.RG16I),
        r === e.INT && (o = e.RG32I)),
      n === e.RGB_INTEGER &&
        (r === e.UNSIGNED_BYTE && (o = e.RGB8UI),
        r === e.UNSIGNED_SHORT && (o = e.RGB16UI),
        r === e.UNSIGNED_INT && (o = e.RGB32UI),
        r === e.BYTE && (o = e.RGB8I),
        r === e.SHORT && (o = e.RGB16I),
        r === e.INT && (o = e.RGB32I)),
      n === e.RGBA_INTEGER &&
        (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI),
        r === e.UNSIGNED_SHORT && (o = e.RGBA16UI),
        r === e.UNSIGNED_INT && (o = e.RGBA32UI),
        r === e.BYTE && (o = e.RGBA8I),
        r === e.SHORT && (o = e.RGBA16I),
        r === e.INT && (o = e.RGBA32I)),
      n === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
      n === e.RGBA)
    ) {
      let t = a ? y : q.getTransfer(s);
      r === e.FLOAT && (o = e.RGBA32F),
        r === e.HALF_FLOAT && (o = e.RGBA16F),
        r === e.UNSIGNED_BYTE && (o = t === M ? e.SRGB8_ALPHA8 : e.RGBA8),
        r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
        r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1);
    }
    return (
      (o === e.R16F ||
        o === e.R32F ||
        o === e.RG16F ||
        o === e.RG32F ||
        o === e.RGBA16F ||
        o === e.RGBA32F) &&
        t.get("EXT_color_buffer_float"),
      o
    );
  }
  function S(t, i) {
    let n;
    return (
      t
        ? null === i || 1014 === i || 1020 === i
          ? (n = e.DEPTH24_STENCIL8)
          : 1015 === i
          ? (n = e.DEPTH32F_STENCIL8)
          : 1012 === i &&
            ((n = e.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : null === i || 1014 === i || 1020 === i
        ? (n = e.DEPTH_COMPONENT24)
        : 1015 === i
        ? (n = e.DEPTH_COMPONENT32F)
        : 1012 === i && (n = e.DEPTH_COMPONENT16),
      n
    );
  }
  function b(e, t) {
    return !0 === g(e) ||
      (e.isFramebufferTexture && 1003 !== e.minFilter && 1006 !== e.minFilter)
      ? Math.log2(Math.max(t.width, t.height)) + 1
      : void 0 !== e.mipmaps && e.mipmaps.length > 0
      ? e.mipmaps.length
      : e.isCompressedTexture && Array.isArray(e.image)
      ? t.mipmaps.length
      : 1;
  }
  function T(e) {
    let t = e.target;
    t.removeEventListener("dispose", T),
      (function (e) {
        let t = n.get(e);
        if (void 0 === t.__webglInit) return;
        let i = e.source,
          r = d.get(i);
        if (r) {
          let n = r[t.__cacheKey];
          n.usedTimes--,
            0 === n.usedTimes && w(e),
            0 === Object.keys(r).length && d.delete(i);
        }
        n.remove(e);
      })(t),
      t.isVideoTexture && u.delete(t);
  }
  function E(t) {
    let i = t.target;
    i.removeEventListener("dispose", E),
      (function (t) {
        let i = n.get(t);
        if (
          (t.depthTexture && t.depthTexture.dispose(),
          t.isWebGLCubeRenderTarget)
        )
          for (let t = 0; t < 6; t++) {
            if (Array.isArray(i.__webglFramebuffer[t]))
              for (let n = 0; n < i.__webglFramebuffer[t].length; n++)
                e.deleteFramebuffer(i.__webglFramebuffer[t][n]);
            else e.deleteFramebuffer(i.__webglFramebuffer[t]);
            i.__webglDepthbuffer &&
              e.deleteRenderbuffer(i.__webglDepthbuffer[t]);
          }
        else {
          if (Array.isArray(i.__webglFramebuffer))
            for (let t = 0; t < i.__webglFramebuffer.length; t++)
              e.deleteFramebuffer(i.__webglFramebuffer[t]);
          else e.deleteFramebuffer(i.__webglFramebuffer);
          if (
            (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer),
            i.__webglMultisampledFramebuffer &&
              e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
            i.__webglColorRenderbuffer)
          )
            for (let t = 0; t < i.__webglColorRenderbuffer.length; t++)
              i.__webglColorRenderbuffer[t] &&
                e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
          i.__webglDepthRenderbuffer &&
            e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
        }
        let r = t.textures;
        for (let t = 0, i = r.length; t < i; t++) {
          let i = n.get(r[t]);
          i.__webglTexture &&
            (e.deleteTexture(i.__webglTexture), a.memory.textures--),
            n.remove(r[t]);
        }
        n.remove(t);
      })(i);
  }
  function w(t) {
    let i = n.get(t);
    e.deleteTexture(i.__webglTexture);
    let r = t.source,
      s = d.get(r);
    delete s[i.__cacheKey], a.memory.textures--;
  }
  let A = 0;
  function R(t, r) {
    let s = n.get(t);
    if (
      (t.isVideoTexture &&
        (function (e) {
          let t = a.render.frame;
          u.get(e) !== t && (u.set(e, t), e.update());
        })(t),
      !1 === t.isRenderTargetTexture &&
        t.version > 0 &&
        s.__version !== t.version)
    ) {
      let e = t.image;
      if (null === e)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (!1 === e.complete)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        D(s, t, r);
        return;
      }
    }
    i.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r);
  }
  let C = { 1e3: e.REPEAT, 1001: e.CLAMP_TO_EDGE, 1002: e.MIRRORED_REPEAT },
    P = {
      1003: e.NEAREST,
      1004: e.NEAREST_MIPMAP_NEAREST,
      1005: e.NEAREST_MIPMAP_LINEAR,
      1006: e.LINEAR,
      1007: e.LINEAR_MIPMAP_NEAREST,
      1008: e.LINEAR_MIPMAP_LINEAR,
    },
    L = {
      512: e.NEVER,
      519: e.ALWAYS,
      513: e.LESS,
      515: e.LEQUAL,
      514: e.EQUAL,
      518: e.GEQUAL,
      516: e.GREATER,
      517: e.NOTEQUAL,
    };
  function N(i, s) {
    if (
      (1015 === s.type &&
        !1 === t.has("OES_texture_float_linear") &&
        (1006 === s.magFilter ||
          1007 === s.magFilter ||
          1005 === s.magFilter ||
          1008 === s.magFilter ||
          1006 === s.minFilter ||
          1007 === s.minFilter ||
          1005 === s.minFilter ||
          1008 === s.minFilter) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      e.texParameteri(i, e.TEXTURE_WRAP_S, C[s.wrapS]),
      e.texParameteri(i, e.TEXTURE_WRAP_T, C[s.wrapT]),
      (i === e.TEXTURE_3D || i === e.TEXTURE_2D_ARRAY) &&
        e.texParameteri(i, e.TEXTURE_WRAP_R, C[s.wrapR]),
      e.texParameteri(i, e.TEXTURE_MAG_FILTER, P[s.magFilter]),
      e.texParameteri(i, e.TEXTURE_MIN_FILTER, P[s.minFilter]),
      s.compareFunction &&
        (e.texParameteri(i, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
        e.texParameteri(i, e.TEXTURE_COMPARE_FUNC, L[s.compareFunction])),
      !0 === t.has("EXT_texture_filter_anisotropic") &&
        1003 !== s.magFilter &&
        (1005 === s.minFilter || 1008 === s.minFilter) &&
        (1015 !== s.type || !1 !== t.has("OES_texture_float_linear")) &&
        (s.anisotropy > 1 || n.get(s).__currentAnisotropy))
    ) {
      let a = t.get("EXT_texture_filter_anisotropic");
      e.texParameterf(
        i,
        a.TEXTURE_MAX_ANISOTROPY_EXT,
        Math.min(s.anisotropy, r.getMaxAnisotropy())
      ),
        (n.get(s).__currentAnisotropy = s.anisotropy);
    }
  }
  function I(t, i) {
    let n = !1;
    void 0 === t.__webglInit &&
      ((t.__webglInit = !0), i.addEventListener("dispose", T));
    let r = i.source,
      s = d.get(r);
    void 0 === s && ((s = {}), d.set(r, s));
    let o = (function (e) {
      let t = [];
      return (
        t.push(e.wrapS),
        t.push(e.wrapT),
        t.push(e.wrapR || 0),
        t.push(e.magFilter),
        t.push(e.minFilter),
        t.push(e.anisotropy),
        t.push(e.internalFormat),
        t.push(e.format),
        t.push(e.type),
        t.push(e.generateMipmaps),
        t.push(e.premultiplyAlpha),
        t.push(e.flipY),
        t.push(e.unpackAlignment),
        t.push(e.colorSpace),
        t.join()
      );
    })(i);
    if (o !== t.__cacheKey) {
      void 0 === s[o] &&
        ((s[o] = { texture: e.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (n = !0)),
        s[o].usedTimes++;
      let r = s[t.__cacheKey];
      void 0 !== r && (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && w(i)),
        (t.__cacheKey = o),
        (t.__webglTexture = s[o].texture);
    }
    return n;
  }
  function D(t, a, o) {
    let l = e.TEXTURE_2D;
    (a.isDataArrayTexture || a.isCompressedArrayTexture) &&
      (l = e.TEXTURE_2D_ARRAY),
      a.isData3DTexture && (l = e.TEXTURE_3D);
    let h = I(t, a),
      c = a.source;
    i.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
    let u = n.get(c);
    if (c.version !== u.__version || !0 === h) {
      let t;
      i.activeTexture(e.TEXTURE0 + o);
      let n = q.getPrimaries(q.workingColorSpace),
        d = "" === a.colorSpace ? null : q.getPrimaries(a.colorSpace),
        p = "" === a.colorSpace || n === d ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
      e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
        e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
      let m = f(a.image, !1, r.maxTextureSize);
      m = W(a, m);
      let _ = s.convert(a.format, a.colorSpace),
        y = s.convert(a.type),
        M = x(a.internalFormat, _, y, a.colorSpace, a.isVideoTexture);
      N(l, a);
      let T = a.mipmaps,
        E = !0 !== a.isVideoTexture,
        w = void 0 === u.__version || !0 === h,
        A = c.dataReady,
        R = b(a, m);
      if (a.isDepthTexture)
        (M = S(1027 === a.format, a.type)),
          w &&
            (E
              ? i.texStorage2D(e.TEXTURE_2D, 1, M, m.width, m.height)
              : i.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  M,
                  m.width,
                  m.height,
                  0,
                  _,
                  y,
                  null
                ));
      else if (a.isDataTexture) {
        if (T.length > 0) {
          E && w && i.texStorage2D(e.TEXTURE_2D, R, M, T[0].width, T[0].height);
          for (let n = 0, r = T.length; n < r; n++)
            (t = T[n]),
              E
                ? A &&
                  i.texSubImage2D(
                    e.TEXTURE_2D,
                    n,
                    0,
                    0,
                    t.width,
                    t.height,
                    _,
                    y,
                    t.data
                  )
                : i.texImage2D(
                    e.TEXTURE_2D,
                    n,
                    M,
                    t.width,
                    t.height,
                    0,
                    _,
                    y,
                    t.data
                  );
          a.generateMipmaps = !1;
        } else
          E
            ? (w && i.texStorage2D(e.TEXTURE_2D, R, M, m.width, m.height),
              A &&
                i.texSubImage2D(
                  e.TEXTURE_2D,
                  0,
                  0,
                  0,
                  m.width,
                  m.height,
                  _,
                  y,
                  m.data
                ))
            : i.texImage2D(
                e.TEXTURE_2D,
                0,
                M,
                m.width,
                m.height,
                0,
                _,
                y,
                m.data
              );
      } else if (a.isCompressedTexture) {
        if (a.isCompressedArrayTexture) {
          E &&
            w &&
            i.texStorage3D(
              e.TEXTURE_2D_ARRAY,
              R,
              M,
              T[0].width,
              T[0].height,
              m.depth
            );
          for (let n = 0, r = T.length; n < r; n++)
            if (((t = T[n]), 1023 !== a.format)) {
              if (null !== _) {
                if (E) {
                  if (A) {
                    if (a.layerUpdates.size > 0) {
                      let r = rg(t.width, t.height, a.format, a.type);
                      for (let s of a.layerUpdates) {
                        let a = t.data.subarray(
                          (s * r) / t.data.BYTES_PER_ELEMENT,
                          ((s + 1) * r) / t.data.BYTES_PER_ELEMENT
                        );
                        i.compressedTexSubImage3D(
                          e.TEXTURE_2D_ARRAY,
                          n,
                          0,
                          0,
                          s,
                          t.width,
                          t.height,
                          1,
                          _,
                          a,
                          0,
                          0
                        );
                      }
                      a.clearLayerUpdates();
                    } else
                      i.compressedTexSubImage3D(
                        e.TEXTURE_2D_ARRAY,
                        n,
                        0,
                        0,
                        0,
                        t.width,
                        t.height,
                        m.depth,
                        _,
                        t.data,
                        0,
                        0
                      );
                  }
                } else
                  i.compressedTexImage3D(
                    e.TEXTURE_2D_ARRAY,
                    n,
                    M,
                    t.width,
                    t.height,
                    m.depth,
                    0,
                    t.data,
                    0,
                    0
                  );
              } else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            } else
              E
                ? A &&
                  i.texSubImage3D(
                    e.TEXTURE_2D_ARRAY,
                    n,
                    0,
                    0,
                    0,
                    t.width,
                    t.height,
                    m.depth,
                    _,
                    y,
                    t.data
                  )
                : i.texImage3D(
                    e.TEXTURE_2D_ARRAY,
                    n,
                    M,
                    t.width,
                    t.height,
                    m.depth,
                    0,
                    _,
                    y,
                    t.data
                  );
        } else {
          E && w && i.texStorage2D(e.TEXTURE_2D, R, M, T[0].width, T[0].height);
          for (let n = 0, r = T.length; n < r; n++)
            (t = T[n]),
              1023 !== a.format
                ? null !== _
                  ? E
                    ? A &&
                      i.compressedTexSubImage2D(
                        e.TEXTURE_2D,
                        n,
                        0,
                        0,
                        t.width,
                        t.height,
                        _,
                        t.data
                      )
                    : i.compressedTexImage2D(
                        e.TEXTURE_2D,
                        n,
                        M,
                        t.width,
                        t.height,
                        0,
                        t.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : E
                ? A &&
                  i.texSubImage2D(
                    e.TEXTURE_2D,
                    n,
                    0,
                    0,
                    t.width,
                    t.height,
                    _,
                    y,
                    t.data
                  )
                : i.texImage2D(
                    e.TEXTURE_2D,
                    n,
                    M,
                    t.width,
                    t.height,
                    0,
                    _,
                    y,
                    t.data
                  );
        }
      } else if (a.isDataArrayTexture) {
        if (E) {
          if (
            (w &&
              i.texStorage3D(
                e.TEXTURE_2D_ARRAY,
                R,
                M,
                m.width,
                m.height,
                m.depth
              ),
            A)
          ) {
            if (a.layerUpdates.size > 0) {
              let t = rg(m.width, m.height, a.format, a.type);
              for (let n of a.layerUpdates) {
                let r = m.data.subarray(
                  (n * t) / m.data.BYTES_PER_ELEMENT,
                  ((n + 1) * t) / m.data.BYTES_PER_ELEMENT
                );
                i.texSubImage3D(
                  e.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  n,
                  m.width,
                  m.height,
                  1,
                  _,
                  y,
                  r
                );
              }
              a.clearLayerUpdates();
            } else
              i.texSubImage3D(
                e.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                m.width,
                m.height,
                m.depth,
                _,
                y,
                m.data
              );
          }
        } else
          i.texImage3D(
            e.TEXTURE_2D_ARRAY,
            0,
            M,
            m.width,
            m.height,
            m.depth,
            0,
            _,
            y,
            m.data
          );
      } else if (a.isData3DTexture)
        E
          ? (w &&
              i.texStorage3D(e.TEXTURE_3D, R, M, m.width, m.height, m.depth),
            A &&
              i.texSubImage3D(
                e.TEXTURE_3D,
                0,
                0,
                0,
                0,
                m.width,
                m.height,
                m.depth,
                _,
                y,
                m.data
              ))
          : i.texImage3D(
              e.TEXTURE_3D,
              0,
              M,
              m.width,
              m.height,
              m.depth,
              0,
              _,
              y,
              m.data
            );
      else if (a.isFramebufferTexture) {
        if (w) {
          if (E) i.texStorage2D(e.TEXTURE_2D, R, M, m.width, m.height);
          else {
            let t = m.width,
              n = m.height;
            for (let r = 0; r < R; r++)
              i.texImage2D(e.TEXTURE_2D, r, M, t, n, 0, _, y, null),
                (t >>= 1),
                (n >>= 1);
          }
        }
      } else if (T.length > 0) {
        if (E && w) {
          let t = X(T[0]);
          i.texStorage2D(e.TEXTURE_2D, R, M, t.width, t.height);
        }
        for (let n = 0, r = T.length; n < r; n++)
          (t = T[n]),
            E
              ? A && i.texSubImage2D(e.TEXTURE_2D, n, 0, 0, _, y, t)
              : i.texImage2D(e.TEXTURE_2D, n, M, _, y, t);
        a.generateMipmaps = !1;
      } else if (E) {
        if (w) {
          let t = X(m);
          i.texStorage2D(e.TEXTURE_2D, R, M, t.width, t.height);
        }
        A && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, _, y, m);
      } else i.texImage2D(e.TEXTURE_2D, 0, M, _, y, m);
      g(a) && v(l), (u.__version = c.version), a.onUpdate && a.onUpdate(a);
    }
    t.__version = a.version;
  }
  function O(t, r, a, o, h, c) {
    let u = s.convert(a.format, a.colorSpace),
      d = s.convert(a.type),
      p = x(a.internalFormat, u, d, a.colorSpace);
    if (!n.get(r).__hasExternalTextures) {
      let t = Math.max(1, r.width >> c),
        n = Math.max(1, r.height >> c);
      h === e.TEXTURE_3D || h === e.TEXTURE_2D_ARRAY
        ? i.texImage3D(h, c, p, t, n, r.depth, 0, u, d, null)
        : i.texImage2D(h, c, p, t, n, 0, u, d, null);
    }
    i.bindFramebuffer(e.FRAMEBUFFER, t),
      G(r)
        ? l.framebufferTexture2DMultisampleEXT(
            e.FRAMEBUFFER,
            o,
            h,
            n.get(a).__webglTexture,
            0,
            V(r)
          )
        : (h === e.TEXTURE_2D ||
            (h >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
              h <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          e.framebufferTexture2D(
            e.FRAMEBUFFER,
            o,
            h,
            n.get(a).__webglTexture,
            c
          ),
      i.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function z(t, i, n) {
    if ((e.bindRenderbuffer(e.RENDERBUFFER, t), i.depthBuffer)) {
      let r = i.depthTexture,
        s = r && r.isDepthTexture ? r.type : null,
        a = S(i.stencilBuffer, s),
        o = i.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
        h = V(i);
      G(i)
        ? l.renderbufferStorageMultisampleEXT(
            e.RENDERBUFFER,
            h,
            a,
            i.width,
            i.height
          )
        : n
        ? e.renderbufferStorageMultisample(
            e.RENDERBUFFER,
            h,
            a,
            i.width,
            i.height
          )
        : e.renderbufferStorage(e.RENDERBUFFER, a, i.width, i.height),
        e.framebufferRenderbuffer(e.FRAMEBUFFER, o, e.RENDERBUFFER, t);
    } else {
      let t = i.textures;
      for (let r = 0; r < t.length; r++) {
        let a = t[r],
          o = s.convert(a.format, a.colorSpace),
          h = s.convert(a.type),
          c = x(a.internalFormat, o, h, a.colorSpace),
          u = V(i);
        n && !1 === G(i)
          ? e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              u,
              c,
              i.width,
              i.height
            )
          : G(i)
          ? l.renderbufferStorageMultisampleEXT(
              e.RENDERBUFFER,
              u,
              c,
              i.width,
              i.height
            )
          : e.renderbufferStorage(e.RENDERBUFFER, c, i.width, i.height);
      }
    }
    e.bindRenderbuffer(e.RENDERBUFFER, null);
  }
  function F(t) {
    let r = n.get(t),
      s = !0 === t.isWebGLCubeRenderTarget;
    if (r.__boundDepthTexture !== t.depthTexture) {
      let e = t.depthTexture;
      if ((r.__depthDisposeCallback && r.__depthDisposeCallback(), e)) {
        let t = () => {
          delete r.__boundDepthTexture,
            delete r.__depthDisposeCallback,
            e.removeEventListener("dispose", t);
        };
        e.addEventListener("dispose", t), (r.__depthDisposeCallback = t);
      }
      r.__boundDepthTexture = e;
    }
    if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
      if (s)
        throw Error("target.depthTexture not supported in Cube render targets");
      !(function (t, r) {
        if (r && r.isWebGLCubeRenderTarget)
          throw Error(
            "Depth Texture with cube render targets is not supported"
          );
        if (
          (i.bindFramebuffer(e.FRAMEBUFFER, t),
          !(r.depthTexture && r.depthTexture.isDepthTexture))
        )
          throw Error(
            "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
          );
        (n.get(r.depthTexture).__webglTexture &&
          r.depthTexture.image.width === r.width &&
          r.depthTexture.image.height === r.height) ||
          ((r.depthTexture.image.width = r.width),
          (r.depthTexture.image.height = r.height),
          (r.depthTexture.needsUpdate = !0)),
          R(r.depthTexture, 0);
        let s = n.get(r.depthTexture).__webglTexture,
          a = V(r);
        if (1026 === r.depthTexture.format)
          G(r)
            ? l.framebufferTexture2DMultisampleEXT(
                e.FRAMEBUFFER,
                e.DEPTH_ATTACHMENT,
                e.TEXTURE_2D,
                s,
                0,
                a
              )
            : e.framebufferTexture2D(
                e.FRAMEBUFFER,
                e.DEPTH_ATTACHMENT,
                e.TEXTURE_2D,
                s,
                0
              );
        else if (1027 === r.depthTexture.format)
          G(r)
            ? l.framebufferTexture2DMultisampleEXT(
                e.FRAMEBUFFER,
                e.DEPTH_STENCIL_ATTACHMENT,
                e.TEXTURE_2D,
                s,
                0,
                a
              )
            : e.framebufferTexture2D(
                e.FRAMEBUFFER,
                e.DEPTH_STENCIL_ATTACHMENT,
                e.TEXTURE_2D,
                s,
                0
              );
        else throw Error("Unknown depthTexture format");
      })(r.__webglFramebuffer, t);
    } else if (s) {
      r.__webglDepthbuffer = [];
      for (let n = 0; n < 6; n++)
        if (
          (i.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[n]),
          void 0 === r.__webglDepthbuffer[n])
        )
          (r.__webglDepthbuffer[n] = e.createRenderbuffer()),
            z(r.__webglDepthbuffer[n], t, !1);
        else {
          let i = t.stencilBuffer
              ? e.DEPTH_STENCIL_ATTACHMENT
              : e.DEPTH_ATTACHMENT,
            s = r.__webglDepthbuffer[n];
          e.bindRenderbuffer(e.RENDERBUFFER, s),
            e.framebufferRenderbuffer(e.FRAMEBUFFER, i, e.RENDERBUFFER, s);
        }
    } else if (
      (i.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
      void 0 === r.__webglDepthbuffer)
    )
      (r.__webglDepthbuffer = e.createRenderbuffer()),
        z(r.__webglDepthbuffer, t, !1);
    else {
      let i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
        n = r.__webglDepthbuffer;
      e.bindRenderbuffer(e.RENDERBUFFER, n),
        e.framebufferRenderbuffer(e.FRAMEBUFFER, i, e.RENDERBUFFER, n);
    }
    i.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  let B = [],
    H = [];
  function V(e) {
    return Math.min(r.maxSamples, e.samples);
  }
  function G(e) {
    let i = n.get(e);
    return (
      e.samples > 0 &&
      !0 === t.has("WEBGL_multisampled_render_to_texture") &&
      !1 !== i.__useRenderToTexture
    );
  }
  function W(e, t) {
    let i = e.colorSpace,
      n = e.format,
      r = e.type;
    return (
      !0 === e.isCompressedTexture ||
        !0 === e.isVideoTexture ||
        (i !== _ &&
          "" !== i &&
          (q.getTransfer(i) === M
            ? (1023 !== n || 1009 !== r) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                i
              ))),
      t
    );
  }
  function X(e) {
    return (
      "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement
        ? ((c.width = e.naturalWidth || e.width),
          (c.height = e.naturalHeight || e.height))
        : "undefined" != typeof VideoFrame && e instanceof VideoFrame
        ? ((c.width = e.displayWidth), (c.height = e.displayHeight))
        : ((c.width = e.width), (c.height = e.height)),
      c
    );
  }
  (this.allocateTextureUnit = function () {
    let e = A;
    return (
      e >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            e +
            " texture units while this GPU supports only " +
            r.maxTextures
        ),
      (A += 1),
      e
    );
  }),
    (this.resetTextureUnits = function () {
      A = 0;
    }),
    (this.setTexture2D = R),
    (this.setTexture2DArray = function (t, r) {
      let s = n.get(t);
      if (t.version > 0 && s.__version !== t.version) {
        D(s, t, r);
        return;
      }
      i.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + r);
    }),
    (this.setTexture3D = function (t, r) {
      let s = n.get(t);
      if (t.version > 0 && s.__version !== t.version) {
        D(s, t, r);
        return;
      }
      i.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r);
    }),
    (this.setTextureCube = function (t, a) {
      let o = n.get(t);
      if (t.version > 0 && o.__version !== t.version) {
        (function (t, a, o) {
          if (6 !== a.image.length) return;
          let l = I(t, a),
            h = a.source;
          i.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
          let c = n.get(h);
          if (h.version !== c.__version || !0 === l) {
            let t;
            i.activeTexture(e.TEXTURE0 + o);
            let n = q.getPrimaries(q.workingColorSpace),
              u = "" === a.colorSpace ? null : q.getPrimaries(a.colorSpace),
              d =
                "" === a.colorSpace || n === u
                  ? e.NONE
                  : e.BROWSER_DEFAULT_WEBGL;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
              e.pixelStorei(
                e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                a.premultiplyAlpha
              ),
              e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
              e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
            let p = a.isCompressedTexture || a.image[0].isCompressedTexture,
              m = a.image[0] && a.image[0].isDataTexture,
              _ = [];
            for (let e = 0; e < 6; e++)
              p || m
                ? (_[e] = m ? a.image[e].image : a.image[e])
                : (_[e] = f(a.image[e], !0, r.maxCubemapSize)),
                (_[e] = W(a, _[e]));
            let y = _[0],
              M = s.convert(a.format, a.colorSpace),
              S = s.convert(a.type),
              T = x(a.internalFormat, M, S, a.colorSpace),
              E = !0 !== a.isVideoTexture,
              w = void 0 === c.__version || !0 === l,
              A = h.dataReady,
              R = b(a, y);
            if ((N(e.TEXTURE_CUBE_MAP, a), p)) {
              E &&
                w &&
                i.texStorage2D(e.TEXTURE_CUBE_MAP, R, T, y.width, y.height);
              for (let n = 0; n < 6; n++) {
                t = _[n].mipmaps;
                for (let r = 0; r < t.length; r++) {
                  let s = t[r];
                  1023 !== a.format
                    ? null !== M
                      ? E
                        ? A &&
                          i.compressedTexSubImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                            r,
                            0,
                            0,
                            s.width,
                            s.height,
                            M,
                            s.data
                          )
                        : i.compressedTexImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                            r,
                            T,
                            s.width,
                            s.height,
                            0,
                            s.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : E
                    ? A &&
                      i.texSubImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        r,
                        0,
                        0,
                        s.width,
                        s.height,
                        M,
                        S,
                        s.data
                      )
                    : i.texImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        r,
                        T,
                        s.width,
                        s.height,
                        0,
                        M,
                        S,
                        s.data
                      );
                }
              }
            } else {
              if (((t = a.mipmaps), E && w)) {
                t.length > 0 && R++;
                let n = X(_[0]);
                i.texStorage2D(e.TEXTURE_CUBE_MAP, R, T, n.width, n.height);
              }
              for (let n = 0; n < 6; n++)
                if (m) {
                  E
                    ? A &&
                      i.texSubImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        0,
                        0,
                        0,
                        _[n].width,
                        _[n].height,
                        M,
                        S,
                        _[n].data
                      )
                    : i.texImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        0,
                        T,
                        _[n].width,
                        _[n].height,
                        0,
                        M,
                        S,
                        _[n].data
                      );
                  for (let r = 0; r < t.length; r++) {
                    let s = t[r].image[n].image;
                    E
                      ? A &&
                        i.texSubImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                          r + 1,
                          0,
                          0,
                          s.width,
                          s.height,
                          M,
                          S,
                          s.data
                        )
                      : i.texImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                          r + 1,
                          T,
                          s.width,
                          s.height,
                          0,
                          M,
                          S,
                          s.data
                        );
                  }
                } else {
                  E
                    ? A &&
                      i.texSubImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        0,
                        0,
                        0,
                        M,
                        S,
                        _[n]
                      )
                    : i.texImage2D(
                        e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                        0,
                        T,
                        M,
                        S,
                        _[n]
                      );
                  for (let r = 0; r < t.length; r++) {
                    let s = t[r];
                    E
                      ? A &&
                        i.texSubImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                          r + 1,
                          0,
                          0,
                          M,
                          S,
                          s.image[n]
                        )
                      : i.texImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                          r + 1,
                          T,
                          M,
                          S,
                          s.image[n]
                        );
                  }
                }
            }
            g(a) && v(e.TEXTURE_CUBE_MAP),
              (c.__version = h.version),
              a.onUpdate && a.onUpdate(a);
          }
          t.__version = a.version;
        })(o, t, a);
        return;
      }
      i.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + a);
    }),
    (this.rebindTextures = function (t, i, r) {
      let s = n.get(t);
      void 0 !== i &&
        O(
          s.__webglFramebuffer,
          t,
          t.texture,
          e.COLOR_ATTACHMENT0,
          e.TEXTURE_2D,
          0
        ),
        void 0 !== r && F(t);
    }),
    (this.setupRenderTarget = function (t) {
      let r = t.texture,
        o = n.get(t),
        l = n.get(r);
      t.addEventListener("dispose", E);
      let h = t.textures,
        c = !0 === t.isWebGLCubeRenderTarget,
        u = h.length > 1;
      if (
        (!u &&
          (void 0 === l.__webglTexture &&
            (l.__webglTexture = e.createTexture()),
          (l.__version = r.version),
          a.memory.textures++),
        c)
      ) {
        o.__webglFramebuffer = [];
        for (let t = 0; t < 6; t++)
          if (r.mipmaps && r.mipmaps.length > 0) {
            o.__webglFramebuffer[t] = [];
            for (let i = 0; i < r.mipmaps.length; i++)
              o.__webglFramebuffer[t][i] = e.createFramebuffer();
          } else o.__webglFramebuffer[t] = e.createFramebuffer();
      } else {
        if (r.mipmaps && r.mipmaps.length > 0) {
          o.__webglFramebuffer = [];
          for (let t = 0; t < r.mipmaps.length; t++)
            o.__webglFramebuffer[t] = e.createFramebuffer();
        } else o.__webglFramebuffer = e.createFramebuffer();
        if (u)
          for (let t = 0, i = h.length; t < i; t++) {
            let i = n.get(h[t]);
            void 0 === i.__webglTexture &&
              ((i.__webglTexture = e.createTexture()), a.memory.textures++);
          }
        if (t.samples > 0 && !1 === G(t)) {
          (o.__webglMultisampledFramebuffer = e.createFramebuffer()),
            (o.__webglColorRenderbuffer = []),
            i.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
          for (let i = 0; i < h.length; i++) {
            let n = h[i];
            (o.__webglColorRenderbuffer[i] = e.createRenderbuffer()),
              e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[i]);
            let r = s.convert(n.format, n.colorSpace),
              a = s.convert(n.type),
              l = x(
                n.internalFormat,
                r,
                a,
                n.colorSpace,
                !0 === t.isXRRenderTarget
              ),
              c = V(t);
            e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              c,
              l,
              t.width,
              t.height
            ),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + i,
                e.RENDERBUFFER,
                o.__webglColorRenderbuffer[i]
              );
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null),
            t.depthBuffer &&
              ((o.__webglDepthRenderbuffer = e.createRenderbuffer()),
              z(o.__webglDepthRenderbuffer, t, !0)),
            i.bindFramebuffer(e.FRAMEBUFFER, null);
        }
      }
      if (c) {
        i.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
          N(e.TEXTURE_CUBE_MAP, r);
        for (let i = 0; i < 6; i++)
          if (r.mipmaps && r.mipmaps.length > 0)
            for (let n = 0; n < r.mipmaps.length; n++)
              O(
                o.__webglFramebuffer[i][n],
                t,
                r,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                n
              );
          else
            O(
              o.__webglFramebuffer[i],
              t,
              r,
              e.COLOR_ATTACHMENT0,
              e.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              0
            );
        g(r) && v(e.TEXTURE_CUBE_MAP), i.unbindTexture();
      } else if (u) {
        for (let r = 0, s = h.length; r < s; r++) {
          let s = h[r],
            a = n.get(s);
          i.bindTexture(e.TEXTURE_2D, a.__webglTexture),
            N(e.TEXTURE_2D, s),
            O(
              o.__webglFramebuffer,
              t,
              s,
              e.COLOR_ATTACHMENT0 + r,
              e.TEXTURE_2D,
              0
            ),
            g(s) && v(e.TEXTURE_2D);
        }
        i.unbindTexture();
      } else {
        let n = e.TEXTURE_2D;
        if (
          ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
            (n = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
          i.bindTexture(n, l.__webglTexture),
          N(n, r),
          r.mipmaps && r.mipmaps.length > 0)
        )
          for (let i = 0; i < r.mipmaps.length; i++)
            O(o.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, n, i);
        else O(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, n, 0);
        g(r) && v(n), i.unbindTexture();
      }
      t.depthBuffer && F(t);
    }),
    (this.updateRenderTargetMipmap = function (t) {
      let r = t.textures;
      for (let s = 0, a = r.length; s < a; s++) {
        let a = r[s];
        if (g(a)) {
          let r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
            s = n.get(a).__webglTexture;
          i.bindTexture(r, s), v(r), i.unbindTexture();
        }
      }
    }),
    (this.updateMultisampleRenderTarget = function (t) {
      if (t.samples > 0) {
        if (!1 === G(t)) {
          let r = t.textures,
            s = t.width,
            a = t.height,
            o = e.COLOR_BUFFER_BIT,
            l = t.stencilBuffer
              ? e.DEPTH_STENCIL_ATTACHMENT
              : e.DEPTH_ATTACHMENT,
            c = n.get(t),
            u = r.length > 1;
          if (u)
            for (let t = 0; t < r.length; t++)
              i.bindFramebuffer(
                e.FRAMEBUFFER,
                c.__webglMultisampledFramebuffer
              ),
                e.framebufferRenderbuffer(
                  e.FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.RENDERBUFFER,
                  null
                ),
                i.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer),
                e.framebufferTexture2D(
                  e.DRAW_FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.TEXTURE_2D,
                  null,
                  0
                );
          i.bindFramebuffer(
            e.READ_FRAMEBUFFER,
            c.__webglMultisampledFramebuffer
          ),
            i.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
          for (let i = 0; i < r.length; i++) {
            if (
              (t.resolveDepthBuffer &&
                (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                t.stencilBuffer &&
                  t.resolveStencilBuffer &&
                  (o |= e.STENCIL_BUFFER_BIT)),
              u)
            ) {
              e.framebufferRenderbuffer(
                e.READ_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0,
                e.RENDERBUFFER,
                c.__webglColorRenderbuffer[i]
              );
              let t = n.get(r[i]).__webglTexture;
              e.framebufferTexture2D(
                e.DRAW_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_2D,
                t,
                0
              );
            }
            e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST),
              !0 === h &&
                ((B.length = 0),
                (H.length = 0),
                B.push(e.COLOR_ATTACHMENT0 + i),
                t.depthBuffer &&
                  !1 === t.resolveDepthBuffer &&
                  (B.push(l),
                  H.push(l),
                  e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, H)),
                e.invalidateFramebuffer(e.READ_FRAMEBUFFER, B));
          }
          if (
            (i.bindFramebuffer(e.READ_FRAMEBUFFER, null),
            i.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
            u)
          )
            for (let t = 0; t < r.length; t++) {
              i.bindFramebuffer(
                e.FRAMEBUFFER,
                c.__webglMultisampledFramebuffer
              ),
                e.framebufferRenderbuffer(
                  e.FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.RENDERBUFFER,
                  c.__webglColorRenderbuffer[t]
                );
              let s = n.get(r[t]).__webglTexture;
              i.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer),
                e.framebufferTexture2D(
                  e.DRAW_FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.TEXTURE_2D,
                  s,
                  0
                );
            }
          i.bindFramebuffer(
            e.DRAW_FRAMEBUFFER,
            c.__webglMultisampledFramebuffer
          );
        } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && h) {
          let i = t.stencilBuffer
            ? e.DEPTH_STENCIL_ATTACHMENT
            : e.DEPTH_ATTACHMENT;
          e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [i]);
        }
      }
    }),
    (this.setupDepthRenderbuffer = F),
    (this.setupFrameBufferTexture = O),
    (this.useMultisampledRTT = G);
}
function rv(e, t) {
  return {
    convert: function (i, n = "") {
      let r;
      let s = q.getTransfer(n);
      if (1009 === i) return e.UNSIGNED_BYTE;
      if (1017 === i) return e.UNSIGNED_SHORT_4_4_4_4;
      if (1018 === i) return e.UNSIGNED_SHORT_5_5_5_1;
      if (35902 === i) return e.UNSIGNED_INT_5_9_9_9_REV;
      if (1010 === i) return e.BYTE;
      if (1011 === i) return e.SHORT;
      if (1012 === i) return e.UNSIGNED_SHORT;
      if (1013 === i) return e.INT;
      if (1014 === i) return e.UNSIGNED_INT;
      if (1015 === i) return e.FLOAT;
      if (1016 === i) return e.HALF_FLOAT;
      if (1021 === i) return e.ALPHA;
      if (1022 === i) return e.RGB;
      if (1023 === i) return e.RGBA;
      if (1024 === i) return e.LUMINANCE;
      if (1025 === i) return e.LUMINANCE_ALPHA;
      if (1026 === i) return e.DEPTH_COMPONENT;
      if (1027 === i) return e.DEPTH_STENCIL;
      if (1028 === i) return e.RED;
      if (1029 === i) return e.RED_INTEGER;
      if (1030 === i) return e.RG;
      if (1031 === i) return e.RG_INTEGER;
      if (1033 === i) return e.RGBA_INTEGER;
      if (33776 === i || 33777 === i || 33778 === i || 33779 === i) {
        if (s === M) {
          if (null === (r = t.get("WEBGL_compressed_texture_s3tc_srgb")))
            return null;
          if (33776 === i) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (33777 === i) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (33778 === i) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (33779 === i) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          if (null === (r = t.get("WEBGL_compressed_texture_s3tc")))
            return null;
          if (33776 === i) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (33777 === i) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (33778 === i) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (33779 === i) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      }
      if (35840 === i || 35841 === i || 35842 === i || 35843 === i) {
        if (null === (r = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
        if (35840 === i) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === i) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (35842 === i) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === i) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (36196 === i || 37492 === i || 37496 === i) {
        if (null === (r = t.get("WEBGL_compressed_texture_etc"))) return null;
        if (36196 === i || 37492 === i)
          return s === M ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (37496 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : r.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (
        37808 === i ||
        37809 === i ||
        37810 === i ||
        37811 === i ||
        37812 === i ||
        37813 === i ||
        37814 === i ||
        37815 === i ||
        37816 === i ||
        37817 === i ||
        37818 === i ||
        37819 === i ||
        37820 === i ||
        37821 === i
      ) {
        if (null === (r = t.get("WEBGL_compressed_texture_astc"))) return null;
        if (37808 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (37809 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (37810 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (37811 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (37812 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (37813 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (37814 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (37815 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (37816 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (37817 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (37818 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (37819 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (37820 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (37821 === i)
          return s === M
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      }
      if (36492 === i || 36494 === i || 36495 === i) {
        if (null === (r = t.get("EXT_texture_compression_bptc"))) return null;
        if (36492 === i)
          return s === M
            ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (36494 === i) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (36495 === i) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      }
      if (36283 === i || 36284 === i || 36285 === i || 36286 === i) {
        if (null === (r = t.get("EXT_texture_compression_rgtc"))) return null;
        if (36492 === i) return r.COMPRESSED_RED_RGTC1_EXT;
        if (36284 === i) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (36285 === i) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (36286 === i) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      }
      return 1020 === i ? e.UNSIGNED_INT_24_8 : void 0 !== e[i] ? e[i] : null;
    },
  };
}
class rx extends t7 {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ry extends te {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const rM = { type: "move" };
class rS {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      null === this._hand &&
        ((this._hand = new ry()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      null === this._targetRay &&
        ((this._targetRay = new ry()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new eo()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new eo())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      null === this._grip &&
        ((this._grip = new ry()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new eo()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new eo())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      null !== this._targetRay && this._targetRay.dispatchEvent(e),
      null !== this._grip && this._grip.dispatchEvent(e),
      null !== this._hand && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      let t = this._hand;
      if (t) for (let i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      null !== this._targetRay && (this._targetRay.visible = !1),
      null !== this._grip && (this._grip.visible = !1),
      null !== this._hand && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let n = null,
      r = null,
      s = null,
      a = this._targetRay,
      o = this._grip,
      l = this._hand;
    if (e && "visible-blurred" !== t.session.visibilityState) {
      if (l && e.hand) {
        for (let n of ((s = !0), e.hand.values())) {
          let e = t.getJointPose(n, i),
            r = this._getHandJoint(l, n);
          null !== e &&
            (r.matrix.fromArray(e.transform.matrix),
            r.matrix.decompose(r.position, r.rotation, r.scale),
            (r.matrixWorldNeedsUpdate = !0),
            (r.jointRadius = e.radius)),
            (r.visible = null !== e);
        }
        let n = l.joints["index-finger-tip"],
          r = l.joints["thumb-tip"],
          a = n.position.distanceTo(r.position);
        l.inputState.pinching && a > 0.025
          ? ((l.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !l.inputState.pinching &&
            a <= 0.015 &&
            ((l.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        null !== o &&
          e.gripSpace &&
          null !== (r = t.getPose(e.gripSpace, i)) &&
          (o.matrix.fromArray(r.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(r.linearVelocity))
            : (o.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(r.angularVelocity))
            : (o.hasAngularVelocity = !1));
      null !== a &&
        (null === (n = t.getPose(e.targetRaySpace, i)) && null !== r && (n = r),
        null !== n &&
          (a.matrix.fromArray(n.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          n.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(n.linearVelocity))
            : (a.hasLinearVelocity = !1),
          n.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(n.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(rM)));
    }
    return (
      null !== a && (a.visible = null !== n),
      null !== o && (o.visible = null !== r),
      null !== l && (l.visible = null !== s),
      this
    );
  }
  _getHandJoint(e, t) {
    if (void 0 === e.joints[t.jointName]) {
      let i = new ry();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
const rb = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  rT = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class rE {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, i) {
    if (null === this.texture) {
      let n = new et();
      (e.properties.get(n).__webglTexture = t.texture),
        (t.depthNear != i.depthNear || t.depthFar != i.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = n);
    }
  }
  getMesh(e) {
    if (null !== this.texture && null === this.mesh) {
      let t = e.cameras[0].viewport,
        i = new t2({
          vertexShader: rb,
          fragmentShader: rT,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new tY(new iu(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class rw extends T {
  constructor(e, t) {
    super();
    let i = this,
      n = null,
      r = 1,
      s = null,
      a = "local-floor",
      o = 1,
      l = null,
      h = null,
      c = null,
      u = null,
      d = null,
      p = null,
      m = new rE(),
      f = t.getContextAttributes(),
      g = null,
      _ = null,
      v = [],
      x = [],
      y = new U(),
      M = null,
      S = new t7();
    S.layers.enable(1), (S.viewport = new ei());
    let b = new t7();
    b.layers.enable(2), (b.viewport = new ei());
    let T = [S, b],
      E = new rx();
    E.layers.enable(1), E.layers.enable(2);
    let w = null,
      A = null;
    function C(e) {
      let t = x.indexOf(e.inputSource);
      if (-1 === t) return;
      let i = v[t];
      void 0 !== i &&
        (i.update(e.inputSource, e.frame, l || s),
        i.dispatchEvent({ type: e.type, data: e.inputSource }));
    }
    function P() {
      n.removeEventListener("select", C),
        n.removeEventListener("selectstart", C),
        n.removeEventListener("selectend", C),
        n.removeEventListener("squeeze", C),
        n.removeEventListener("squeezestart", C),
        n.removeEventListener("squeezeend", C),
        n.removeEventListener("end", P),
        n.removeEventListener("inputsourceschange", L);
      for (let e = 0; e < v.length; e++) {
        let t = x[e];
        null !== t && ((x[e] = null), v[e].disconnect(t));
      }
      (w = null),
        (A = null),
        m.reset(),
        e.setRenderTarget(g),
        (d = null),
        (u = null),
        (c = null),
        (n = null),
        (_ = null),
        z.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(M),
        e.setSize(y.width, y.height, !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    function L(e) {
      for (let t = 0; t < e.removed.length; t++) {
        let i = e.removed[t],
          n = x.indexOf(i);
        n >= 0 && ((x[n] = null), v[n].disconnect(i));
      }
      for (let t = 0; t < e.added.length; t++) {
        let i = e.added[t],
          n = x.indexOf(i);
        if (-1 === n) {
          for (let e = 0; e < v.length; e++) {
            if (e >= x.length) {
              x.push(i), (n = e);
              break;
            }
            if (null === x[e]) {
              (x[e] = i), (n = e);
              break;
            }
          }
          if (-1 === n) break;
        }
        let r = v[n];
        r && r.connect(i);
      }
    }
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (e) {
        let t = v[e];
        return (
          void 0 === t && ((t = new rS()), (v[e] = t)), t.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (e) {
        let t = v[e];
        return void 0 === t && ((t = new rS()), (v[e] = t)), t.getGripSpace();
      }),
      (this.getHand = function (e) {
        let t = v[e];
        return void 0 === t && ((t = new rS()), (v[e] = t)), t.getHandSpace();
      }),
      (this.setFramebufferScaleFactor = function (e) {
        (r = e),
          !0 === i.isPresenting &&
            console.warn(
              "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
            );
      }),
      (this.setReferenceSpaceType = function (e) {
        (a = e),
          !0 === i.isPresenting &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return l || s;
      }),
      (this.setReferenceSpace = function (e) {
        l = e;
      }),
      (this.getBaseLayer = function () {
        return null !== u ? u : d;
      }),
      (this.getBinding = function () {
        return c;
      }),
      (this.getFrame = function () {
        return p;
      }),
      (this.getSession = function () {
        return n;
      }),
      (this.setSession = async function (h) {
        if (null !== (n = h)) {
          if (
            ((g = e.getRenderTarget()),
            n.addEventListener("select", C),
            n.addEventListener("selectstart", C),
            n.addEventListener("selectend", C),
            n.addEventListener("squeeze", C),
            n.addEventListener("squeezestart", C),
            n.addEventListener("squeezeend", C),
            n.addEventListener("end", P),
            n.addEventListener("inputsourceschange", L),
            !0 !== f.xrCompatible && (await t.makeXRCompatible()),
            (M = e.getPixelRatio()),
            e.getSize(y),
            void 0 === n.renderState.layers)
          ) {
            let i = {
              antialias: f.antialias,
              alpha: !0,
              depth: f.depth,
              stencil: f.stencil,
              framebufferScaleFactor: r,
            };
            (d = new XRWebGLLayer(n, t, i)),
              n.updateRenderState({ baseLayer: d }),
              e.setPixelRatio(1),
              e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
              (_ = new er(d.framebufferWidth, d.framebufferHeight, {
                format: 1023,
                type: 1009,
                colorSpace: e.outputColorSpace,
                stencilBuffer: f.stencil,
              }));
          } else {
            let i = null,
              s = null,
              a = null;
            f.depth &&
              ((a = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (i = f.stencil ? 1027 : 1026),
              (s = f.stencil ? 1020 : 1014));
            let o = { colorFormat: t.RGBA8, depthFormat: a, scaleFactor: r };
            (u = (c = new XRWebGLBinding(n, t)).createProjectionLayer(o)),
              n.updateRenderState({ layers: [u] }),
              e.setPixelRatio(1),
              e.setSize(u.textureWidth, u.textureHeight, !1),
              (_ = new er(u.textureWidth, u.textureHeight, {
                format: 1023,
                type: 1009,
                depthTexture: new iY(
                  u.textureWidth,
                  u.textureHeight,
                  s,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  i
                ),
                stencilBuffer: f.stencil,
                colorSpace: e.outputColorSpace,
                samples: f.antialias ? 4 : 0,
                resolveDepthBuffer: !1 === u.ignoreDepthValues,
              }));
          }
          (_.isXRRenderTarget = !0),
            this.setFoveation(o),
            (l = null),
            (s = await n.requestReferenceSpace(a)),
            z.setContext(n),
            z.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (null !== n) return n.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return m.getDepthTexture();
      });
    let N = new eo(),
      I = new eo();
    function D(e, t) {
      null === t
        ? e.matrixWorld.copy(e.matrix)
        : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
        e.matrixWorldInverse.copy(e.matrixWorld).invert();
    }
    (this.updateCamera = function (e) {
      if (null === n) return;
      let t = e.near,
        i = e.far;
      null !== m.texture &&
        (m.depthNear > 0 && (t = m.depthNear),
        m.depthFar > 0 && (i = m.depthFar)),
        (E.near = b.near = S.near = t),
        (E.far = b.far = S.far = i),
        (w !== E.near || A !== E.far) &&
          (n.updateRenderState({ depthNear: E.near, depthFar: E.far }),
          (w = E.near),
          (A = E.far));
      let r = e.parent,
        s = E.cameras;
      D(E, r);
      for (let e = 0; e < s.length; e++) D(s[e], r);
      2 === s.length
        ? (function (e, t, i) {
            N.setFromMatrixPosition(t.matrixWorld),
              I.setFromMatrixPosition(i.matrixWorld);
            let n = N.distanceTo(I),
              r = t.projectionMatrix.elements,
              s = i.projectionMatrix.elements,
              a = r[14] / (r[10] - 1),
              o = r[14] / (r[10] + 1),
              l = (r[9] + 1) / r[5],
              h = (r[9] - 1) / r[5],
              c = (r[8] - 1) / r[0],
              u = (s[8] + 1) / s[0],
              d = n / (-c + u),
              p = -(d * c);
            if (
              (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
              e.translateX(p),
              e.translateZ(d),
              e.matrixWorld.compose(e.position, e.quaternion, e.scale),
              e.matrixWorldInverse.copy(e.matrixWorld).invert(),
              -1 === r[10])
            )
              e.projectionMatrix.copy(t.projectionMatrix),
                e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
            else {
              let t = a + d,
                i = o + d;
              e.projectionMatrix.makePerspective(
                a * c - p,
                a * u + (n - p),
                ((l * o) / i) * t,
                ((h * o) / i) * t,
                t,
                i
              ),
                e.projectionMatrixInverse.copy(e.projectionMatrix).invert();
            }
          })(E, S, b)
        : E.projectionMatrix.copy(S.projectionMatrix),
        null === r
          ? e.matrix.copy(E.matrixWorld)
          : (e.matrix.copy(r.matrixWorld),
            e.matrix.invert(),
            e.matrix.multiply(E.matrixWorld)),
        e.matrix.decompose(e.position, e.quaternion, e.scale),
        e.updateMatrixWorld(!0),
        e.projectionMatrix.copy(E.projectionMatrix),
        e.projectionMatrixInverse.copy(E.projectionMatrixInverse),
        e.isPerspectiveCamera &&
          ((e.fov = 2 * R * Math.atan(1 / e.projectionMatrix.elements[5])),
          (e.zoom = 1));
    }),
      (this.getCamera = function () {
        return E;
      }),
      (this.getFoveation = function () {
        if (null !== u || null !== d) return o;
      }),
      (this.setFoveation = function (e) {
        (o = e),
          null !== u && (u.fixedFoveation = e),
          null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e);
      }),
      (this.hasDepthSensing = function () {
        return null !== m.texture;
      }),
      (this.getDepthSensingMesh = function () {
        return m.getMesh(E);
      });
    let O = null,
      z = new ih();
    z.setAnimationLoop(function (t, r) {
      if (((h = r.getViewerPose(l || s)), (p = r), null !== h)) {
        let t = h.views;
        null !== d &&
          (e.setRenderTargetFramebuffer(_, d.framebuffer),
          e.setRenderTarget(_));
        let i = !1;
        t.length !== E.cameras.length && ((E.cameras.length = 0), (i = !0));
        for (let n = 0; n < t.length; n++) {
          let r = t[n],
            s = null;
          if (null !== d) s = d.getViewport(r);
          else {
            let t = c.getViewSubImage(u, r);
            (s = t.viewport),
              0 === n &&
                (e.setRenderTargetTextures(
                  _,
                  t.colorTexture,
                  u.ignoreDepthValues ? void 0 : t.depthStencilTexture
                ),
                e.setRenderTarget(_));
          }
          let a = T[n];
          void 0 === a &&
            ((a = new t7()).layers.enable(n),
            (a.viewport = new ei()),
            (T[n] = a)),
            a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.quaternion, a.scale),
            a.projectionMatrix.fromArray(r.projectionMatrix),
            a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
            a.viewport.set(s.x, s.y, s.width, s.height),
            0 === n &&
              (E.matrix.copy(a.matrix),
              E.matrix.decompose(E.position, E.quaternion, E.scale)),
            !0 === i && E.cameras.push(a);
        }
        let r = n.enabledFeatures;
        if (r && r.includes("depth-sensing")) {
          let i = c.getDepthInformation(t[0]);
          i && i.isValid && i.texture && m.init(e, i, n.renderState);
        }
      }
      for (let e = 0; e < v.length; e++) {
        let t = x[e],
          i = v[e];
        null !== t && void 0 !== i && i.update(t, r, l || s);
      }
      O && O(t, r),
        r.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: r }),
        (p = null);
    }),
      (this.setAnimationLoop = function (e) {
        O = e;
      }),
      (this.dispose = function () {});
  }
}
const rA = new eq(),
  rR = new ez();
function rC(e, t) {
  function i(e, t) {
    !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix);
  }
  function n(e, n) {
    (e.opacity.value = n.opacity),
      n.color && e.diffuse.value.copy(n.color),
      n.emissive &&
        e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
      n.map && ((e.map.value = n.map), i(n.map, e.mapTransform)),
      n.alphaMap &&
        ((e.alphaMap.value = n.alphaMap), i(n.alphaMap, e.alphaMapTransform)),
      n.bumpMap &&
        ((e.bumpMap.value = n.bumpMap),
        i(n.bumpMap, e.bumpMapTransform),
        (e.bumpScale.value = n.bumpScale),
        1 === n.side && (e.bumpScale.value *= -1)),
      n.normalMap &&
        ((e.normalMap.value = n.normalMap),
        i(n.normalMap, e.normalMapTransform),
        e.normalScale.value.copy(n.normalScale),
        1 === n.side && e.normalScale.value.negate()),
      n.displacementMap &&
        ((e.displacementMap.value = n.displacementMap),
        i(n.displacementMap, e.displacementMapTransform),
        (e.displacementScale.value = n.displacementScale),
        (e.displacementBias.value = n.displacementBias)),
      n.emissiveMap &&
        ((e.emissiveMap.value = n.emissiveMap),
        i(n.emissiveMap, e.emissiveMapTransform)),
      n.specularMap &&
        ((e.specularMap.value = n.specularMap),
        i(n.specularMap, e.specularMapTransform)),
      n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
    let r = t.get(n),
      s = r.envMap,
      a = r.envMapRotation;
    s &&
      ((e.envMap.value = s),
      rA.copy(a),
      (rA.x *= -1),
      (rA.y *= -1),
      (rA.z *= -1),
      s.isCubeTexture &&
        !1 === s.isRenderTargetTexture &&
        ((rA.y *= -1), (rA.z *= -1)),
      e.envMapRotation.value.setFromMatrix4(rR.makeRotationFromEuler(rA)),
      (e.flipEnvMap.value =
        s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
      (e.reflectivity.value = n.reflectivity),
      (e.ior.value = n.ior),
      (e.refractionRatio.value = n.refractionRatio)),
      n.lightMap &&
        ((e.lightMap.value = n.lightMap),
        (e.lightMapIntensity.value = n.lightMapIntensity),
        i(n.lightMap, e.lightMapTransform)),
      n.aoMap &&
        ((e.aoMap.value = n.aoMap),
        (e.aoMapIntensity.value = n.aoMapIntensity),
        i(n.aoMap, e.aoMapTransform));
  }
  return {
    refreshFogUniforms: function (t, i) {
      i.color.getRGB(t.fogColor.value, t0(e)),
        i.isFog
          ? ((t.fogNear.value = i.near), (t.fogFar.value = i.far))
          : i.isFogExp2 && (t.fogDensity.value = i.density);
    },
    refreshMaterialUniforms: function (e, r, s, a, o) {
      r.isMeshBasicMaterial
        ? n(e, r)
        : r.isMeshLambertMaterial
        ? n(e, r)
        : r.isMeshToonMaterial
        ? (n(e, r), r.gradientMap && (e.gradientMap.value = r.gradientMap))
        : r.isMeshPhongMaterial
        ? (n(e, r),
          e.specular.value.copy(r.specular),
          (e.shininess.value = Math.max(r.shininess, 1e-4)))
        : r.isMeshStandardMaterial
        ? (n(e, r),
          (e.metalness.value = r.metalness),
          r.metalnessMap &&
            ((e.metalnessMap.value = r.metalnessMap),
            i(r.metalnessMap, e.metalnessMapTransform)),
          (e.roughness.value = r.roughness),
          r.roughnessMap &&
            ((e.roughnessMap.value = r.roughnessMap),
            i(r.roughnessMap, e.roughnessMapTransform)),
          r.envMap && (e.envMapIntensity.value = r.envMapIntensity),
          r.isMeshPhysicalMaterial &&
            ((e.ior.value = r.ior),
            r.sheen > 0 &&
              (e.sheenColor.value.copy(r.sheenColor).multiplyScalar(r.sheen),
              (e.sheenRoughness.value = r.sheenRoughness),
              r.sheenColorMap &&
                ((e.sheenColorMap.value = r.sheenColorMap),
                i(r.sheenColorMap, e.sheenColorMapTransform)),
              r.sheenRoughnessMap &&
                ((e.sheenRoughnessMap.value = r.sheenRoughnessMap),
                i(r.sheenRoughnessMap, e.sheenRoughnessMapTransform))),
            r.clearcoat > 0 &&
              ((e.clearcoat.value = r.clearcoat),
              (e.clearcoatRoughness.value = r.clearcoatRoughness),
              r.clearcoatMap &&
                ((e.clearcoatMap.value = r.clearcoatMap),
                i(r.clearcoatMap, e.clearcoatMapTransform)),
              r.clearcoatRoughnessMap &&
                ((e.clearcoatRoughnessMap.value = r.clearcoatRoughnessMap),
                i(r.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
              r.clearcoatNormalMap &&
                ((e.clearcoatNormalMap.value = r.clearcoatNormalMap),
                i(r.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                e.clearcoatNormalScale.value.copy(r.clearcoatNormalScale),
                1 === r.side && e.clearcoatNormalScale.value.negate())),
            r.dispersion > 0 && (e.dispersion.value = r.dispersion),
            r.iridescence > 0 &&
              ((e.iridescence.value = r.iridescence),
              (e.iridescenceIOR.value = r.iridescenceIOR),
              (e.iridescenceThicknessMinimum.value =
                r.iridescenceThicknessRange[0]),
              (e.iridescenceThicknessMaximum.value =
                r.iridescenceThicknessRange[1]),
              r.iridescenceMap &&
                ((e.iridescenceMap.value = r.iridescenceMap),
                i(r.iridescenceMap, e.iridescenceMapTransform)),
              r.iridescenceThicknessMap &&
                ((e.iridescenceThicknessMap.value = r.iridescenceThicknessMap),
                i(
                  r.iridescenceThicknessMap,
                  e.iridescenceThicknessMapTransform
                ))),
            r.transmission > 0 &&
              ((e.transmission.value = r.transmission),
              (e.transmissionSamplerMap.value = o.texture),
              e.transmissionSamplerSize.value.set(o.width, o.height),
              r.transmissionMap &&
                ((e.transmissionMap.value = r.transmissionMap),
                i(r.transmissionMap, e.transmissionMapTransform)),
              (e.thickness.value = r.thickness),
              r.thicknessMap &&
                ((e.thicknessMap.value = r.thicknessMap),
                i(r.thicknessMap, e.thicknessMapTransform)),
              (e.attenuationDistance.value = r.attenuationDistance),
              e.attenuationColor.value.copy(r.attenuationColor)),
            r.anisotropy > 0 &&
              (e.anisotropyVector.value.set(
                r.anisotropy * Math.cos(r.anisotropyRotation),
                r.anisotropy * Math.sin(r.anisotropyRotation)
              ),
              r.anisotropyMap &&
                ((e.anisotropyMap.value = r.anisotropyMap),
                i(r.anisotropyMap, e.anisotropyMapTransform))),
            (e.specularIntensity.value = r.specularIntensity),
            e.specularColor.value.copy(r.specularColor),
            r.specularColorMap &&
              ((e.specularColorMap.value = r.specularColorMap),
              i(r.specularColorMap, e.specularColorMapTransform)),
            r.specularIntensityMap &&
              ((e.specularIntensityMap.value = r.specularIntensityMap),
              i(r.specularIntensityMap, e.specularIntensityMapTransform))))
        : r.isMeshMatcapMaterial
        ? (n(e, r), r.matcap && (e.matcap.value = r.matcap))
        : r.isMeshDepthMaterial
        ? n(e, r)
        : r.isMeshDistanceMaterial
        ? (n(e, r),
          (function (e, i) {
            let n = t.get(i).light;
            e.referencePosition.value.setFromMatrixPosition(n.matrixWorld),
              (e.nearDistance.value = n.shadow.camera.near),
              (e.farDistance.value = n.shadow.camera.far);
          })(e, r))
        : r.isMeshNormalMaterial
        ? n(e, r)
        : r.isLineBasicMaterial
        ? (e.diffuse.value.copy(r.color),
          (e.opacity.value = r.opacity),
          r.map && ((e.map.value = r.map), i(r.map, e.mapTransform)),
          r.isLineDashedMaterial &&
            ((e.dashSize.value = r.dashSize),
            (e.totalSize.value = r.dashSize + r.gapSize),
            (e.scale.value = r.scale)))
        : r.isPointsMaterial
        ? (e.diffuse.value.copy(r.color),
          (e.opacity.value = r.opacity),
          (e.size.value = r.size * s),
          (e.scale.value = 0.5 * a),
          r.map && ((e.map.value = r.map), i(r.map, e.uvTransform)),
          r.alphaMap &&
            ((e.alphaMap.value = r.alphaMap),
            i(r.alphaMap, e.alphaMapTransform)),
          r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest))
        : r.isSpriteMaterial
        ? (e.diffuse.value.copy(r.color),
          (e.opacity.value = r.opacity),
          (e.rotation.value = r.rotation),
          r.map && ((e.map.value = r.map), i(r.map, e.mapTransform)),
          r.alphaMap &&
            ((e.alphaMap.value = r.alphaMap),
            i(r.alphaMap, e.alphaMapTransform)),
          r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest))
        : r.isShadowMaterial
        ? (e.color.value.copy(r.color), (e.opacity.value = r.opacity))
        : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
    },
  };
}
function rP(e, t, i, n) {
  let r = {},
    s = {},
    a = [],
    o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(e) {
    let t = { boundary: 0, storage: 0 };
    return (
      "number" == typeof e || "boolean" == typeof e
        ? ((t.boundary = 4), (t.storage = 4))
        : e.isVector2
        ? ((t.boundary = 8), (t.storage = 8))
        : e.isVector3 || e.isColor
        ? ((t.boundary = 16), (t.storage = 12))
        : e.isVector4
        ? ((t.boundary = 16), (t.storage = 16))
        : e.isMatrix3
        ? ((t.boundary = 48), (t.storage = 48))
        : e.isMatrix4
        ? ((t.boundary = 64), (t.storage = 64))
        : e.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            e
          ),
      t
    );
  }
  function h(t) {
    let i = t.target;
    i.removeEventListener("dispose", h);
    let n = a.indexOf(i.__bindingPointIndex);
    a.splice(n, 1), e.deleteBuffer(r[i.id]), delete r[i.id], delete s[i.id];
  }
  return {
    bind: function (e, t) {
      let i = t.program;
      n.uniformBlockBinding(e, i);
    },
    update: function (i, c) {
      let u = r[i.id];
      void 0 === u &&
        ((function (e) {
          let t = e.uniforms,
            i = 0;
          for (let e = 0, n = t.length; e < n; e++) {
            let n = Array.isArray(t[e]) ? t[e] : [t[e]];
            for (let e = 0, t = n.length; e < t; e++) {
              let t = n[e],
                r = Array.isArray(t.value) ? t.value : [t.value];
              for (let e = 0, n = r.length; e < n; e++) {
                let n = l(r[e]),
                  s = i % 16,
                  a = s % n.boundary,
                  o = s + a;
                (i += a),
                  0 !== o && 16 - o < n.storage && (i += 16 - o),
                  (t.__data = new Float32Array(
                    n.storage / Float32Array.BYTES_PER_ELEMENT
                  )),
                  (t.__offset = i),
                  (i += n.storage);
              }
            }
          }
          let n = i % 16;
          n > 0 && (i += 16 - n), (e.__size = i), (e.__cache = {});
        })(i),
        (u = (function (t) {
          let i = (function () {
            for (let e = 0; e < o; e++)
              if (-1 === a.indexOf(e)) return a.push(e), e;
            return (
              console.error(
                "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
              ),
              0
            );
          })();
          t.__bindingPointIndex = i;
          let n = e.createBuffer(),
            r = t.__size,
            s = t.usage;
          return (
            e.bindBuffer(e.UNIFORM_BUFFER, n),
            e.bufferData(e.UNIFORM_BUFFER, r, s),
            e.bindBuffer(e.UNIFORM_BUFFER, null),
            e.bindBufferBase(e.UNIFORM_BUFFER, i, n),
            n
          );
        })(i)),
        (r[i.id] = u),
        i.addEventListener("dispose", h));
      let d = c.program;
      n.updateUBOMapping(i, d);
      let p = t.render.frame;
      s[i.id] !== p &&
        ((function (t) {
          let i = r[t.id],
            n = t.uniforms,
            s = t.__cache;
          e.bindBuffer(e.UNIFORM_BUFFER, i);
          for (let t = 0, i = n.length; t < i; t++) {
            let i = Array.isArray(n[t]) ? n[t] : [n[t]];
            for (let n = 0, r = i.length; n < r; n++) {
              let r = i[n];
              if (
                !0 ===
                (function (e, t, i, n) {
                  let r = e.value,
                    s = t + "_" + i;
                  if (void 0 === n[s])
                    return (
                      "number" == typeof r || "boolean" == typeof r
                        ? (n[s] = r)
                        : (n[s] = r.clone()),
                      !0
                    );
                  {
                    let e = n[s];
                    if ("number" == typeof r || "boolean" == typeof r) {
                      if (e !== r) return (n[s] = r), !0;
                    } else if (!1 === e.equals(r)) return e.copy(r), !0;
                  }
                  return !1;
                })(r, t, n, s)
              ) {
                let t = r.__offset,
                  i = Array.isArray(r.value) ? r.value : [r.value],
                  n = 0;
                for (let s = 0; s < i.length; s++) {
                  let a = i[s],
                    o = l(a);
                  "number" == typeof a || "boolean" == typeof a
                    ? ((r.__data[0] = a),
                      e.bufferSubData(e.UNIFORM_BUFFER, t + n, r.__data))
                    : a.isMatrix3
                    ? ((r.__data[0] = a.elements[0]),
                      (r.__data[1] = a.elements[1]),
                      (r.__data[2] = a.elements[2]),
                      (r.__data[3] = 0),
                      (r.__data[4] = a.elements[3]),
                      (r.__data[5] = a.elements[4]),
                      (r.__data[6] = a.elements[5]),
                      (r.__data[7] = 0),
                      (r.__data[8] = a.elements[6]),
                      (r.__data[9] = a.elements[7]),
                      (r.__data[10] = a.elements[8]),
                      (r.__data[11] = 0))
                    : (a.toArray(r.__data, n),
                      (n += o.storage / Float32Array.BYTES_PER_ELEMENT));
                }
                e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data);
              }
            }
          }
          e.bindBuffer(e.UNIFORM_BUFFER, null);
        })(i),
        (s[i.id] = p));
    },
    dispose: function () {
      for (let t in r) e.deleteBuffer(r[t]);
      (a = []), (r = {}), (s = {});
    },
  };
}
class rL {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.usage = 35044),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = C());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let n = 0, r = this.stride; n < r; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = C()),
      void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = C()),
      void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const rN = new eo();
class rI {
  constructor(e, t, i, n = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = n);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      rN.fromBufferAttribute(this, t),
        rN.applyMatrix4(e),
        this.setXYZ(t, rN.x, rN.y, rN.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      rN.fromBufferAttribute(this, t),
        rN.applyNormalMatrix(e),
        this.setXYZ(t, rN.x, rN.y, rN.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      rN.fromBufferAttribute(this, t),
        rN.transformDirection(e),
        this.setXYZ(t, rN.x, rN.y, rN.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = I(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = D(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = D(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = I(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = I(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = I(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = I(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = D(t, this.array)), (i = D(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = D(t, this.array)),
        (i = D(i, this.array)),
        (n = D(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = n),
      this
    );
  }
  setXYZW(e, t, i, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = D(t, this.array)),
        (i = D(i, this.array)),
        (n = D(n, this.array)),
        (r = D(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = n),
      (this.data.array[e + 3] = r),
      this
    );
  }
  clone(e) {
    if (void 0 !== e)
      return (
        void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
        void 0 === e.interleavedBuffers[this.data.uuid] &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new rI(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
    {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      let e = [];
      for (let t = 0; t < this.count; t++) {
        let i = t * this.data.stride + this.offset;
        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t]);
      }
      return new tw(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized
      );
    }
  }
  toJSON(e) {
    if (void 0 !== e)
      return (
        void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
        void 0 === e.interleavedBuffers[this.data.uuid] &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      let e = [];
      for (let t = 0; t < this.count; t++) {
        let i = t * this.data.stride + this.offset;
        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      };
    }
  }
}
const rD = new eo(),
  rO = new ei(),
  rU = new ei(),
  rz = new eo(),
  rF = new ez(),
  rB = new eo(),
  rk = new eR(),
  rH = new ez(),
  rV = new eU();
class rG extends tY {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = f),
      (this.bindMatrix = new ez()),
      (this.bindMatrixInverse = new ez()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    let e = this.geometry;
    null === this.boundingBox && (this.boundingBox = new ec()),
      this.boundingBox.makeEmpty();
    let t = e.getAttribute("position");
    for (let e = 0; e < t.count; e++)
      this.getVertexPosition(e, rB), this.boundingBox.expandByPoint(rB);
  }
  computeBoundingSphere() {
    let e = this.geometry;
    null === this.boundingSphere && (this.boundingSphere = new eR()),
      this.boundingSphere.makeEmpty();
    let t = e.getAttribute("position");
    for (let e = 0; e < t.count; e++)
      this.getVertexPosition(e, rB), this.boundingSphere.expandByPoint(rB);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
      null !== e.boundingSphere &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    let i = this.material,
      n = this.matrixWorld;
    if (
      void 0 !== i &&
      (null === this.boundingSphere && this.computeBoundingSphere(),
      rk.copy(this.boundingSphere),
      rk.applyMatrix4(n),
      !1 !== e.ray.intersectsSphere(rk))
    ) {
      if (
        (rH.copy(n).invert(),
        rV.copy(e.ray).applyMatrix4(rH),
        null !== this.boundingBox && !1 === rV.intersectsBox(this.boundingBox))
      )
        return;
      this._computeIntersections(e, t, rV);
    }
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      void 0 === t &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    let e = new ei(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.fromBufferAttribute(t, i);
      let n = 1 / e.manhattanLength();
      n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === f
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : "detached" === this.bindMode
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    let i = this.skeleton,
      n = this.geometry;
    rO.fromBufferAttribute(n.attributes.skinIndex, e),
      rU.fromBufferAttribute(n.attributes.skinWeight, e),
      rD.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let e = 0; e < 4; e++) {
      let n = rU.getComponent(e);
      if (0 !== n) {
        let r = rO.getComponent(e);
        rF.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
          t.addScaledVector(rz.copy(rD).applyMatrix4(rF), n);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class rW extends te {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class rX extends et {
  constructor(e = null, t = 1, i = 1, n, r, s, a, o, l = 1003, h = 1003, c, u) {
    super(null, s, a, o, l, h, n, r, c, u),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const rj = new ez(),
  rq = new ez();
class rJ {
  constructor(e = [], t = []) {
    (this.uuid = C()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    let e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(16 * e.length)), 0 === t.length))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let e = 0, t = this.bones.length; e < t; e++)
        this.boneInverses.push(new ez());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      let t = new ez();
      this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(t);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      let t = this.bones[e];
      t && t.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      let t = this.bones[e];
      t &&
        (t.parent && t.parent.isBone
          ? (t.matrix.copy(t.parent.matrixWorld).invert(),
            t.matrix.multiply(t.matrixWorld))
          : t.matrix.copy(t.matrixWorld),
        t.matrix.decompose(t.position, t.quaternion, t.scale));
    }
  }
  update() {
    let e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      n = this.boneTexture;
    for (let n = 0, r = e.length; n < r; n++) {
      let r = e[n] ? e[n].matrixWorld : rq;
      rj.multiplyMatrices(r, t[n]), rj.toArray(i, 16 * n);
    }
    null !== n && (n.needsUpdate = !0);
  }
  clone() {
    return new rJ(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(4 * this.bones.length);
    e = Math.max((e = 4 * Math.ceil(e / 4)), 4);
    let t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    let i = new rX(t, e, e, 1023, 1015);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      let i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    null !== this.boneTexture &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      let n = e.bones[i],
        r = t[n];
      void 0 === r &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", n),
        (r = new rW())),
        this.bones.push(r),
        this.boneInverses.push(new ez().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    let e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    let t = this.bones,
      i = this.boneInverses;
    for (let n = 0, r = t.length; n < r; n++) {
      let r = t[n];
      e.bones.push(r.uuid);
      let s = i[n];
      e.boneInverses.push(s.toArray());
    }
    return e;
  }
}
class rY extends tw {
  constructor(e, t, i, n = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const rK = new ez(),
  rZ = new ez(),
  rQ = [],
  r$ = new ec(),
  r0 = new ez(),
  r1 = new tY(),
  r2 = new eR();
class r3 extends tY {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new rY(new Float32Array(16 * i), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let e = 0; e < i; e++) this.setMatrixAt(e, r0);
  }
  computeBoundingBox() {
    let e = this.geometry,
      t = this.count;
    null === this.boundingBox && (this.boundingBox = new ec()),
      null === e.boundingBox && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, rK),
        r$.copy(e.boundingBox).applyMatrix4(rK),
        this.boundingBox.union(r$);
  }
  computeBoundingSphere() {
    let e = this.geometry,
      t = this.count;
    null === this.boundingSphere && (this.boundingSphere = new eR()),
      null === e.boundingSphere && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, rK),
        r2.copy(e.boundingSphere).applyMatrix4(rK),
        this.boundingSphere.union(r2);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()),
      null !== e.instanceColor &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
      null !== e.boundingSphere &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, 3 * e);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  getMorphAt(e, t) {
    let i = t.morphTargetInfluences,
      n = this.morphTexture.source.data.data,
      r = e * (i.length + 1) + 1;
    for (let e = 0; e < i.length; e++) i[e] = n[r + e];
  }
  raycast(e, t) {
    let i = this.matrixWorld,
      n = this.count;
    if (
      ((r1.geometry = this.geometry),
      (r1.material = this.material),
      void 0 !== r1.material &&
        (null === this.boundingSphere && this.computeBoundingSphere(),
        r2.copy(this.boundingSphere),
        r2.applyMatrix4(i),
        !1 !== e.ray.intersectsSphere(r2)))
    )
      for (let r = 0; r < n; r++) {
        this.getMatrixAt(r, rK),
          rZ.multiplyMatrices(i, rK),
          (r1.matrixWorld = rZ),
          r1.raycast(e, rQ);
        for (let e = 0, i = rQ.length; e < i; e++) {
          let i = rQ[e];
          (i.instanceId = r), (i.object = this), t.push(i);
        }
        rQ.length = 0;
      }
  }
  setColorAt(e, t) {
    null === this.instanceColor &&
      (this.instanceColor = new rY(
        new Float32Array(3 * this.instanceMatrix.count).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, 3 * e);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, 16 * e);
  }
  setMorphAt(e, t) {
    let i = t.morphTargetInfluences,
      n = i.length + 1;
    null === this.morphTexture &&
      (this.morphTexture = new rX(
        new Float32Array(n * this.count),
        n,
        this.count,
        1028,
        1015
      ));
    let r = this.morphTexture.source.data.data,
      s = 0;
    for (let e = 0; e < i.length; e++) s += i[e];
    let a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
      o = n * e;
    (r[o] = a), r.set(i, o + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      null !== this.morphTexture &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
class r5 extends tS {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new tx(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const r4 = new eo(),
  r6 = new eo(),
  r7 = new ez(),
  r8 = new eU(),
  r9 = new eR(),
  se = new eo(),
  st = new eo();
class si extends te {
  constructor(e = new tz(), t = new r5()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    let e = this.geometry;
    if (null === e.index) {
      let t = e.attributes.position,
        i = [0];
      for (let e = 1, n = t.count; e < n; e++)
        r4.fromBufferAttribute(t, e - 1),
          r6.fromBufferAttribute(t, e),
          (i[e] = i[e - 1]),
          (i[e] += r4.distanceTo(r6));
      e.setAttribute("lineDistance", new tC(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    let i = this.geometry,
      n = this.matrixWorld,
      r = e.params.Line.threshold,
      s = i.drawRange;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      r9.copy(i.boundingSphere),
      r9.applyMatrix4(n),
      (r9.radius += r),
      !1 === e.ray.intersectsSphere(r9))
    )
      return;
    r7.copy(n).invert(), r8.copy(e.ray).applyMatrix4(r7);
    let a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = this.isLineSegments ? 2 : 1,
      h = i.index,
      c = i.attributes.position;
    if (null !== h) {
      let i = Math.max(0, s.start),
        n = Math.min(h.count, s.start + s.count);
      for (let r = i, s = n - 1; r < s; r += l) {
        let i = sn(this, e, r8, o, h.getX(r), h.getX(r + 1));
        i && t.push(i);
      }
      if (this.isLineLoop) {
        let r = sn(this, e, r8, o, h.getX(n - 1), h.getX(i));
        r && t.push(r);
      }
    } else {
      let i = Math.max(0, s.start),
        n = Math.min(c.count, s.start + s.count);
      for (let r = i, s = n - 1; r < s; r += l) {
        let i = sn(this, e, r8, o, r, r + 1);
        i && t.push(i);
      }
      if (this.isLineLoop) {
        let r = sn(this, e, r8, o, n - 1, i);
        r && t.push(r);
      }
    }
  }
  updateMorphTargets() {
    let e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      let i = e[t[0]];
      if (void 0 !== i) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let e = 0, t = i.length; e < t; e++) {
          let t = i[e].name || String(e);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[t] = e);
        }
      }
    }
  }
}
function sn(e, t, i, n, r, s) {
  let a = e.geometry.attributes.position;
  if (
    (r4.fromBufferAttribute(a, r),
    r6.fromBufferAttribute(a, s),
    i.distanceSqToSegment(r4, r6, se, st) > n)
  )
    return;
  se.applyMatrix4(e.matrixWorld);
  let o = t.ray.origin.distanceTo(se);
  if (!(o < t.near) && !(o > t.far))
    return {
      distance: o,
      point: st.clone().applyMatrix4(e.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: e,
    };
}
const sr = new eo(),
  ss = new eo();
class sa extends si {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    let e = this.geometry;
    if (null === e.index) {
      let t = e.attributes.position,
        i = [];
      for (let e = 0, n = t.count; e < n; e += 2)
        sr.fromBufferAttribute(t, e),
          ss.fromBufferAttribute(t, e + 1),
          (i[e] = 0 === e ? 0 : i[e - 1]),
          (i[e + 1] = i[e] + sr.distanceTo(ss));
      e.setAttribute("lineDistance", new tC(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class so extends si {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class sl extends tS {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new tx(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const sh = new ez(),
  sc = new eU(),
  su = new eR(),
  sd = new eo();
class sp extends te {
  constructor(e = new tz(), t = new sl()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    let i = this.geometry,
      n = this.matrixWorld,
      r = e.params.Points.threshold,
      s = i.drawRange;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      su.copy(i.boundingSphere),
      su.applyMatrix4(n),
      (su.radius += r),
      !1 === e.ray.intersectsSphere(su))
    )
      return;
    sh.copy(n).invert(), sc.copy(e.ray).applyMatrix4(sh);
    let a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = i.index,
      h = i.attributes.position;
    if (null !== l) {
      let i = Math.max(0, s.start),
        r = Math.min(l.count, s.start + s.count);
      for (let s = i; s < r; s++) {
        let i = l.getX(s);
        sd.fromBufferAttribute(h, i), sm(sd, i, o, n, e, t, this);
      }
    } else {
      let i = Math.max(0, s.start),
        r = Math.min(h.count, s.start + s.count);
      for (let s = i; s < r; s++)
        sd.fromBufferAttribute(h, s), sm(sd, s, o, n, e, t, this);
    }
  }
  updateMorphTargets() {
    let e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      let i = e[t[0]];
      if (void 0 !== i) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let e = 0, t = i.length; e < t; e++) {
          let t = i[e].name || String(e);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[t] = e);
        }
      }
    }
  }
}
function sm(e, t, i, n, r, s, a) {
  let o = sc.distanceSqToPoint(e);
  if (o < i) {
    let i = new eo();
    sc.closestPointToPoint(e, i), i.applyMatrix4(n);
    let l = r.ray.origin.distanceTo(i);
    if (l < r.near || l > r.far) return;
    s.push({
      distance: l,
      distanceToRay: Math.sqrt(o),
      point: i,
      index: t,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a,
    });
  }
}
class sf {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    let i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    let t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    let t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    let e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    let t = [],
      i,
      n = this.getPoint(0),
      r = 0;
    t.push(0);
    for (let s = 1; s <= e; s++)
      t.push((r += (i = this.getPoint(s / e)).distanceTo(n))), (n = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    let i;
    let n = this.getLengths(),
      r = 0,
      s = n.length;
    i = t || e * n[s - 1];
    let a = 0,
      o = s - 1,
      l;
    for (; a <= o; )
      if ((l = n[(r = Math.floor(a + (o - a) / 2))] - i) < 0) a = r + 1;
      else if (l > 0) o = r - 1;
      else {
        o = r;
        break;
      }
    if (n[(r = o)] === i) return r / (s - 1);
    let h = n[r],
      c = n[r + 1];
    return (r + (i - h) / (c - h)) / (s - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      n = e + 1e-4;
    i < 0 && (i = 0), n > 1 && (n = 1);
    let r = this.getPoint(i),
      s = this.getPoint(n),
      a = t || (r.isVector2 ? new U() : new eo());
    return a.copy(s).sub(r).normalize(), a;
  }
  getTangentAt(e, t) {
    let i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    let i = new eo(),
      n = [],
      r = [],
      s = [],
      a = new eo(),
      o = new ez();
    for (let t = 0; t <= e; t++) {
      let i = t / e;
      n[t] = this.getTangentAt(i, new eo());
    }
    (r[0] = new eo()), (s[0] = new eo());
    let l = Number.MAX_VALUE,
      h = Math.abs(n[0].x),
      c = Math.abs(n[0].y),
      u = Math.abs(n[0].z);
    h <= l && ((l = h), i.set(1, 0, 0)),
      c <= l && ((l = c), i.set(0, 1, 0)),
      u <= l && i.set(0, 0, 1),
      a.crossVectors(n[0], i).normalize(),
      r[0].crossVectors(n[0], a),
      s[0].crossVectors(n[0], r[0]);
    for (let t = 1; t <= e; t++) {
      if (
        ((r[t] = r[t - 1].clone()),
        (s[t] = s[t - 1].clone()),
        a.crossVectors(n[t - 1], n[t]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        let e = Math.acos(P(n[t - 1].dot(n[t]), -1, 1));
        r[t].applyMatrix4(o.makeRotationAxis(a, e));
      }
      s[t].crossVectors(n[t], r[t]);
    }
    if (!0 === t) {
      let t = Math.acos(P(r[0].dot(r[e]), -1, 1));
      (t /= e), n[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
      for (let i = 1; i <= e; i++)
        r[i].applyMatrix4(o.makeRotationAxis(n[i], t * i)),
          s[i].crossVectors(n[i], r[i]);
    }
    return { tangents: n, normals: r, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    let e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class sg extends sf {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    n = 1,
    r = 0,
    s = 2 * Math.PI,
    a = !1,
    o = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = n),
      (this.aStartAngle = r),
      (this.aEndAngle = s),
      (this.aClockwise = a),
      (this.aRotation = o);
  }
  getPoint(e, t = new U()) {
    let i = 2 * Math.PI,
      n = this.aEndAngle - this.aStartAngle,
      r = Math.abs(n) < Number.EPSILON;
    for (; n < 0; ) n += i;
    for (; n > i; ) n -= i;
    n < Number.EPSILON && (n = r ? 0 : i),
      !0 !== this.aClockwise || r || (n === i ? (n = -i) : (n -= i));
    let s = this.aStartAngle + e * n,
      a = this.aX + this.xRadius * Math.cos(s),
      o = this.aY + this.yRadius * Math.sin(s);
    if (0 !== this.aRotation) {
      let e = Math.cos(this.aRotation),
        t = Math.sin(this.aRotation),
        i = a - this.aX,
        n = o - this.aY;
      (a = i * e - n * t + this.aX), (o = i * t + n * e + this.aY);
    }
    return t.set(a, o);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
function s_() {
  let e = 0,
    t = 0,
    i = 0,
    n = 0;
  function r(r, s, a, o) {
    (e = r),
      (t = a),
      (i = -3 * r + 3 * s - 2 * a - o),
      (n = 2 * r - 2 * s + a + o);
  }
  return {
    initCatmullRom: function (e, t, i, n, s) {
      r(t, i, s * (i - e), s * (n - t));
    },
    initNonuniformCatmullRom: function (e, t, i, n, s, a, o) {
      let l = (t - e) / s - (i - e) / (s + a) + (i - t) / a,
        h = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
      r(t, i, (l *= a), (h *= a));
    },
    calc: function (r) {
      let s = r * r;
      return e + t * r + i * s + s * r * n;
    },
  };
}
const sv = new eo(),
  sx = new s_(),
  sy = new s_(),
  sM = new s_();
function sS(e, t, i, n, r) {
  let s = (n - t) * 0.5,
    a = (r - i) * 0.5,
    o = e * e;
  return (
    e * o * (2 * i - 2 * n + s + a) +
    (-3 * i + 3 * n - 2 * s - a) * o +
    s * e +
    i
  );
}
function sb(e, t, i, n) {
  return (
    (function (e, t) {
      let i = 1 - e;
      return i * i * t;
    })(e, t) +
    2 * (1 - e) * e * i +
    e * e * n
  );
}
function sT(e, t, i, n, r) {
  return (
    (function (e, t) {
      let i = 1 - e;
      return i * i * i * t;
    })(e, t) +
    (function (e, t) {
      let i = 1 - e;
      return 3 * i * i * e * t;
    })(e, i) +
    3 * (1 - e) * e * e * n +
    e * e * e * r
  );
}
class sE extends sf {
  constructor(e = new U(), t = new U(), i = new U(), n = new U()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = n);
  }
  getPoint(e, t = new U()) {
    let i = this.v0,
      n = this.v1,
      r = this.v2,
      s = this.v3;
    return t.set(sT(e, i.x, n.x, r.x, s.x), sT(e, i.y, n.y, r.y, s.y)), t;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class sw extends sf {
  constructor(e = new U(), t = new U()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new U()) {
    return (
      1 === e
        ? t.copy(this.v2)
        : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)),
      t
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new U()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class sA extends sf {
  constructor(e = new U(), t = new U(), i = new U()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new U()) {
    let i = this.v0,
      n = this.v1,
      r = this.v2;
    return t.set(sb(e, i.x, n.x, r.x), sb(e, i.y, n.y, r.y)), t;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class sR extends sf {
  constructor(e = new eo(), t = new eo(), i = new eo()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new eo()) {
    let i = this.v0,
      n = this.v1,
      r = this.v2;
    return (
      t.set(sb(e, i.x, n.x, r.x), sb(e, i.y, n.y, r.y), sb(e, i.z, n.z, r.z)), t
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class sC extends sf {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new U()) {
    let i = this.points,
      n = (i.length - 1) * e,
      r = Math.floor(n),
      s = n - r,
      a = i[0 === r ? r : r - 1],
      o = i[r],
      l = i[r > i.length - 2 ? i.length - 1 : r + 1],
      h = i[r > i.length - 3 ? i.length - 1 : r + 2];
    return t.set(sS(s, a.x, o.x, l.x, h.x), sS(s, a.y, o.y, l.y, h.y)), t;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      let i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    let e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      let i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      let i = e.points[t];
      this.points.push(new U().fromArray(i));
    }
    return this;
  }
}
var sP = Object.freeze({
  __proto__: null,
  ArcCurve: class extends sg {
    constructor(e, t, i, n, r, s) {
      super(e, t, i, i, n, r, s),
        (this.isArcCurve = !0),
        (this.type = "ArcCurve");
    }
  },
  CatmullRomCurve3: class extends sf {
    constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
      super(),
        (this.isCatmullRomCurve3 = !0),
        (this.type = "CatmullRomCurve3"),
        (this.points = e),
        (this.closed = t),
        (this.curveType = i),
        (this.tension = n);
    }
    getPoint(e, t = new eo()) {
      let i, n;
      let r = this.points,
        s = r.length,
        a = (s - (this.closed ? 0 : 1)) * e,
        o = Math.floor(a),
        l = a - o;
      this.closed
        ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s)
        : 0 === l && o === s - 1 && ((o = s - 2), (l = 1)),
        this.closed || o > 0
          ? (i = r[(o - 1) % s])
          : (sv.subVectors(r[0], r[1]).add(r[0]), (i = sv));
      let h = r[o % s],
        c = r[(o + 1) % s];
      if (
        (this.closed || o + 2 < s
          ? (n = r[(o + 2) % s])
          : (sv.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (n = sv)),
        "centripetal" === this.curveType || "chordal" === this.curveType)
      ) {
        let e = "chordal" === this.curveType ? 0.5 : 0.25,
          t = Math.pow(i.distanceToSquared(h), e),
          r = Math.pow(h.distanceToSquared(c), e),
          s = Math.pow(c.distanceToSquared(n), e);
        r < 1e-4 && (r = 1),
          t < 1e-4 && (t = r),
          s < 1e-4 && (s = r),
          sx.initNonuniformCatmullRom(i.x, h.x, c.x, n.x, t, r, s),
          sy.initNonuniformCatmullRom(i.y, h.y, c.y, n.y, t, r, s),
          sM.initNonuniformCatmullRom(i.z, h.z, c.z, n.z, t, r, s);
      } else
        "catmullrom" === this.curveType &&
          (sx.initCatmullRom(i.x, h.x, c.x, n.x, this.tension),
          sy.initCatmullRom(i.y, h.y, c.y, n.y, this.tension),
          sM.initCatmullRom(i.z, h.z, c.z, n.z, this.tension));
      return t.set(sx.calc(l), sy.calc(l), sM.calc(l)), t;
    }
    copy(e) {
      super.copy(e), (this.points = []);
      for (let t = 0, i = e.points.length; t < i; t++) {
        let i = e.points[t];
        this.points.push(i.clone());
      }
      return (
        (this.closed = e.closed),
        (this.curveType = e.curveType),
        (this.tension = e.tension),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      e.points = [];
      for (let t = 0, i = this.points.length; t < i; t++) {
        let i = this.points[t];
        e.points.push(i.toArray());
      }
      return (
        (e.closed = this.closed),
        (e.curveType = this.curveType),
        (e.tension = this.tension),
        e
      );
    }
    fromJSON(e) {
      super.fromJSON(e), (this.points = []);
      for (let t = 0, i = e.points.length; t < i; t++) {
        let i = e.points[t];
        this.points.push(new eo().fromArray(i));
      }
      return (
        (this.closed = e.closed),
        (this.curveType = e.curveType),
        (this.tension = e.tension),
        this
      );
    }
  },
  CubicBezierCurve: sE,
  CubicBezierCurve3: class extends sf {
    constructor(e = new eo(), t = new eo(), i = new eo(), n = new eo()) {
      super(),
        (this.isCubicBezierCurve3 = !0),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = e),
        (this.v1 = t),
        (this.v2 = i),
        (this.v3 = n);
    }
    getPoint(e, t = new eo()) {
      let i = this.v0,
        n = this.v1,
        r = this.v2,
        s = this.v3;
      return (
        t.set(
          sT(e, i.x, n.x, r.x, s.x),
          sT(e, i.y, n.y, r.y, s.y),
          sT(e, i.z, n.z, r.z, s.z)
        ),
        t
      );
    }
    copy(e) {
      return (
        super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        (e.v3 = this.v3.toArray()),
        e
      );
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
      );
    }
  },
  EllipseCurve: sg,
  LineCurve: sw,
  LineCurve3: class extends sf {
    constructor(e = new eo(), t = new eo()) {
      super(),
        (this.isLineCurve3 = !0),
        (this.type = "LineCurve3"),
        (this.v1 = e),
        (this.v2 = t);
    }
    getPoint(e, t = new eo()) {
      return (
        1 === e
          ? t.copy(this.v2)
          : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)),
        t
      );
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t = new eo()) {
      return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
      return this.getTangent(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      let e = super.toJSON();
      return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }
  },
  QuadraticBezierCurve: sA,
  QuadraticBezierCurve3: sR,
  SplineCurve: sC,
});
class sL extends sf {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    let e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      let i = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
      this.curves.push(new sP[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    let i = e * this.getLength(),
      n = this.getCurveLengths(),
      r = 0;
    for (; r < n.length; ) {
      if (n[r] >= i) {
        let e = n[r] - i,
          s = this.curves[r],
          a = s.getLength(),
          o = 0 === a ? 0 : 1 - e / a;
        return s.getPointAt(o, t);
      }
      r++;
    }
    return null;
  }
  getLength() {
    let e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    let e = [],
      t = 0;
    for (let i = 0, n = this.curves.length; i < n; i++)
      e.push((t += this.curves[i].getLength()));
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    let t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    let t;
    let i = [];
    for (let n = 0, r = this.curves; n < r.length; n++) {
      let s = r[n],
        a = s.isEllipseCurve
          ? 2 * e
          : s.isLineCurve || s.isLineCurve3
          ? 1
          : s.isSplineCurve
          ? e * s.points.length
          : e,
        o = s.getPoints(a);
      for (let e = 0; e < o.length; e++) {
        let n = o[e];
        (t && t.equals(n)) || (i.push(n), (t = n));
      }
    }
    return (
      this.autoClose &&
        i.length > 1 &&
        !i[i.length - 1].equals(i[0]) &&
        i.push(i[0]),
      i
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      let i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    let e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, i = this.curves.length; t < i; t++) {
      let i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      let i = e.curves[t];
      this.curves.push(new sP[i.type]().fromJSON(i));
    }
    return this;
  }
}
class sN extends sL {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new U()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    let i = new sw(this.currentPoint.clone(), new U(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, n) {
    let r = new sA(this.currentPoint.clone(), new U(e, t), new U(i, n));
    return this.curves.push(r), this.currentPoint.set(i, n), this;
  }
  bezierCurveTo(e, t, i, n, r, s) {
    let a = new sE(
      this.currentPoint.clone(),
      new U(e, t),
      new U(i, n),
      new U(r, s)
    );
    return this.curves.push(a), this.currentPoint.set(r, s), this;
  }
  splineThru(e) {
    let t = new sC([this.currentPoint.clone()].concat(e));
    return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, n, r, s) {
    let a = this.currentPoint.x,
      o = this.currentPoint.y;
    return this.absarc(e + a, t + o, i, n, r, s), this;
  }
  absarc(e, t, i, n, r, s) {
    return this.absellipse(e, t, i, i, n, r, s), this;
  }
  ellipse(e, t, i, n, r, s, a, o) {
    let l = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + l, t + h, i, n, r, s, a, o), this;
  }
  absellipse(e, t, i, n, r, s, a, o) {
    let l = new sg(e, t, i, n, r, s, a, o);
    if (this.curves.length > 0) {
      let e = l.getPoint(0);
      e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
    }
    this.curves.push(l);
    let h = l.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class sI extends tz {
  constructor(
    e = [new U(0, -0.5), new U(0.5, 0), new U(0, 0.5)],
    t = 12,
    i = 0,
    n = 2 * Math.PI
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: n }),
      (t = Math.floor(t)),
      (n = P(n, 0, 2 * Math.PI));
    let r = [],
      s = [],
      a = [],
      o = [],
      l = [],
      h = 1 / t,
      c = new eo(),
      u = new U(),
      d = new eo(),
      p = new eo(),
      m = new eo(),
      f = 0,
      g = 0;
    for (let t = 0; t <= e.length - 1; t++)
      switch (t) {
        case 0:
          (f = e[t + 1].x - e[t].x),
            (g = e[t + 1].y - e[t].y),
            (d.x = 1 * g),
            (d.y = -f),
            (d.z = 0 * g),
            m.copy(d),
            d.normalize(),
            o.push(d.x, d.y, d.z);
          break;
        case e.length - 1:
          o.push(m.x, m.y, m.z);
          break;
        default:
          (f = e[t + 1].x - e[t].x),
            (g = e[t + 1].y - e[t].y),
            (d.x = 1 * g),
            (d.y = -f),
            (d.z = 0 * g),
            p.copy(d),
            (d.x += m.x),
            (d.y += m.y),
            (d.z += m.z),
            d.normalize(),
            o.push(d.x, d.y, d.z),
            m.copy(p);
      }
    for (let r = 0; r <= t; r++) {
      let d = i + r * h * n,
        p = Math.sin(d),
        m = Math.cos(d);
      for (let i = 0; i <= e.length - 1; i++) {
        (c.x = e[i].x * p),
          (c.y = e[i].y),
          (c.z = e[i].x * m),
          s.push(c.x, c.y, c.z),
          (u.x = r / t),
          (u.y = i / (e.length - 1)),
          a.push(u.x, u.y);
        let n = o[3 * i + 0] * p,
          h = o[3 * i + 1],
          d = o[3 * i + 0] * m;
        l.push(n, h, d);
      }
    }
    for (let i = 0; i < t; i++)
      for (let t = 0; t < e.length - 1; t++) {
        let n = t + i * e.length,
          s = n + e.length,
          a = n + e.length + 1,
          o = n + 1;
        r.push(n, s, o), r.push(a, o, s);
      }
    this.setIndex(r),
      this.setAttribute("position", new tC(s, 3)),
      this.setAttribute("uv", new tC(a, 2)),
      this.setAttribute("normal", new tC(l, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sI(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class sD extends sI {
  constructor(e = 1, t = 1, i = 4, n = 8) {
    let r = new sN();
    r.absarc(0, -t / 2, e, 1.5 * Math.PI, 0),
      r.absarc(0, t / 2, e, 0, 0.5 * Math.PI),
      super(r.getPoints(i), n),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: i,
        radialSegments: n,
      });
  }
  static fromJSON(e) {
    return new sD(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class sO extends tz {
  constructor(e = 1, t = 32, i = 0, n = 2 * Math.PI) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: n,
      }),
      (t = Math.max(3, t));
    let r = [],
      s = [],
      a = [],
      o = [],
      l = new eo(),
      h = new U();
    s.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
    for (let r = 0, c = 3; r <= t; r++, c += 3) {
      let u = i + (r / t) * n;
      (l.x = e * Math.cos(u)),
        (l.y = e * Math.sin(u)),
        s.push(l.x, l.y, l.z),
        a.push(0, 0, 1),
        (h.x = (s[c] / e + 1) / 2),
        (h.y = (s[c + 1] / e + 1) / 2),
        o.push(h.x, h.y);
    }
    for (let e = 1; e <= t; e++) r.push(e, e + 1, 0);
    this.setIndex(r),
      this.setAttribute("position", new tC(s, 3)),
      this.setAttribute("normal", new tC(a, 3)),
      this.setAttribute("uv", new tC(o, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sO(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class sU extends tz {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    n = 32,
    r = 1,
    s = !1,
    a = 0,
    o = 2 * Math.PI
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: n,
        heightSegments: r,
        openEnded: s,
        thetaStart: a,
        thetaLength: o,
      });
    let l = this;
    (n = Math.floor(n)), (r = Math.floor(r));
    let h = [],
      c = [],
      u = [],
      d = [],
      p = 0,
      m = [],
      f = i / 2,
      g = 0;
    function _(i) {
      let r = p,
        s = new U(),
        m = new eo(),
        _ = 0,
        v = !0 === i ? e : t,
        x = !0 === i ? 1 : -1;
      for (let e = 1; e <= n; e++)
        c.push(0, f * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++;
      let y = p;
      for (let e = 0; e <= n; e++) {
        let t = (e / n) * o + a,
          i = Math.cos(t),
          r = Math.sin(t);
        (m.x = v * r),
          (m.y = f * x),
          (m.z = v * i),
          c.push(m.x, m.y, m.z),
          u.push(0, x, 0),
          (s.x = 0.5 * i + 0.5),
          (s.y = 0.5 * r * x + 0.5),
          d.push(s.x, s.y),
          p++;
      }
      for (let e = 0; e < n; e++) {
        let t = r + e,
          n = y + e;
        !0 === i ? h.push(n, n + 1, t) : h.push(n + 1, n, t), (_ += 3);
      }
      l.addGroup(g, _, !0 === i ? 1 : 2), (g += _);
    }
    (function () {
      let s = new eo(),
        _ = new eo(),
        v = 0,
        x = (t - e) / i;
      for (let l = 0; l <= r; l++) {
        let h = [],
          g = l / r,
          v = g * (t - e) + e;
        for (let e = 0; e <= n; e++) {
          let t = e / n,
            r = t * o + a,
            l = Math.sin(r),
            m = Math.cos(r);
          (_.x = v * l),
            (_.y = -g * i + f),
            (_.z = v * m),
            c.push(_.x, _.y, _.z),
            s.set(l, x, m).normalize(),
            u.push(s.x, s.y, s.z),
            d.push(t, 1 - g),
            h.push(p++);
        }
        m.push(h);
      }
      for (let i = 0; i < n; i++)
        for (let n = 0; n < r; n++) {
          let r = m[n][i],
            s = m[n + 1][i],
            a = m[n + 1][i + 1],
            o = m[n][i + 1];
          e > 0 && (h.push(r, s, o), (v += 3)),
            t > 0 && (h.push(s, a, o), (v += 3));
        }
      l.addGroup(g, v, 0), (g += v);
    })(),
      !1 === s && (e > 0 && _(!0), t > 0 && _(!1)),
      this.setIndex(h),
      this.setAttribute("position", new tC(c, 3)),
      this.setAttribute("normal", new tC(u, 3)),
      this.setAttribute("uv", new tC(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sU(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class sz extends sU {
  constructor(e = 1, t = 1, i = 32, n = 1, r = !1, s = 0, a = 2 * Math.PI) {
    super(0, e, t, i, n, r, s, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: s,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new sz(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class sF extends tz {
  constructor(e = [], t = [], i = 1, n = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: n });
    let r = [],
      s = [];
    function a(e) {
      r.push(e.x, e.y, e.z);
    }
    function o(t, i) {
      let n = 3 * t;
      (i.x = e[n + 0]), (i.y = e[n + 1]), (i.z = e[n + 2]);
    }
    function l(e, t, i, n) {
      n < 0 && 1 === e.x && (s[t] = e.x - 1),
        0 === i.x && 0 === i.z && (s[t] = n / 2 / Math.PI + 0.5);
    }
    function h(e) {
      return Math.atan2(e.z, -e.x);
    }
    (function (e) {
      let i = new eo(),
        n = new eo(),
        r = new eo();
      for (let s = 0; s < t.length; s += 3)
        o(t[s + 0], i),
          o(t[s + 1], n),
          o(t[s + 2], r),
          (function (e, t, i, n) {
            let r = n + 1,
              s = [];
            for (let n = 0; n <= r; n++) {
              s[n] = [];
              let a = e.clone().lerp(i, n / r),
                o = t.clone().lerp(i, n / r),
                l = r - n;
              for (let e = 0; e <= l; e++)
                0 === e && n === r
                  ? (s[n][e] = a)
                  : (s[n][e] = a.clone().lerp(o, e / l));
            }
            for (let e = 0; e < r; e++)
              for (let t = 0; t < 2 * (r - e) - 1; t++) {
                let i = Math.floor(t / 2);
                t % 2 == 0
                  ? (a(s[e][i + 1]), a(s[e + 1][i]), a(s[e][i]))
                  : (a(s[e][i + 1]), a(s[e + 1][i + 1]), a(s[e + 1][i]));
              }
          })(i, n, r, e);
    })(n),
      (function (e) {
        let t = new eo();
        for (let i = 0; i < r.length; i += 3)
          (t.x = r[i + 0]),
            (t.y = r[i + 1]),
            (t.z = r[i + 2]),
            t.normalize().multiplyScalar(e),
            (r[i + 0] = t.x),
            (r[i + 1] = t.y),
            (r[i + 2] = t.z);
      })(i),
      (function () {
        let e = new eo();
        for (let t = 0; t < r.length; t += 3) {
          (e.x = r[t + 0]), (e.y = r[t + 1]), (e.z = r[t + 2]);
          let i = h(e) / 2 / Math.PI + 0.5,
            n =
              Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +
              0.5;
          s.push(i, 1 - n);
        }
        (function () {
          let e = new eo(),
            t = new eo(),
            i = new eo(),
            n = new eo(),
            a = new U(),
            o = new U(),
            c = new U();
          for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
            e.set(r[u + 0], r[u + 1], r[u + 2]),
              t.set(r[u + 3], r[u + 4], r[u + 5]),
              i.set(r[u + 6], r[u + 7], r[u + 8]),
              a.set(s[d + 0], s[d + 1]),
              o.set(s[d + 2], s[d + 3]),
              c.set(s[d + 4], s[d + 5]),
              n.copy(e).add(t).add(i).divideScalar(3);
            let p = h(n);
            l(a, d + 0, e, p), l(o, d + 2, t, p), l(c, d + 4, i, p);
          }
        })(),
          (function () {
            for (let e = 0; e < s.length; e += 6) {
              let t = s[e + 0],
                i = s[e + 2],
                n = s[e + 4],
                r = Math.max(t, i, n),
                a = Math.min(t, i, n);
              r > 0.9 &&
                a < 0.1 &&
                (t < 0.2 && (s[e + 0] += 1),
                i < 0.2 && (s[e + 2] += 1),
                n < 0.2 && (s[e + 4] += 1));
            }
          })();
      })(),
      this.setAttribute("position", new tC(r, 3)),
      this.setAttribute("normal", new tC(r.slice(), 3)),
      this.setAttribute("uv", new tC(s, 2)),
      0 === n ? this.computeVertexNormals() : this.normalizeNormals();
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sF(e.vertices, e.indices, e.radius, e.details);
  }
}
class sB extends sF {
  constructor(e = 1, t = 0) {
    let i = (1 + Math.sqrt(5)) / 2,
      n = 1 / i;
    super(
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n,
      ],
      [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ],
      e,
      t
    ),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new sB(e.radius, e.detail);
  }
}
class sk extends sN {
  constructor(e) {
    super(e), (this.uuid = C()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    let t = [];
    for (let i = 0, n = this.holes.length; i < n; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      let i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    let e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, i = this.holes.length; t < i; t++) {
      let i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      let i = e.holes[t];
      this.holes.push(new sN().fromJSON(i));
    }
    return this;
  }
}
const sH = {
  triangulate: function (e, t, i = 2) {
    let n, r, s, a, o, l, h;
    let c = t && t.length,
      u = c ? t[0] * i : e.length,
      d = sV(e, 0, u, i, !0),
      p = [];
    if (!d || d.next === d.prev) return p;
    if (
      (c &&
        (d = (function (e, t, i, n) {
          let r, s, a, o, l;
          let h = [];
          for (r = 0, s = t.length; r < s; r++)
            (a = t[r] * n),
              (o = r < s - 1 ? t[r + 1] * n : e.length),
              (l = sV(e, a, o, n, !1)) === l.next && (l.steiner = !0),
              h.push(
                (function (e) {
                  let t = e,
                    i = e;
                  do
                    (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t),
                      (t = t.next);
                  while (t !== e);
                  return i;
                })(l)
              );
          for (h.sort(sW), r = 0; r < h.length; r++)
            i = (function (e, t) {
              let i = (function (e, t) {
                let i = t,
                  n = -1 / 0,
                  r,
                  s = e.x,
                  a = e.y;
                do {
                  if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                    let e =
                      i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                    if (
                      e <= s &&
                      e > n &&
                      ((n = e), (r = i.x < i.next.x ? i : i.next), e === s)
                    )
                      return r;
                  }
                  i = i.next;
                } while (i !== t);
                if (!r) return null;
                let o = r,
                  l = r.x,
                  h = r.y,
                  c = 1 / 0,
                  u;
                i = r;
                do {
                  var d, p;
                  s >= i.x &&
                    i.x >= l &&
                    s !== i.x &&
                    sj(a < h ? s : n, a, l, h, a < h ? n : s, a, i.x, i.y) &&
                    ((u = Math.abs(a - i.y) / (s - i.x)),
                    sQ(i, e) &&
                      (u < c ||
                        (u === c &&
                          (i.x > r.x ||
                            (i.x === r.x &&
                              ((d = r),
                              (p = i),
                              0 > sq(d.prev, d, p.prev) &&
                                0 > sq(p.next, d, d.next)))))) &&
                      ((r = i), (c = u))),
                    (i = i.next);
                } while (i !== o);
                return r;
              })(e, t);
              if (!i) return t;
              let n = s$(i, e);
              return sG(n, n.next), sG(i, i.next);
            })(h[r], i);
          return i;
        })(e, t, d, i)),
      e.length > 80 * i)
    ) {
      (n = s = e[0]), (r = a = e[1]);
      for (let t = i; t < u; t += i)
        (o = e[t]),
          (l = e[t + 1]),
          o < n && (n = o),
          l < r && (r = l),
          o > s && (s = o),
          l > a && (a = l);
      h = 0 !== (h = Math.max(s - n, a - r)) ? 32767 / h : 0;
    }
    return (
      (function e(t, i, n, r, s, a, o) {
        if (!t) return;
        !o &&
          a &&
          (function (e, t, i, n) {
            let r = e;
            do
              0 === r.z && (r.z = sX(r.x, r.y, t, i, n)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            while (r !== e);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (e) {
                let t,
                  i,
                  n,
                  r,
                  s,
                  a,
                  o,
                  l,
                  h = 1;
                do {
                  for (i = e, e = null, s = null, a = 0; i; ) {
                    for (
                      a++, n = i, o = 0, t = 0;
                      t < h && (o++, (n = n.nextZ));
                      t++
                    );
                    for (l = h; o > 0 || (l > 0 && n); )
                      0 !== o && (0 === l || !n || i.z <= n.z)
                        ? ((r = i), (i = i.nextZ), o--)
                        : ((r = n), (n = n.nextZ), l--),
                        s ? (s.nextZ = r) : (e = r),
                        (r.prevZ = s),
                        (s = r);
                    i = n;
                  }
                  (s.nextZ = null), (h *= 2);
                } while (a > 1);
              })(r);
          })(t, r, s, a);
        let l = t,
          h,
          c;
        for (; t.prev !== t.next; ) {
          if (
            ((h = t.prev),
            (c = t.next),
            a
              ? (function (e, t, i, n) {
                  let r = e.prev,
                    s = e.next;
                  if (sq(r, e, s) >= 0) return !1;
                  let a = r.x,
                    o = e.x,
                    l = s.x,
                    h = r.y,
                    c = e.y,
                    u = s.y,
                    d = a < o ? (a < l ? a : l) : o < l ? o : l,
                    p = h < c ? (h < u ? h : u) : c < u ? c : u,
                    m = a > o ? (a > l ? a : l) : o > l ? o : l,
                    f = h > c ? (h > u ? h : u) : c > u ? c : u,
                    g = sX(d, p, t, i, n),
                    _ = sX(m, f, t, i, n),
                    v = e.prevZ,
                    x = e.nextZ;
                  for (; v && v.z >= g && x && x.z <= _; ) {
                    if (
                      (v.x >= d &&
                        v.x <= m &&
                        v.y >= p &&
                        v.y <= f &&
                        v !== r &&
                        v !== s &&
                        sj(a, h, o, c, l, u, v.x, v.y) &&
                        sq(v.prev, v, v.next) >= 0) ||
                      ((v = v.prevZ),
                      x.x >= d &&
                        x.x <= m &&
                        x.y >= p &&
                        x.y <= f &&
                        x !== r &&
                        x !== s &&
                        sj(a, h, o, c, l, u, x.x, x.y) &&
                        sq(x.prev, x, x.next) >= 0)
                    )
                      return !1;
                    x = x.nextZ;
                  }
                  for (; v && v.z >= g; ) {
                    if (
                      v.x >= d &&
                      v.x <= m &&
                      v.y >= p &&
                      v.y <= f &&
                      v !== r &&
                      v !== s &&
                      sj(a, h, o, c, l, u, v.x, v.y) &&
                      sq(v.prev, v, v.next) >= 0
                    )
                      return !1;
                    v = v.prevZ;
                  }
                  for (; x && x.z <= _; ) {
                    if (
                      x.x >= d &&
                      x.x <= m &&
                      x.y >= p &&
                      x.y <= f &&
                      x !== r &&
                      x !== s &&
                      sj(a, h, o, c, l, u, x.x, x.y) &&
                      sq(x.prev, x, x.next) >= 0
                    )
                      return !1;
                    x = x.nextZ;
                  }
                  return !0;
                })(t, r, s, a)
              : (function (e) {
                  let t = e.prev,
                    i = e.next;
                  if (sq(t, e, i) >= 0) return !1;
                  let n = t.x,
                    r = e.x,
                    s = i.x,
                    a = t.y,
                    o = e.y,
                    l = i.y,
                    h = n < r ? (n < s ? n : s) : r < s ? r : s,
                    c = a < o ? (a < l ? a : l) : o < l ? o : l,
                    u = n > r ? (n > s ? n : s) : r > s ? r : s,
                    d = a > o ? (a > l ? a : l) : o > l ? o : l,
                    p = i.next;
                  for (; p !== t; ) {
                    if (
                      p.x >= h &&
                      p.x <= u &&
                      p.y >= c &&
                      p.y <= d &&
                      sj(n, a, r, o, s, l, p.x, p.y) &&
                      sq(p.prev, p, p.next) >= 0
                    )
                      return !1;
                    p = p.next;
                  }
                  return !0;
                })(t))
          ) {
            i.push((h.i / n) | 0),
              i.push((t.i / n) | 0),
              i.push((c.i / n) | 0),
              s1(t),
              (t = c.next),
              (l = c.next);
            continue;
          }
          if ((t = c) === l) {
            o
              ? 1 === o
                ? e(
                    (t = (function (e, t, i) {
                      let n = e;
                      do {
                        let r = n.prev,
                          s = n.next.next;
                        !sJ(r, s) &&
                          sY(r, n, n.next, s) &&
                          sQ(r, s) &&
                          sQ(s, r) &&
                          (t.push((r.i / i) | 0),
                          t.push((n.i / i) | 0),
                          t.push((s.i / i) | 0),
                          s1(n),
                          s1(n.next),
                          (n = e = s)),
                          (n = n.next);
                      } while (n !== e);
                      return sG(n);
                    })(sG(t), i, n)),
                    i,
                    n,
                    r,
                    s,
                    a,
                    2
                  )
                : 2 === o &&
                  (function (t, i, n, r, s, a) {
                    let o = t;
                    do {
                      let t = o.next.next;
                      for (; t !== o.prev; ) {
                        var l, h;
                        if (
                          o.i !== t.i &&
                          ((l = o),
                          (h = t),
                          l.next.i !== h.i &&
                            l.prev.i !== h.i &&
                            !(function (e, t) {
                              let i = e;
                              do {
                                if (
                                  i.i !== e.i &&
                                  i.next.i !== e.i &&
                                  i.i !== t.i &&
                                  i.next.i !== t.i &&
                                  sY(i, i.next, e, t)
                                )
                                  return !0;
                                i = i.next;
                              } while (i !== e);
                              return !1;
                            })(l, h) &&
                            ((sQ(l, h) &&
                              sQ(h, l) &&
                              (function (e, t) {
                                let i = e,
                                  n = !1,
                                  r = (e.x + t.x) / 2,
                                  s = (e.y + t.y) / 2;
                                do
                                  i.y > s != i.next.y > s &&
                                    i.next.y !== i.y &&
                                    r <
                                      ((i.next.x - i.x) * (s - i.y)) /
                                        (i.next.y - i.y) +
                                        i.x &&
                                    (n = !n),
                                    (i = i.next);
                                while (i !== e);
                                return n;
                              })(l, h) &&
                              (sq(l.prev, l, h.prev) || sq(l, h.prev, h))) ||
                              (sJ(l, h) &&
                                sq(l.prev, l, l.next) > 0 &&
                                sq(h.prev, h, h.next) > 0)))
                        ) {
                          let l = s$(o, t);
                          (o = sG(o, o.next)),
                            (l = sG(l, l.next)),
                            e(o, i, n, r, s, a, 0),
                            e(l, i, n, r, s, a, 0);
                          return;
                        }
                        t = t.next;
                      }
                      o = o.next;
                    } while (o !== t);
                  })(t, i, n, r, s, a)
              : e(sG(t), i, n, r, s, a, 1);
            break;
          }
        }
      })(d, p, i, n, r, h, 0),
      p
    );
  },
};
function sV(e, t, i, n, r) {
  let s, a;
  if (
    r ===
    (function (e, t, i, n) {
      let r = 0;
      for (let s = t, a = i - n; s < i; s += n)
        (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])), (a = s);
      return r;
    })(e, t, i, n) >
      0
  )
    for (s = t; s < i; s += n) a = s0(s, e[s], e[s + 1], a);
  else for (s = i - n; s >= t; s -= n) a = s0(s, e[s], e[s + 1], a);
  return a && sJ(a, a.next) && (s1(a), (a = a.next)), a;
}
function sG(e, t) {
  if (!e) return e;
  t || (t = e);
  let i = e,
    n;
  do
    if (
      ((n = !1), !i.steiner && (sJ(i, i.next) || 0 === sq(i.prev, i, i.next)))
    ) {
      if ((s1(i), (i = t = i.prev) === i.next)) break;
      n = !0;
    } else i = i.next;
  while (n || i !== t);
  return t;
}
function sW(e, t) {
  return e.x - t.x;
}
function sX(e, t, i, n, r) {
  return (
    (e =
      ((e =
        ((e =
          ((e = ((e = ((e - i) * r) | 0) | (e << 8)) & 16711935) | (e << 4)) &
          252645135) |
          (e << 2)) &
        858993459) |
        (e << 1)) &
      1431655765) |
    ((t =
      ((t =
        ((t =
          ((t = ((t = ((t - n) * r) | 0) | (t << 8)) & 16711935) | (t << 4)) &
          252645135) |
          (t << 2)) &
        858993459) |
        (t << 1)) &
      1431655765) <<
      1)
  );
}
function sj(e, t, i, n, r, s, a, o) {
  return (
    (r - a) * (t - o) >= (e - a) * (s - o) &&
    (e - a) * (n - o) >= (i - a) * (t - o) &&
    (i - a) * (s - o) >= (r - a) * (n - o)
  );
}
function sq(e, t, i) {
  return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
}
function sJ(e, t) {
  return e.x === t.x && e.y === t.y;
}
function sY(e, t, i, n) {
  let r = sZ(sq(e, t, i)),
    s = sZ(sq(e, t, n)),
    a = sZ(sq(i, n, e)),
    o = sZ(sq(i, n, t));
  return !!(
    (r !== s && a !== o) ||
    (0 === r && sK(e, i, t)) ||
    (0 === s && sK(e, n, t)) ||
    (0 === a && sK(i, e, n)) ||
    (0 === o && sK(i, t, n))
  );
}
function sK(e, t, i) {
  return (
    t.x <= Math.max(e.x, i.x) &&
    t.x >= Math.min(e.x, i.x) &&
    t.y <= Math.max(e.y, i.y) &&
    t.y >= Math.min(e.y, i.y)
  );
}
function sZ(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}
function sQ(e, t) {
  return 0 > sq(e.prev, e, e.next)
    ? sq(e, t, e.next) >= 0 && sq(e, e.prev, t) >= 0
    : 0 > sq(e, t, e.prev) || 0 > sq(e, e.next, t);
}
function s$(e, t) {
  let i = new s2(e.i, e.x, e.y),
    n = new s2(t.i, t.x, t.y),
    r = e.next,
    s = t.prev;
  return (
    (e.next = t),
    (t.prev = e),
    (i.next = r),
    (r.prev = i),
    (n.next = i),
    (i.prev = n),
    (s.next = n),
    (n.prev = s),
    n
  );
}
function s0(e, t, i, n) {
  let r = new s2(e, t, i);
  return (
    n
      ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function s1(e) {
  (e.next.prev = e.prev),
    (e.prev.next = e.next),
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function s2(e, t, i) {
  (this.i = e),
    (this.x = t),
    (this.y = i),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
class s3 {
  static area(e) {
    let t = e.length,
      i = 0;
    for (let n = t - 1, r = 0; r < t; n = r++)
      i += e[n].x * e[r].y - e[r].x * e[n].y;
    return 0.5 * i;
  }
  static isClockWise(e) {
    return 0 > s3.area(e);
  }
  static triangulateShape(e, t) {
    let i = [],
      n = [],
      r = [];
    s5(e), s4(i, e);
    let s = e.length;
    t.forEach(s5);
    for (let e = 0; e < t.length; e++)
      n.push(s), (s += t[e].length), s4(i, t[e]);
    let a = sH.triangulate(i, n);
    for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
    return r;
  }
}
function s5(e) {
  let t = e.length;
  t > 2 && e[t - 1].equals(e[0]) && e.pop();
}
function s4(e, t) {
  for (let i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y);
}
class s6 extends tz {
  constructor(
    e = new sk([
      new U(0.5, 0.5),
      new U(-0.5, 0.5),
      new U(-0.5, -0.5),
      new U(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    let i = this,
      n = [],
      r = [];
    for (let s = 0, a = e.length; s < a; s++)
      !(function (e) {
        let s, a, o, l;
        let h = [],
          c = void 0 !== t.curveSegments ? t.curveSegments : 12,
          u = void 0 !== t.steps ? t.steps : 1,
          d = void 0 !== t.depth ? t.depth : 1,
          p = void 0 === t.bevelEnabled || t.bevelEnabled,
          m = void 0 !== t.bevelThickness ? t.bevelThickness : 0.2,
          f = void 0 !== t.bevelSize ? t.bevelSize : m - 0.1,
          g = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
          _ = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
          v = t.extrudePath,
          x = void 0 !== t.UVGenerator ? t.UVGenerator : s7,
          y,
          M = !1;
        v &&
          ((y = v.getSpacedPoints(u)),
          (M = !0),
          (p = !1),
          (s = v.computeFrenetFrames(u, !1)),
          (a = new eo()),
          (o = new eo()),
          (l = new eo())),
          p || ((_ = 0), (m = 0), (f = 0), (g = 0));
        let S = e.extractPoints(c),
          b = S.shape,
          T = S.holes;
        if (!s3.isClockWise(b)) {
          b = b.reverse();
          for (let e = 0, t = T.length; e < t; e++) {
            let t = T[e];
            s3.isClockWise(t) && (T[e] = t.reverse());
          }
        }
        let E = s3.triangulateShape(b, T),
          w = b;
        for (let e = 0, t = T.length; e < t; e++) {
          let t = T[e];
          b = b.concat(t);
        }
        function A(e, t, i) {
          return (
            t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().addScaledVector(t, i)
          );
        }
        let R = b.length,
          C = E.length;
        function P(e, t, i) {
          let n, r, s;
          let a = e.x - t.x,
            o = e.y - t.y,
            l = i.x - e.x,
            h = i.y - e.y,
            c = a * a + o * o;
          if (Math.abs(a * h - o * l) > Number.EPSILON) {
            let u = Math.sqrt(c),
              d = Math.sqrt(l * l + h * h),
              p = t.x - o / u,
              m = t.y + a / u,
              f =
                ((i.x - h / d - p) * h - (i.y + l / d - m) * l) /
                (a * h - o * l),
              g = (n = p + a * f - e.x) * n + (r = m + o * f - e.y) * r;
            if (g <= 2) return new U(n, r);
            s = Math.sqrt(g / 2);
          } else {
            let e = !1;
            a > Number.EPSILON
              ? l > Number.EPSILON && (e = !0)
              : a < -Number.EPSILON
              ? l < -Number.EPSILON && (e = !0)
              : Math.sign(o) === Math.sign(h) && (e = !0),
              e
                ? ((n = -o), (r = a), (s = Math.sqrt(c)))
                : ((n = a), (r = o), (s = Math.sqrt(c / 2)));
          }
          return new U(n / s, r / s);
        }
        let L = [];
        for (
          let e = 0, t = w.length, i = t - 1, n = e + 1;
          e < t;
          e++, i++, n++
        )
          i === t && (i = 0), n === t && (n = 0), (L[e] = P(w[e], w[i], w[n]));
        let N = [],
          I,
          D = L.concat();
        for (let e = 0, t = T.length; e < t; e++) {
          let t = T[e];
          I = [];
          for (
            let e = 0, i = t.length, n = i - 1, r = e + 1;
            e < i;
            e++, n++, r++
          )
            n === i && (n = 0),
              r === i && (r = 0),
              (I[e] = P(t[e], t[n], t[r]));
          N.push(I), (D = D.concat(I));
        }
        for (let e = 0; e < _; e++) {
          let t = e / _,
            i = m * Math.cos((t * Math.PI) / 2),
            n = f * Math.sin((t * Math.PI) / 2) + g;
          for (let e = 0, t = w.length; e < t; e++) {
            let t = A(w[e], L[e], n);
            F(t.x, t.y, -i);
          }
          for (let e = 0, t = T.length; e < t; e++) {
            let t = T[e];
            I = N[e];
            for (let e = 0, r = t.length; e < r; e++) {
              let r = A(t[e], I[e], n);
              F(r.x, r.y, -i);
            }
          }
        }
        let O = f + g;
        for (let e = 0; e < R; e++) {
          let t = p ? A(b[e], D[e], O) : b[e];
          M
            ? (o.copy(s.normals[0]).multiplyScalar(t.x),
              a.copy(s.binormals[0]).multiplyScalar(t.y),
              l.copy(y[0]).add(o).add(a),
              F(l.x, l.y, l.z))
            : F(t.x, t.y, 0);
        }
        for (let e = 1; e <= u; e++)
          for (let t = 0; t < R; t++) {
            let i = p ? A(b[t], D[t], O) : b[t];
            M
              ? (o.copy(s.normals[e]).multiplyScalar(i.x),
                a.copy(s.binormals[e]).multiplyScalar(i.y),
                l.copy(y[e]).add(o).add(a),
                F(l.x, l.y, l.z))
              : F(i.x, i.y, (d / u) * e);
          }
        for (let e = _ - 1; e >= 0; e--) {
          let t = e / _,
            i = m * Math.cos((t * Math.PI) / 2),
            n = f * Math.sin((t * Math.PI) / 2) + g;
          for (let e = 0, t = w.length; e < t; e++) {
            let t = A(w[e], L[e], n);
            F(t.x, t.y, d + i);
          }
          for (let e = 0, t = T.length; e < t; e++) {
            let t = T[e];
            I = N[e];
            for (let e = 0, r = t.length; e < r; e++) {
              let r = A(t[e], I[e], n);
              M ? F(r.x, r.y + y[u - 1].y, y[u - 1].x + i) : F(r.x, r.y, d + i);
            }
          }
        }
        function z(e, t) {
          let r = e.length;
          for (; --r >= 0; ) {
            let s = r,
              a = r - 1;
            a < 0 && (a = e.length - 1);
            for (let e = 0, r = u + 2 * _; e < r; e++) {
              let r = R * e,
                o = R * (e + 1);
              !(function (e, t, r, s) {
                k(e), k(t), k(s), k(t), k(r), k(s);
                let a = n.length / 3,
                  o = x.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                H(o[0]), H(o[1]), H(o[3]), H(o[1]), H(o[2]), H(o[3]);
              })(t + s + r, t + a + r, t + a + o, t + s + o);
            }
          }
        }
        function F(e, t, i) {
          h.push(e), h.push(t), h.push(i);
        }
        function B(e, t, r) {
          k(e), k(t), k(r);
          let s = n.length / 3,
            a = x.generateTopUV(i, n, s - 3, s - 2, s - 1);
          H(a[0]), H(a[1]), H(a[2]);
        }
        function k(e) {
          n.push(h[3 * e + 0]), n.push(h[3 * e + 1]), n.push(h[3 * e + 2]);
        }
        function H(e) {
          r.push(e.x), r.push(e.y);
        }
        (function () {
          let e = n.length / 3;
          if (p) {
            let e = 0 * R;
            for (let t = 0; t < C; t++) {
              let i = E[t];
              B(i[2] + e, i[1] + e, i[0] + e);
            }
            e = R * (u + 2 * _);
            for (let t = 0; t < C; t++) {
              let i = E[t];
              B(i[0] + e, i[1] + e, i[2] + e);
            }
          } else {
            for (let e = 0; e < C; e++) {
              let t = E[e];
              B(t[2], t[1], t[0]);
            }
            for (let e = 0; e < C; e++) {
              let t = E[e];
              B(t[0] + R * u, t[1] + R * u, t[2] + R * u);
            }
          }
          i.addGroup(e, n.length / 3 - e, 0);
        })(),
          (function () {
            let e = n.length / 3,
              t = 0;
            z(w, 0), (t += w.length);
            for (let e = 0, i = T.length; e < i; e++) {
              let i = T[e];
              z(i, t), (t += i.length);
            }
            i.addGroup(e, n.length / 3 - e, 1);
          })();
      })(e[s]);
    this.setAttribute("position", new tC(n, 3)),
      this.setAttribute("uv", new tC(r, 2)),
      this.computeVertexNormals();
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (function (e, t, i) {
      if (((i.shapes = []), Array.isArray(e)))
        for (let t = 0, n = e.length; t < n; t++) {
          let n = e[t];
          i.shapes.push(n.uuid);
        }
      else i.shapes.push(e.uuid);
      return (
        (i.options = Object.assign({}, t)),
        void 0 !== t.extrudePath &&
          (i.options.extrudePath = t.extrudePath.toJSON()),
        i
      );
    })(this.parameters.shapes, this.parameters.options, e);
  }
  static fromJSON(e, t) {
    let i = [];
    for (let n = 0, r = e.shapes.length; n < r; n++) {
      let r = t[e.shapes[n]];
      i.push(r);
    }
    let n = e.options.extrudePath;
    return (
      void 0 !== n && (e.options.extrudePath = new sP[n.type]().fromJSON(n)),
      new s6(i, e.options)
    );
  }
}
const s7 = {
  generateTopUV: function (e, t, i, n, r) {
    let s = t[3 * i],
      a = t[3 * i + 1],
      o = t[3 * n],
      l = t[3 * n + 1],
      h = t[3 * r],
      c = t[3 * r + 1];
    return [new U(s, a), new U(o, l), new U(h, c)];
  },
  generateSideWallUV: function (e, t, i, n, r, s) {
    let a = t[3 * i],
      o = t[3 * i + 1],
      l = t[3 * i + 2],
      h = t[3 * n],
      c = t[3 * n + 1],
      u = t[3 * n + 2],
      d = t[3 * r],
      p = t[3 * r + 1],
      m = t[3 * r + 2],
      f = t[3 * s],
      g = t[3 * s + 1],
      _ = t[3 * s + 2];
    return Math.abs(o - c) < Math.abs(a - h)
      ? [new U(a, 1 - l), new U(h, 1 - u), new U(d, 1 - m), new U(f, 1 - _)]
      : [new U(o, 1 - l), new U(c, 1 - u), new U(p, 1 - m), new U(g, 1 - _)];
  },
};
class s8 extends sF {
  constructor(e = 1, t = 0) {
    let i = (1 + Math.sqrt(5)) / 2;
    super(
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      e,
      t
    ),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new s8(e.radius, e.detail);
  }
}
class s9 extends sF {
  constructor(e = 1, t = 0) {
    super(
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      e,
      t
    ),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new s9(e.radius, e.detail);
  }
}
class ae extends tz {
  constructor(e = 0.5, t = 1, i = 32, n = 1, r = 0, s = 2 * Math.PI) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: n,
        thetaStart: r,
        thetaLength: s,
      }),
      (i = Math.max(3, i));
    let a = [],
      o = [],
      l = [],
      h = [],
      c = e,
      u = (t - e) / (n = Math.max(1, n)),
      d = new eo(),
      p = new U();
    for (let e = 0; e <= n; e++) {
      for (let e = 0; e <= i; e++) {
        let n = r + (e / i) * s;
        (d.x = c * Math.cos(n)),
          (d.y = c * Math.sin(n)),
          o.push(d.x, d.y, d.z),
          l.push(0, 0, 1),
          (p.x = (d.x / t + 1) / 2),
          (p.y = (d.y / t + 1) / 2),
          h.push(p.x, p.y);
      }
      c += u;
    }
    for (let e = 0; e < n; e++) {
      let t = e * (i + 1);
      for (let e = 0; e < i; e++) {
        let n = e + t,
          r = n + i + 1,
          s = n + i + 2,
          o = n + 1;
        a.push(n, r, o), a.push(r, s, o);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new tC(o, 3)),
      this.setAttribute("normal", new tC(l, 3)),
      this.setAttribute("uv", new tC(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ae(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class at extends tz {
  constructor(
    e = new sk([new U(0, 0.5), new U(-0.5, -0.5), new U(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    let i = [],
      n = [],
      r = [],
      s = [],
      a = 0,
      o = 0;
    if (!1 === Array.isArray(e)) l(e);
    else
      for (let t = 0; t < e.length; t++)
        l(e[t]), this.addGroup(a, o, t), (a += o), (o = 0);
    function l(e) {
      let a = n.length / 3,
        l = e.extractPoints(t),
        h = l.shape,
        c = l.holes;
      !1 === s3.isClockWise(h) && (h = h.reverse());
      for (let e = 0, t = c.length; e < t; e++) {
        let t = c[e];
        !0 === s3.isClockWise(t) && (c[e] = t.reverse());
      }
      let u = s3.triangulateShape(h, c);
      for (let e = 0, t = c.length; e < t; e++) {
        let t = c[e];
        h = h.concat(t);
      }
      for (let e = 0, t = h.length; e < t; e++) {
        let t = h[e];
        n.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y);
      }
      for (let e = 0, t = u.length; e < t; e++) {
        let t = u[e],
          n = t[0] + a,
          r = t[1] + a,
          s = t[2] + a;
        i.push(n, r, s), (o += 3);
      }
    }
    this.setIndex(i),
      this.setAttribute("position", new tC(n, 3)),
      this.setAttribute("normal", new tC(r, 3)),
      this.setAttribute("uv", new tC(s, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (function (e, t) {
      if (((t.shapes = []), Array.isArray(e)))
        for (let i = 0, n = e.length; i < n; i++) {
          let n = e[i];
          t.shapes.push(n.uuid);
        }
      else t.shapes.push(e.uuid);
      return t;
    })(this.parameters.shapes, e);
  }
  static fromJSON(e, t) {
    let i = [];
    for (let n = 0, r = e.shapes.length; n < r; n++) {
      let r = t[e.shapes[n]];
      i.push(r);
    }
    return new at(i, e.curveSegments);
  }
}
class ai extends tz {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    n = 0,
    r = 2 * Math.PI,
    s = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: s,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    let o = Math.min(s + a, Math.PI),
      l = 0,
      h = [],
      c = new eo(),
      u = new eo(),
      d = [],
      p = [],
      m = [],
      f = [];
    for (let d = 0; d <= i; d++) {
      let g = [],
        _ = d / i,
        v = 0;
      0 === d && 0 === s
        ? (v = 0.5 / t)
        : d === i && o === Math.PI && (v = -0.5 / t);
      for (let i = 0; i <= t; i++) {
        let o = i / t;
        (c.x = -e * Math.cos(n + o * r) * Math.sin(s + _ * a)),
          (c.y = e * Math.cos(s + _ * a)),
          (c.z = e * Math.sin(n + o * r) * Math.sin(s + _ * a)),
          p.push(c.x, c.y, c.z),
          u.copy(c).normalize(),
          m.push(u.x, u.y, u.z),
          f.push(o + v, 1 - _),
          g.push(l++);
      }
      h.push(g);
    }
    for (let e = 0; e < i; e++)
      for (let n = 0; n < t; n++) {
        let t = h[e][n + 1],
          r = h[e][n],
          a = h[e + 1][n],
          l = h[e + 1][n + 1];
        (0 !== e || s > 0) && d.push(t, r, l),
          (e !== i - 1 || o < Math.PI) && d.push(r, a, l);
      }
    this.setIndex(d),
      this.setAttribute("position", new tC(p, 3)),
      this.setAttribute("normal", new tC(m, 3)),
      this.setAttribute("uv", new tC(f, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ai(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class an extends sF {
  constructor(e = 1, t = 0) {
    super(
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      e,
      t
    ),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new an(e.radius, e.detail);
  }
}
class ar extends tz {
  constructor(e = 1, t = 0.4, i = 12, n = 48, r = 2 * Math.PI) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: n,
        arc: r,
      }),
      (i = Math.floor(i)),
      (n = Math.floor(n));
    let s = [],
      a = [],
      o = [],
      l = [],
      h = new eo(),
      c = new eo(),
      u = new eo();
    for (let s = 0; s <= i; s++)
      for (let d = 0; d <= n; d++) {
        let p = (d / n) * r,
          m = (s / i) * Math.PI * 2;
        (c.x = (e + t * Math.cos(m)) * Math.cos(p)),
          (c.y = (e + t * Math.cos(m)) * Math.sin(p)),
          (c.z = t * Math.sin(m)),
          a.push(c.x, c.y, c.z),
          (h.x = e * Math.cos(p)),
          (h.y = e * Math.sin(p)),
          u.subVectors(c, h).normalize(),
          o.push(u.x, u.y, u.z),
          l.push(d / n),
          l.push(s / i);
      }
    for (let e = 1; e <= i; e++)
      for (let t = 1; t <= n; t++) {
        let i = (n + 1) * e + t - 1,
          r = (n + 1) * (e - 1) + t - 1,
          a = (n + 1) * (e - 1) + t,
          o = (n + 1) * e + t;
        s.push(i, r, o), s.push(r, a, o);
      }
    this.setIndex(s),
      this.setAttribute("position", new tC(a, 3)),
      this.setAttribute("normal", new tC(o, 3)),
      this.setAttribute("uv", new tC(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ar(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class as extends tz {
  constructor(e = 1, t = 0.4, i = 64, n = 8, r = 2, s = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: n,
        p: r,
        q: s,
      }),
      (i = Math.floor(i)),
      (n = Math.floor(n));
    let a = [],
      o = [],
      l = [],
      h = [],
      c = new eo(),
      u = new eo(),
      d = new eo(),
      p = new eo(),
      m = new eo(),
      f = new eo(),
      g = new eo();
    for (let a = 0; a <= i; ++a) {
      let v = (a / i) * r * Math.PI * 2;
      _(v, r, s, e, d),
        _(v + 0.01, r, s, e, p),
        f.subVectors(p, d),
        g.addVectors(p, d),
        m.crossVectors(f, g),
        g.crossVectors(m, f),
        m.normalize(),
        g.normalize();
      for (let e = 0; e <= n; ++e) {
        let r = (e / n) * Math.PI * 2,
          s = -t * Math.cos(r),
          p = t * Math.sin(r);
        (c.x = d.x + (s * g.x + p * m.x)),
          (c.y = d.y + (s * g.y + p * m.y)),
          (c.z = d.z + (s * g.z + p * m.z)),
          o.push(c.x, c.y, c.z),
          u.subVectors(c, d).normalize(),
          l.push(u.x, u.y, u.z),
          h.push(a / i),
          h.push(e / n);
      }
    }
    for (let e = 1; e <= i; e++)
      for (let t = 1; t <= n; t++) {
        let i = (n + 1) * (e - 1) + (t - 1),
          r = (n + 1) * e + (t - 1),
          s = (n + 1) * e + t,
          o = (n + 1) * (e - 1) + t;
        a.push(i, r, o), a.push(r, s, o);
      }
    function _(e, t, i, n, r) {
      let s = (i / t) * e,
        a = Math.cos(s);
      (r.x = n * (2 + a) * 0.5 * Math.cos(e)),
        (r.y = n * (2 + a) * Math.sin(e) * 0.5),
        (r.z = n * Math.sin(s) * 0.5);
    }
    this.setIndex(a),
      this.setAttribute("position", new tC(o, 3)),
      this.setAttribute("normal", new tC(l, 3)),
      this.setAttribute("uv", new tC(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new as(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class aa extends tz {
  constructor(
    e = new sR(new eo(-1, -1, 0), new eo(-1, 1, 0), new eo(1, 1, 0)),
    t = 64,
    i = 1,
    n = 8,
    r = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: n,
        closed: r,
      });
    let s = e.computeFrenetFrames(t, r);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals);
    let a = new eo(),
      o = new eo(),
      l = new U(),
      h = new eo(),
      c = [],
      u = [],
      d = [],
      p = [];
    function m(r) {
      h = e.getPointAt(r / t, h);
      let l = s.normals[r],
        d = s.binormals[r];
      for (let e = 0; e <= n; e++) {
        let t = (e / n) * Math.PI * 2,
          r = Math.sin(t),
          s = -Math.cos(t);
        (o.x = s * l.x + r * d.x),
          (o.y = s * l.y + r * d.y),
          (o.z = s * l.z + r * d.z),
          o.normalize(),
          u.push(o.x, o.y, o.z),
          (a.x = h.x + i * o.x),
          (a.y = h.y + i * o.y),
          (a.z = h.z + i * o.z),
          c.push(a.x, a.y, a.z);
      }
    }
    (function () {
      for (let e = 0; e < t; e++) m(e);
      m(!1 === r ? t : 0),
        (function () {
          for (let e = 0; e <= t; e++)
            for (let i = 0; i <= n; i++)
              (l.x = e / t), (l.y = i / n), d.push(l.x, l.y);
        })(),
        (function () {
          for (let e = 1; e <= t; e++)
            for (let t = 1; t <= n; t++) {
              let i = (n + 1) * (e - 1) + (t - 1),
                r = (n + 1) * e + (t - 1),
                s = (n + 1) * e + t,
                a = (n + 1) * (e - 1) + t;
              p.push(i, r, a), p.push(r, s, a);
            }
        })();
    })(),
      this.setIndex(p),
      this.setAttribute("position", new tC(c, 3)),
      this.setAttribute("normal", new tC(u, 3)),
      this.setAttribute("uv", new tC(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new aa(
      new sP[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class ao extends tS {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new tx(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new tx(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new U(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new eq()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class al extends ao {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new U(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return P((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new tx(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new tx(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new tx(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function ah(e, t, i) {
  return e && (i || e.constructor !== t)
    ? "number" == typeof t.BYTES_PER_ELEMENT
      ? new t(e)
      : Array.prototype.slice.call(e)
    : e;
}
function ac(e, t, i) {
  let n = e.length,
    r = new e.constructor(n);
  for (let s = 0, a = 0; a !== n; ++s) {
    let n = i[s] * t;
    for (let i = 0; i !== t; ++i) r[a++] = e[n + i];
  }
  return r;
}
function au(e, t, i, n) {
  let r = 1,
    s = e[0];
  for (; void 0 !== s && void 0 === s[n]; ) s = e[r++];
  if (void 0 === s) return;
  let a = s[n];
  if (void 0 !== a) {
    if (Array.isArray(a))
      do
        void 0 !== (a = s[n]) && (t.push(s.time), i.push.apply(i, a)),
          (s = e[r++]);
      while (void 0 !== s);
    else if (void 0 !== a.toArray)
      do
        void 0 !== (a = s[n]) && (t.push(s.time), a.toArray(i, i.length)),
          (s = e[r++]);
      while (void 0 !== s);
    else
      do void 0 !== (a = s[n]) && (t.push(s.time), i.push(a)), (s = e[r++]);
      while (void 0 !== s);
  }
}
class ad {
  constructor(e, t, i, n) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== n ? n : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    let t = this.parameterPositions,
      i = this._cachedIndex,
      n = t[i],
      r = t[i - 1];
    e: {
      t: {
        let s;
        i: {
          n: if (!(e < n)) {
            for (let s = i + 2; ; ) {
              if (void 0 === n) {
                if (e < r) break n;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === s) break;
              if (((r = n), e < (n = t[++i]))) break t;
            }
            s = t.length;
            break i;
          }
          if (!(e >= r)) {
            let a = t[1];
            e < a && ((i = 2), (r = a));
            for (let s = i - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === s) break;
              if (((n = r), e >= (r = t[--i - 1]))) break t;
            }
            (s = i), (i = 0);
            break i;
          }
          break e;
        }
        for (; i < s; ) {
          let n = (i + s) >>> 1;
          e < t[n] ? (s = n) : (i = n + 1);
        }
        if (((n = t[i]), void 0 === (r = t[i - 1])))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (void 0 === n)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, r, n);
    }
    return this.interpolate_(i, r, e, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    let t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      r = e * n;
    for (let e = 0; e !== n; ++e) t[e] = i[r + e];
    return t;
  }
  interpolate_() {
    throw Error("call to abstract method");
  }
  intervalChanged_() {}
}
class ap extends ad {
  constructor(e, t, i, n) {
    super(e, t, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
  }
  intervalChanged_(e, t, i) {
    let n = this.parameterPositions,
      r = e - 2,
      s = e + 1,
      a = n[r],
      o = n[s];
    if (void 0 === a)
      switch (this.getSettings_().endingStart) {
        case 2401:
          (r = e), (a = 2 * t - i);
          break;
        case 2402:
          (r = n.length - 2), (a = t + n[r] - n[r + 1]);
          break;
        default:
          (r = e), (a = i);
      }
    if (void 0 === o)
      switch (this.getSettings_().endingEnd) {
        case 2401:
          (s = e), (o = 2 * i - t);
          break;
        case 2402:
          (s = 1), (o = i + n[1] - n[0]);
          break;
        default:
          (s = e - 1), (o = t);
      }
    let l = (i - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = l / (t - a)),
      (this._weightNext = l / (o - i)),
      (this._offsetPrev = r * h),
      (this._offsetNext = s * h);
  }
  interpolate_(e, t, i, n) {
    let r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = e * a,
      l = o - a,
      h = this._offsetPrev,
      c = this._offsetNext,
      u = this._weightPrev,
      d = this._weightNext,
      p = (i - t) / (n - t),
      m = p * p,
      f = m * p,
      g = -u * f + 2 * u * m - u * p,
      _ = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
      v = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
      x = d * f - d * m;
    for (let e = 0; e !== a; ++e)
      r[e] = g * s[h + e] + _ * s[l + e] + v * s[o + e] + x * s[c + e];
    return r;
  }
}
class am extends ad {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    let r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = e * a,
      l = o - a,
      h = (i - t) / (n - t),
      c = 1 - h;
    for (let e = 0; e !== a; ++e) r[e] = s[l + e] * c + s[o + e] * h;
    return r;
  }
}
class af extends ad {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ag {
  constructor(e, t, i, n) {
    if (void 0 === e)
      throw Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t || 0 === t.length)
      throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = ah(t, this.TimeBufferType)),
      (this.values = ah(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation);
  }
  static toJSON(e) {
    let t;
    let i = e.constructor;
    if (i.toJSON !== this.toJSON) t = i.toJSON(e);
    else {
      t = {
        name: e.name,
        times: ah(e.times, Array),
        values: ah(e.values, Array),
      };
      let i = e.getInterpolation();
      i !== e.DefaultInterpolation && (t.interpolation = i);
    }
    return (t.type = e.ValueTypeName), t;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new af(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new am(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new ap(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case 2300:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        t = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === t) {
      let t =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (void 0 === this.createInterpolant) {
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw Error(t);
      }
      return console.warn("THREE.KeyframeTrack:", t), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (0 !== e) {
      let t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (1 !== e) {
      let t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    let i = this.times,
      n = i.length,
      r = 0,
      s = n - 1;
    for (; r !== n && i[r] < e; ) ++r;
    for (; -1 !== s && i[s] > t; ) --s;
    if ((++s, 0 !== r || s !== n)) {
      r >= s && (r = (s = Math.max(s, 1)) - 1);
      let e = this.getValueSize();
      (this.times = i.slice(r, s)),
        (this.values = this.values.slice(r * e, s * e));
    }
    return this;
  }
  validate() {
    let e = !0,
      t = this.getValueSize();
    t - Math.floor(t) != 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    let i = this.times,
      n = this.values,
      r = i.length;
    0 === r &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let s = null;
    for (let t = 0; t !== r; t++) {
      let n = i[t];
      if ("number" == typeof n && isNaN(n)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          t,
          n
        ),
          (e = !1);
        break;
      }
      if (null !== s && s > n) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, t, n, s),
          (e = !1);
        break;
      }
      s = n;
    }
    if (void 0 !== n && ArrayBuffer.isView(n) && !(n instanceof DataView))
      for (let t = 0, i = n.length; t !== i; ++t) {
        let i = n[t];
        if (isNaN(i)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            t,
            i
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    let e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      n = 2302 === this.getInterpolation(),
      r = e.length - 1,
      s = 1;
    for (let a = 1; a < r; ++a) {
      let r = !1,
        o = e[a];
      if (o !== e[a + 1] && (1 !== a || o !== e[0])) {
        if (n) r = !0;
        else {
          let e = a * i,
            n = e - i,
            s = e + i;
          for (let a = 0; a !== i; ++a) {
            let i = t[e + a];
            if (i !== t[n + a] || i !== t[s + a]) {
              r = !0;
              break;
            }
          }
        }
      }
      if (r) {
        if (a !== s) {
          e[s] = e[a];
          let n = a * i,
            r = s * i;
          for (let e = 0; e !== i; ++e) t[r + e] = t[n + e];
        }
        ++s;
      }
    }
    if (r > 0) {
      e[s] = e[r];
      for (let e = r * i, n = s * i, a = 0; a !== i; ++a) t[n + a] = t[e + a];
      ++s;
    }
    return (
      s !== e.length
        ? ((this.times = e.slice(0, s)), (this.values = t.slice(0, s * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    let e = this.times.slice(),
      t = this.values.slice(),
      i = new this.constructor(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
(ag.prototype.TimeBufferType = Float32Array),
  (ag.prototype.ValueBufferType = Float32Array),
  (ag.prototype.DefaultInterpolation = 2301);
class a_ extends ag {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
(a_.prototype.ValueTypeName = "bool"),
  (a_.prototype.ValueBufferType = Array),
  (a_.prototype.DefaultInterpolation = 2300),
  (a_.prototype.InterpolantFactoryMethodLinear = void 0),
  (a_.prototype.InterpolantFactoryMethodSmooth = void 0);
class av extends ag {}
av.prototype.ValueTypeName = "color";
class ax extends ag {}
ax.prototype.ValueTypeName = "number";
class ay extends ad {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    let r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = (i - t) / (n - t),
      l = e * a;
    for (let e = l + a; l !== e; l += 4) ea.slerpFlat(r, 0, s, l - a, s, l, o);
    return r;
  }
}
class aM extends ag {
  InterpolantFactoryMethodLinear(e) {
    return new ay(this.times, this.values, this.getValueSize(), e);
  }
}
(aM.prototype.ValueTypeName = "quaternion"),
  (aM.prototype.InterpolantFactoryMethodSmooth = void 0);
class aS extends ag {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
(aS.prototype.ValueTypeName = "string"),
  (aS.prototype.ValueBufferType = Array),
  (aS.prototype.DefaultInterpolation = 2300),
  (aS.prototype.InterpolantFactoryMethodLinear = void 0),
  (aS.prototype.InterpolantFactoryMethodSmooth = void 0);
class ab extends ag {}
ab.prototype.ValueTypeName = "vector";
class aT {
  constructor(e = "", t = -1, i = [], n = 2500) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = n),
      (this.uuid = C()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    let t = [],
      i = e.tracks,
      n = 1 / (e.fps || 1);
    for (let e = 0, r = i.length; e !== r; ++e)
      t.push(
        (function (e) {
          if (void 0 === e.type)
            throw Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          let t = (function (e) {
            switch (e.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return ax;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return ab;
              case "color":
                return av;
              case "quaternion":
                return aM;
              case "bool":
              case "boolean":
                return a_;
              case "string":
                return aS;
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
          })(e.type);
          if (void 0 === e.times) {
            let t = [],
              i = [];
            au(e.keys, t, i, "value"), (e.times = t), (e.values = i);
          }
          return void 0 !== t.parse
            ? t.parse(e)
            : new t(e.name, e.times, e.values, e.interpolation);
        })(i[e]).scale(n)
      );
    let r = new this(e.name, e.duration, t, e.blendMode);
    return (r.uuid = e.uuid), r;
  }
  static toJSON(e) {
    let t = [],
      i = e.tracks,
      n = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let e = 0, n = i.length; e !== n; ++e) t.push(ag.toJSON(i[e]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    let r = t.length,
      s = [];
    for (let e = 0; e < r; e++) {
      let a = [],
        o = [];
      a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
      let l = (function (e) {
        let t = e.length,
          i = Array(t);
        for (let e = 0; e !== t; ++e) i[e] = e;
        return (
          i.sort(function (t, i) {
            return e[t] - e[i];
          }),
          i
        );
      })(a);
      (a = ac(a, 1, l)),
        (o = ac(o, 1, l)),
        n || 0 !== a[0] || (a.push(r), o.push(o[0])),
        s.push(
          new ax(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / i)
        );
    }
    return new this(e, -1, s);
  }
  static findByName(e, t) {
    let i = e;
    Array.isArray(e) ||
      (i = (e.geometry && e.geometry.animations) || e.animations);
    for (let e = 0; e < i.length; e++) if (i[e].name === t) return i[e];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    let n = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let t = 0, i = e.length; t < i; t++) {
      let i = e[t],
        s = i.name.match(r);
      if (s && s.length > 1) {
        let e = s[1],
          t = n[e];
        t || (n[e] = t = []), t.push(i);
      }
    }
    let s = [];
    for (let e in n) s.push(this.CreateFromMorphTargetSequence(e, n[e], t, i));
    return s;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    let i = function (e, t, i, n, r) {
        if (0 !== i.length) {
          let s = [],
            a = [];
          au(i, s, a, n), 0 !== s.length && r.push(new e(t, s, a));
        }
      },
      n = [],
      r = e.name || "default",
      s = e.fps || 30,
      a = e.blendMode,
      o = e.length || -1,
      l = e.hierarchy || [];
    for (let e = 0; e < l.length; e++) {
      let r = l[e].keys;
      if (r && 0 !== r.length) {
        if (r[0].morphTargets) {
          let e;
          let t = {};
          for (e = 0; e < r.length; e++)
            if (r[e].morphTargets)
              for (let i = 0; i < r[e].morphTargets.length; i++)
                t[r[e].morphTargets[i]] = -1;
          for (let i in t) {
            let t = [],
              s = [];
            for (let n = 0; n !== r[e].morphTargets.length; ++n) {
              let n = r[e];
              t.push(n.time), s.push(n.morphTarget === i ? 1 : 0);
            }
            n.push(new ax(".morphTargetInfluence[" + i + "]", t, s));
          }
          o = t.length * s;
        } else {
          let s = ".bones[" + t[e].name + "]";
          i(ab, s + ".position", r, "pos", n),
            i(aM, s + ".quaternion", r, "rot", n),
            i(ab, s + ".scale", r, "scl", n);
        }
      }
    }
    return 0 === n.length ? null : new this(r, o, n, a);
  }
  resetDuration() {
    let e = this.tracks,
      t = 0;
    for (let i = 0, n = e.length; i !== n; ++i) {
      let e = this.tracks[i];
      t = Math.max(t, e.times[e.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    let e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
const aE = {
    enabled: !1,
    files: {},
    add: function (e, t) {
      !1 !== this.enabled && (this.files[e] = t);
    },
    get: function (e) {
      if (!1 !== this.enabled) return this.files[e];
    },
    remove: function (e) {
      delete this.files[e];
    },
    clear: function () {
      this.files = {};
    },
  },
  aw = new (class {
    constructor(e, t, i) {
      let n;
      let r = this,
        s = !1,
        a = 0,
        o = 0,
        l = [];
      (this.onStart = void 0),
        (this.onLoad = e),
        (this.onProgress = t),
        (this.onError = i),
        (this.itemStart = function (e) {
          o++, !1 === s && void 0 !== r.onStart && r.onStart(e, a, o), (s = !0);
        }),
        (this.itemEnd = function (e) {
          a++,
            void 0 !== r.onProgress && r.onProgress(e, a, o),
            a === o && ((s = !1), void 0 !== r.onLoad && r.onLoad());
        }),
        (this.itemError = function (e) {
          void 0 !== r.onError && r.onError(e);
        }),
        (this.resolveURL = function (e) {
          return n ? n(e) : e;
        }),
        (this.setURLModifier = function (e) {
          return (n = e), this;
        }),
        (this.addHandler = function (e, t) {
          return l.push(e, t), this;
        }),
        (this.removeHandler = function (e) {
          let t = l.indexOf(e);
          return -1 !== t && l.splice(t, 2), this;
        }),
        (this.getHandler = function (e) {
          for (let t = 0, i = l.length; t < i; t += 2) {
            let i = l[t],
              n = l[t + 1];
            if ((i.global && (i.lastIndex = 0), i.test(e))) return n;
          }
          return null;
        });
    }
  })();
class aA {
  constructor(e) {
    (this.manager = void 0 !== e ? e : aw),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    let i = this;
    return new Promise(function (n, r) {
      i.load(e, n, t, r);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
aA.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const aR = {};
class aC extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class aP extends aA {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    void 0 === e && (e = ""),
      void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    let r = aE.get(e);
    if (void 0 !== r)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(r), this.manager.itemEnd(e);
        }, 0),
        r
      );
    if (void 0 !== aR[e]) {
      aR[e].push({ onLoad: t, onProgress: i, onError: n });
      return;
    }
    (aR[e] = []), aR[e].push({ onLoad: t, onProgress: i, onError: n });
    let s = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      o = this.responseType;
    fetch(s)
      .then((t) => {
        if (200 === t.status || 0 === t.status) {
          if (
            (0 === t.status &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            "undefined" == typeof ReadableStream ||
              void 0 === t.body ||
              void 0 === t.body.getReader)
          )
            return t;
          let i = aR[e],
            n = t.body.getReader(),
            r = t.headers.get("X-File-Size") || t.headers.get("Content-Length"),
            s = r ? parseInt(r) : 0,
            a = 0 !== s,
            o = 0,
            l = new ReadableStream({
              start(e) {
                (function t() {
                  n.read().then(
                    ({ done: n, value: r }) => {
                      if (n) e.close();
                      else {
                        o += r.byteLength;
                        let n = new ProgressEvent("progress", {
                          lengthComputable: a,
                          loaded: o,
                          total: s,
                        });
                        for (let e = 0, t = i.length; e < t; e++) {
                          let t = i[e];
                          t.onProgress && t.onProgress(n);
                        }
                        e.enqueue(r), t();
                      }
                    },
                    (t) => {
                      e.error(t);
                    }
                  );
                })();
              },
            });
          return new Response(l);
        }
        throw new aC(
          `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,
          t
        );
      })
      .then((e) => {
        switch (o) {
          case "arraybuffer":
            return e.arrayBuffer();
          case "blob":
            return e.blob();
          case "document":
            return e.text().then((e) => new DOMParser().parseFromString(e, a));
          case "json":
            return e.json();
          default:
            if (void 0 === a) return e.text();
            {
              let t = /charset="?([^;"\s]*)"?/i.exec(a),
                i = t && t[1] ? t[1].toLowerCase() : void 0,
                n = new TextDecoder(i);
              return e.arrayBuffer().then((e) => n.decode(e));
            }
        }
      })
      .then((t) => {
        aE.add(e, t);
        let i = aR[e];
        delete aR[e];
        for (let e = 0, n = i.length; e < n; e++) {
          let n = i[e];
          n.onLoad && n.onLoad(t);
        }
      })
      .catch((t) => {
        let i = aR[e];
        if (void 0 === i) throw (this.manager.itemError(e), t);
        delete aR[e];
        for (let e = 0, n = i.length; e < n; e++) {
          let n = i[e];
          n.onError && n.onError(t);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class aL extends aA {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    let r = this,
      s = aE.get(e);
    if (void 0 !== s)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(s), r.manager.itemEnd(e);
        }, 0),
        s
      );
    let a = k("img");
    function o() {
      h(), aE.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function l(t) {
      h(), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", o, !1),
        a.removeEventListener("error", l, !1);
    }
    return (
      a.addEventListener("load", o, !1),
      a.addEventListener("error", l, !1),
      "data:" !== e.slice(0, 5) &&
        void 0 !== this.crossOrigin &&
        (a.crossOrigin = this.crossOrigin),
      r.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class aN extends aA {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    let r = new et(),
      s = new aL(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (e) {
          (r.image = e), (r.needsUpdate = !0), void 0 !== t && t(r);
        },
        i,
        n
      ),
      r
    );
  }
}
class aI extends te {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new tx(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    let t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      void 0 !== this.groundColor &&
        (t.object.groundColor = this.groundColor.getHex()),
      void 0 !== this.distance && (t.object.distance = this.distance),
      void 0 !== this.angle && (t.object.angle = this.angle),
      void 0 !== this.decay && (t.object.decay = this.decay),
      void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
      void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
      void 0 !== this.target && (t.object.target = this.target.uuid),
      t
    );
  }
}
const aD = new ez(),
  aO = new eo(),
  aU = new eo();
class az {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new U(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ez()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new il()),
      (this._frameExtents = new U(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new ei(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    let t = this.camera,
      i = this.matrix;
    aO.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(aO),
      aU.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(aU),
      t.updateMatrixWorld(),
      aD.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(aD),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(aD);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    let e = {};
    return (
      1 !== this.intensity && (e.intensity = this.intensity),
      0 !== this.bias && (e.bias = this.bias),
      0 !== this.normalBias && (e.normalBias = this.normalBias),
      1 !== this.radius && (e.radius = this.radius),
      (512 !== this.mapSize.x || 512 !== this.mapSize.y) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class aF extends az {
  constructor() {
    super(new t7(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    let t = this.camera,
      i = 2 * R * e.angle * this.focus,
      n = this.mapSize.width / this.mapSize.height,
      r = e.distance || t.far;
    (i !== t.fov || n !== t.aspect || r !== t.far) &&
      ((t.fov = i), (t.aspect = n), (t.far = r), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class aB extends aI {
  constructor(e, t, i = 0, n = Math.PI / 3, r = 0, s = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(te.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new te()),
      (this.distance = i),
      (this.angle = n),
      (this.penumbra = r),
      (this.decay = s),
      (this.map = null),
      (this.shadow = new aF());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const ak = new ez(),
  aH = new eo(),
  aV = new eo();
class aG extends az {
  constructor() {
    super(new t7(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new U(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new ei(2, 1, 1, 1),
        new ei(0, 1, 1, 1),
        new ei(3, 1, 1, 1),
        new ei(1, 1, 1, 1),
        new ei(3, 0, 1, 1),
        new ei(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new eo(1, 0, 0),
        new eo(-1, 0, 0),
        new eo(0, 0, 1),
        new eo(0, 0, -1),
        new eo(0, 1, 0),
        new eo(0, -1, 0),
      ]),
      (this._cubeUps = [
        new eo(0, 1, 0),
        new eo(0, 1, 0),
        new eo(0, 1, 0),
        new eo(0, 1, 0),
        new eo(0, 0, 1),
        new eo(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    let i = this.camera,
      n = this.matrix,
      r = e.distance || i.far;
    r !== i.far && ((i.far = r), i.updateProjectionMatrix()),
      aH.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(aH),
      aV.copy(i.position),
      aV.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(aV),
      i.updateMatrixWorld(),
      n.makeTranslation(-aH.x, -aH.y, -aH.z),
      ak.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(ak);
  }
}
class aW extends aI {
  constructor(e, t, i = 0, n = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = n),
      (this.shadow = new aG());
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class aX extends az {
  constructor() {
    super(new iE(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class aj extends aI {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(te.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new te()),
      (this.shadow = new aX());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class aq extends aI {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class aJ {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      "undefined" != typeof TextDecoder)
    )
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch (e) {
      return t;
    }
  }
  static extractUrlBase(e) {
    let t = e.lastIndexOf("/");
    return -1 === t ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return "string" != typeof e || "" === e
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
          /^data:.*,.*$/i.test(e) ||
          /^blob:.*$/i.test(e))
      ? e
      : t + e;
  }
}
class aY extends aA {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      "undefined" == typeof createImageBitmap &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      "undefined" == typeof fetch &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, n) {
    void 0 === e && (e = ""),
      void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    let r = this,
      s = aE.get(e);
    if (void 0 !== s) {
      if ((r.manager.itemStart(e), s.then)) {
        s.then((i) => {
          t && t(i), r.manager.itemEnd(e);
        }).catch((e) => {
          n && n(e);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(s), r.manager.itemEnd(e);
        }, 0),
        s
      );
    }
    let a = {};
    (a.credentials =
      "anonymous" === this.crossOrigin ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    let o = fetch(e, a)
      .then(function (e) {
        return e.blob();
      })
      .then(function (e) {
        return createImageBitmap(
          e,
          Object.assign(r.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (i) {
        return aE.add(e, i), t && t(i), r.manager.itemEnd(e), i;
      })
      .catch(function (t) {
        n && n(t), aE.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
      });
    aE.add(e, o), r.manager.itemStart(e);
  }
}
const aK = "\\[\\]\\.:\\/",
  aZ = RegExp("[" + aK + "]", "g"),
  aQ = "[^" + aK + "]",
  a$ = "[^" + aK.replace("\\.", "") + "]",
  a0 = /((?:WC+[\/:])*)/.source.replace("WC", aQ),
  a1 = RegExp(
    "^" +
      a0 +
      /(WCOD+)?/.source.replace("WCOD", a$) +
      /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", aQ) +
      /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", aQ) +
      "$"
  ),
  a2 = ["material", "materials", "bones", "map"];
class a3 {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || a3.parseTrackName(t)),
      (this.node = a3.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new a3.Composite(e, t, i)
      : new a3(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(aZ, "");
  }
  static parseTrackName(e) {
    let t = a1.exec(e);
    if (null === t)
      throw Error("PropertyBinding: Cannot parse trackName: " + e);
    let i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (void 0 !== n && -1 !== n) {
      let e = i.nodeName.substring(n + 1);
      -1 !== a2.indexOf(e) &&
        ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = e));
    }
    if (null === i.propertyName || 0 === i.propertyName.length)
      throw Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      void 0 === t ||
      "" === t ||
      "." === t ||
      -1 === t ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      let i = e.skeleton.getBoneByName(t);
      if (void 0 !== i) return i;
    }
    if (e.children) {
      let i = function (e) {
          for (let n = 0; n < e.length; n++) {
            let r = e[n];
            if (r.name === t || r.uuid === t) return r;
            let s = i(r.children);
            if (s) return s;
          }
          return null;
        },
        n = i(e.children);
      if (n) return n;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    let i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    let i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    let i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    let i = this.resolvedProperty;
    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node,
      t = this.parsedPath,
      i = t.objectName,
      n = t.propertyName,
      r = t.propertyIndex;
    if (
      (e || ((e = a3.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (i) {
      let n = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let t = 0; t < e.length; t++)
            if (e[t].name === n) {
              n = t;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (void 0 === e[i]) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (void 0 !== n) {
        if (void 0 === e[n]) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[n];
      }
    }
    let s = e[n];
    if (void 0 === s) {
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          t.nodeName +
          "." +
          n +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      void 0 !== e.needsUpdate
        ? (a = this.Versioning.NeedsUpdate)
        : void 0 !== e.matrixWorldNeedsUpdate &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let o = this.BindingType.Direct;
    if (void 0 !== r) {
      if ("morphTargetInfluences" === n) {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        void 0 !== e.morphTargetDictionary[r] &&
          (r = e.morphTargetDictionary[r]);
      }
      (o = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = r);
    } else
      void 0 !== s.fromArray && void 0 !== s.toArray
        ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = n);
    (this.getValue = this.GetterByBindingType[o]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
(a3.Composite = class {
  constructor(e, t, i) {
    let n = i || a3.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
  }
  getValue(e, t) {
    this.bind();
    let i = this._targetGroup.nCachedObjects_,
      n = this._bindings[i];
    void 0 !== n && n.getValue(e, t);
  }
  setValue(e, t) {
    let i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    let e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    let e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}),
  (a3.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
  }),
  (a3.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2,
  }),
  (a3.prototype.GetterByBindingType = [
    a3.prototype._getValue_direct,
    a3.prototype._getValue_array,
    a3.prototype._getValue_arrayElement,
    a3.prototype._getValue_toArray,
  ]),
  (a3.prototype.SetterByBindingTypeAndVersioning = [
    [
      a3.prototype._setValue_direct,
      a3.prototype._setValue_direct_setNeedsUpdate,
      a3.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
      a3.prototype._setValue_array,
      a3.prototype._setValue_array_setNeedsUpdate,
      a3.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
      a3.prototype._setValue_arrayElement,
      a3.prototype._setValue_arrayElement_setNeedsUpdate,
      a3.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
      a3.prototype._setValue_fromArray,
      a3.prototype._setValue_fromArray_setNeedsUpdate,
      a3.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
  ]),
  new Float32Array(1);
const a5 = new ez();
function a4(e, t) {
  return e.distance - t.distance;
}
function a6(e, t, i, n) {
  let r = !0;
  if (
    (e.layers.test(t.layers) && !1 === e.raycast(t, i) && (r = !1),
    !0 === r && !0 === n)
  ) {
    let n = e.children;
    for (let e = 0, r = n.length; e < r; e++) a6(n[e], t, i, !0);
  }
}
class a7 {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(P(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class a8 extends T {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
"undefined" != typeof __THREE_DEVTOOLS__ &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: "169" } })
  ),
  "undefined" != typeof window &&
    (window.__THREE__
      ? console.warn("WARNING: Multiple instances of Three.js being imported.")
      : (window.__THREE__ = "169"));
class a9 {
  constructor(e, t, i, n, r) {
    (this.sender = e),
      (this.receiver = t),
      (this.message = i),
      (this.delay = n),
      (this.data = r);
  }
  toJSON() {
    return {
      type: this.constructor.name,
      sender: this.sender.uuid,
      receiver: this.receiver.uuid,
      message: this.message,
      delay: this.delay,
      data: this.data,
    };
  }
  fromJSON(e) {
    return (
      (this.sender = e.sender),
      (this.receiver = e.receiver),
      (this.message = e.message),
      (this.delay = e.delay),
      (this.data = e.data),
      this
    );
  }
  resolveReferences(e) {
    return (
      (this.sender = e.get(this.sender)),
      (this.receiver = e.get(this.receiver)),
      this
    );
  }
}
class oe {
  static setLevel(e) {
    ot = e;
  }
  static log(...e) {
    ot <= oe.LEVEL.LOG && console.log(...e);
  }
  static warn(...e) {
    ot <= oe.LEVEL.WARN && console.warn(...e);
  }
  static error(...e) {
    ot <= oe.LEVEL.ERROR && console.error(...e);
  }
}
oe.LEVEL = Object.freeze({ LOG: 0, WARN: 1, ERROR: 2, SILENT: 3 });
let ot = oe.LEVEL.WARN;
class oi {
  constructor() {
    this.delayedTelegrams = [];
  }
  deliver(e) {
    let t = e.receiver;
    return (
      !1 === t.handleMessage(e) &&
        oe.warn(
          "YUKA.MessageDispatcher: Message not handled by receiver: %o",
          t
        ),
      this
    );
  }
  dispatch(e, t, i, n, r) {
    let s = new a9(e, t, i, n, r);
    return n <= 0 ? this.deliver(s) : this.delayedTelegrams.push(s), this;
  }
  dispatchDelayedMessages(e) {
    let t = this.delayedTelegrams.length;
    for (; t--; ) {
      let i = this.delayedTelegrams[t];
      (i.delay -= e),
        i.delay <= 0 && (this.deliver(i), this.delayedTelegrams.pop());
    }
    return this;
  }
  clear() {
    return (this.delayedTelegrams.length = 0), this;
  }
  toJSON() {
    let e = { type: this.constructor.name, delayedTelegrams: [] };
    for (let t = 0, i = this.delayedTelegrams.length; t < i; t++) {
      let i = this.delayedTelegrams[t];
      e.delayedTelegrams.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    this.clear();
    let t = e.delayedTelegrams;
    for (let e = 0, i = t.length; e < i; e++) {
      let i = t[e],
        n = new a9().fromJSON(i);
      this.delayedTelegrams.push(n);
    }
    return this;
  }
  resolveReferences(e) {
    let t = this.delayedTelegrams;
    for (let i = 0, n = t.length; i < n; i++) t[i].resolveReferences(e);
    return this;
  }
}
const on = [];
for (let e = 0; e < 256; e++) on[e] = (e < 16 ? "0" : "") + e.toString(16);
class or {
  static area(e, t, i) {
    return (i.x - e.x) * (t.z - e.z) - (t.x - e.x) * (i.z - e.z);
  }
  static argmax(e) {
    let t = Math.max(...e),
      i = [];
    for (let n = 0, r = e.length; n < r; n++) e[n] === t && i.push(n);
    return i;
  }
  static choice(e, t = null) {
    let i = Math.random();
    if (null === t) return e[Math.floor(Math.random() * e.length)];
    {
      let n = 0,
        r = e.map((e, i) => (n += t[i])).findIndex((e) => e >= i);
      return e[r];
    }
  }
  static clamp(e, t, i) {
    return Math.max(t, Math.min(i, e));
  }
  static generateUUID() {
    let e = (4294967295 * Math.random()) | 0,
      t = (4294967295 * Math.random()) | 0,
      i = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0;
    return (
      on[255 & e] +
      on[(e >> 8) & 255] +
      on[(e >> 16) & 255] +
      on[(e >> 24) & 255] +
      "-" +
      on[255 & t] +
      on[(t >> 8) & 255] +
      "-" +
      on[((t >> 16) & 15) | 64] +
      on[(t >> 24) & 255] +
      "-" +
      on[(63 & i) | 128] +
      on[(i >> 8) & 255] +
      "-" +
      on[(i >> 16) & 255] +
      on[(i >> 24) & 255] +
      on[255 & n] +
      on[(n >> 8) & 255] +
      on[(n >> 16) & 255] +
      on[(n >> 24) & 255]
    ).toUpperCase();
  }
  static randFloat(e, t) {
    return e + Math.random() * (t - e);
  }
  static randInt(e, t) {
    return e + Math.floor(Math.random() * (t - e + 1));
  }
}
class os {
  constructor(e = 0, t = 0, i = 0) {
    (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (this.x = e), (this.y = t), (this.z = i), this;
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return (this.x /= e), (this.y /= e), (this.z /= e), this;
  }
  divideVectors(e, t) {
    return (
      (this.x = e.x / t.x), (this.y = e.y / t.y), (this.z = e.z / t.z), this
    );
  }
  reflect(e) {
    return this.sub(oa.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  cross(e) {
    let t = this.x,
      i = this.y,
      n = this.z;
    return (
      (this.x = i * e.z - n * e.y),
      (this.y = n * e.x - t * e.z),
      (this.z = t * e.y - i * e.x),
      this
    );
  }
  crossVectors(e, t) {
    let i = e.x,
      n = e.y,
      r = e.z,
      s = t.x,
      a = t.y,
      o = t.z;
    return (
      (this.x = n * o - r * a),
      (this.y = r * s - i * o),
      (this.z = i * a - n * s),
      this
    );
  }
  angleTo(e) {
    let t = Math.sqrt(this.squaredLength() * e.squaredLength());
    if (0 === t) return 0;
    let i = this.dot(e) / t;
    return Math.acos(or.clamp(i, -1, 1));
  }
  length() {
    return Math.sqrt(this.squaredLength());
  }
  squaredLength() {
    return this.dot(this);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  distanceTo(e) {
    return Math.sqrt(this.squaredDistanceTo(e));
  }
  squaredDistanceTo(e) {
    let t = this.x - e.x,
      i = this.y - e.y,
      n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  applyMatrix4(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.elements,
      s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
    return (
      (this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s),
      (this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s),
      (this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s),
      this
    );
  }
  applyRotation(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.x,
      s = e.y,
      a = e.z,
      o = e.w,
      l = o * t + s * n - a * i,
      h = o * i + a * t - r * n,
      c = o * n + r * i - s * t,
      u = -r * t - s * i - a * n;
    return (
      (this.x = l * o + -(u * r) + -(h * a) - -(c * s)),
      (this.y = h * o + -(u * s) + -(c * r) - -(l * a)),
      (this.z = c * o + -(u * a) + -(l * s) - -(h * r)),
      this
    );
  }
  extractPositionFromMatrix(e) {
    let t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  transformDirection(e) {
    let t = this.x,
      i = this.y,
      n = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[4] * i + r[8] * n),
      (this.y = r[1] * t + r[5] * i + r[9] * n),
      (this.z = r[2] * t + r[6] * i + r[10] * n),
      this.normalize()
    );
  }
  fromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  fromMatrix4Column(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  fromSpherical(e, t, i) {
    let n = Math.sin(t) * e;
    return (
      (this.x = n * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = n * Math.cos(i)),
      this
    );
  }
  fromArray(e, t = 0) {
    return (this.x = e[t + 0]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e, t = 0) {
    return (e[t + 0] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
}
const oa = new os(),
  oo = new os(0, 1, 0),
  ol = new os(),
  oh = new os(),
  oc = new os(),
  ou = new os(),
  od = [2, 2, 1],
  op = [1, 0, 0];
class om {
  constructor() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(e, t, i, n, r, s, a, o, l) {
    let h = this.elements;
    return (
      (h[0] = e),
      (h[3] = t),
      (h[6] = i),
      (h[1] = n),
      (h[4] = r),
      (h[7] = s),
      (h[2] = a),
      (h[5] = o),
      (h[8] = l),
      this
    );
  }
  copy(e) {
    let t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    let i = e.elements,
      n = t.elements,
      r = this.elements,
      s = i[0],
      a = i[3],
      o = i[6],
      l = i[1],
      h = i[4],
      c = i[7],
      u = i[2],
      d = i[5],
      p = i[8],
      m = n[0],
      f = n[3],
      g = n[6],
      _ = n[1],
      v = n[4],
      x = n[7],
      y = n[2],
      M = n[5],
      S = n[8];
    return (
      (r[0] = s * m + a * _ + o * y),
      (r[3] = s * f + a * v + o * M),
      (r[6] = s * g + a * x + o * S),
      (r[1] = l * m + h * _ + c * y),
      (r[4] = l * f + h * v + c * M),
      (r[7] = l * g + h * x + c * S),
      (r[2] = u * m + d * _ + p * y),
      (r[5] = u * f + d * v + p * M),
      (r[8] = u * g + d * x + p * S),
      this
    );
  }
  multiplyScalar(e) {
    let t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.fromMatrix3Column(this, 0),
      t.fromMatrix3Column(this, 1),
      i.fromMatrix3Column(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return this.set(e.x, t.x, i.x, e.y, t.y, i.y, e.z, t.z, i.z), this;
  }
  lookAt(e, t, i) {
    return (
      ol.crossVectors(i, e).normalize(),
      oh.crossVectors(oo, t).normalize(),
      0 === oh.squaredLength() &&
        (ou.copy(t).addScalar(Number.EPSILON),
        oh.crossVectors(oo, ou).normalize()),
      oc.crossVectors(t, oh).normalize(),
      of.makeBasis(oh, oc, t),
      og.makeBasis(ol, i, e),
      this.multiplyMatrices(of, og.transpose()),
      this
    );
  }
  transpose() {
    let e;
    let t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getElementIndex(e, t) {
    return 3 * e + t;
  }
  frobeniusNorm() {
    let e = this.elements,
      t = 0;
    for (let i = 0; i < 9; i++) t += e[i] * e[i];
    return Math.sqrt(t);
  }
  offDiagonalFrobeniusNorm() {
    let e = this.elements,
      t = 0;
    for (let i = 0; i < 3; i++) {
      let n = e[this.getElementIndex(od[i], op[i])];
      t += 2 * n * n;
    }
    return Math.sqrt(t);
  }
  eigenDecomposition(e) {
    let t = 0,
      i = 0;
    e.unitary.identity(), e.diagonal.copy(this);
    let n = e.unitary,
      r = e.diagonal,
      s = Number.EPSILON * r.frobeniusNorm();
    for (; i < 10 && r.offDiagonalFrobeniusNorm() > s; )
      r.shurDecomposition(of),
        og.copy(of).transpose(),
        r.multiply(of),
        r.premultiply(og),
        n.multiply(of),
        ++t > 2 && (i++, (t = 0));
    return e;
  }
  shurDecomposition(e) {
    let t = 0,
      i = 1,
      n = this.elements;
    for (let e = 0; e < 3; e++) {
      let r = Math.abs(n[this.getElementIndex(od[e], op[e])]);
      r > t && ((t = r), (i = e));
    }
    let r = 1,
      s = 0,
      a = op[i],
      o = od[i];
    if (Math.abs(n[this.getElementIndex(o, a)]) > Number.EPSILON) {
      let e;
      let t =
        (n[this.getElementIndex(o, o)] - n[this.getElementIndex(a, a)]) /
        2 /
        n[this.getElementIndex(o, a)];
      (r =
        1 /
        Math.sqrt(
          1 +
            (e =
              t < 0
                ? -1 / (-t + Math.sqrt(1 + t * t))
                : 1 / (t + Math.sqrt(1 + t * t))) *
              e
        )),
        (s = e * r);
    }
    return (
      e.identity(),
      (e.elements[this.getElementIndex(a, a)] = r),
      (e.elements[this.getElementIndex(o, o)] = r),
      (e.elements[this.getElementIndex(o, a)] = s),
      (e.elements[this.getElementIndex(a, o)] = -s),
      e
    );
  }
  fromQuaternion(e) {
    let t = this.elements,
      i = e.x,
      n = e.y,
      r = e.z,
      s = e.w,
      a = i + i,
      o = n + n,
      l = r + r,
      h = i * a,
      c = i * o,
      u = i * l,
      d = n * o,
      p = n * l,
      m = r * l,
      f = s * a,
      g = s * o,
      _ = s * l;
    return (
      (t[0] = 1 - (d + m)),
      (t[3] = c - _),
      (t[6] = u + g),
      (t[1] = c + _),
      (t[4] = 1 - (h + m)),
      (t[7] = p - f),
      (t[2] = u - g),
      (t[5] = p + f),
      (t[8] = 1 - (h + d)),
      this
    );
  }
  fromMatrix4(e) {
    let t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[4]),
      (t[4] = i[5]),
      (t[5] = i[6]),
      (t[6] = i[8]),
      (t[7] = i[9]),
      (t[8] = i[10]),
      this
    );
  }
  fromArray(e, t = 0) {
    let i = this.elements;
    for (let n = 0; n < 9; n++) i[n] = e[n + t];
    return this;
  }
  toArray(e, t = 0) {
    let i = this.elements;
    return (
      (e[t + 0] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  equals(e) {
    let t = this.elements,
      i = e.elements;
    for (let e = 0; e < 9; e++) if (t[e] !== i[e]) return !1;
    return !0;
  }
}
const of = new om(),
  og = new om(),
  o_ = new om(),
  ov = new os();
class ox {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    (this.x = e), (this.y = t), (this.z = i), (this.w = n);
  }
  set(e, t, i, n) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = n), this;
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  inverse() {
    return this.conjugate().normalize();
  }
  conjugate() {
    return (this.x *= -1), (this.y *= -1), (this.z *= -1), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  length() {
    return Math.sqrt(this.squaredLength());
  }
  squaredLength() {
    return this.dot(this);
  }
  normalize() {
    let e = this.length();
    return (
      0 === e
        ? ((this.x = 0), (this.y = 0), (this.z = 0), (this.w = 1))
        : ((e = 1 / e),
          (this.x = this.x * e),
          (this.y = this.y * e),
          (this.z = this.z * e),
          (this.w = this.w * e)),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    let i = e.x,
      n = e.y,
      r = e.z,
      s = e.w,
      a = t.x,
      o = t.y,
      l = t.z,
      h = t.w;
    return (
      (this.x = i * h + s * a + n * l - r * o),
      (this.y = n * h + s * o + r * a - i * l),
      (this.z = r * h + s * l + i * o - n * a),
      (this.w = s * h - i * a - n * o - r * l),
      this
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(or.clamp(this.dot(e), -1, 1)));
  }
  rotateTo(e, t, i = 1e-4) {
    let n = this.angleTo(e);
    return n < i || (this.slerp(e, Math.min(1, t / n)), !1);
  }
  lookAt(e, t, i) {
    o_.lookAt(e, t, i), this.fromMatrix3(o_);
  }
  slerp(e, t) {
    if (0 === t) return this;
    if (1 === t) return this.copy(e);
    let i = this.x,
      n = this.y,
      r = this.z,
      s = this.w,
      a = s * e.w + i * e.x + n * e.y + r * e.z;
    if (
      (a < 0
        ? ((this.w = -e.w),
          (this.x = -e.x),
          (this.y = -e.y),
          (this.z = -e.z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this.w = s), (this.x = i), (this.y = n), (this.z = r), this;
    let o = Math.sqrt(1 - a * a);
    if (0.001 > Math.abs(o))
      return (
        (this.w = 0.5 * (s + this.w)),
        (this.x = 0.5 * (i + this.x)),
        (this.y = 0.5 * (n + this.y)),
        (this.z = 0.5 * (r + this.z)),
        this
      );
    let l = Math.atan2(o, a),
      h = Math.sin((1 - t) * l) / o,
      c = Math.sin(t * l) / o;
    return (
      (this.w = s * h + this.w * c),
      (this.x = i * h + this.x * c),
      (this.y = n * h + this.y * c),
      (this.z = r * h + this.z * c),
      this
    );
  }
  extractRotationFromMatrix(e) {
    let t = o_.elements,
      i = e.elements,
      n = 1 / ov.fromMatrix4Column(e, 0).length(),
      r = 1 / ov.fromMatrix4Column(e, 1).length(),
      s = 1 / ov.fromMatrix4Column(e, 2).length();
    return (
      (t[0] = i[0] * n),
      (t[1] = i[1] * n),
      (t[2] = i[2] * n),
      (t[3] = i[4] * r),
      (t[4] = i[5] * r),
      (t[5] = i[6] * r),
      (t[6] = i[8] * s),
      (t[7] = i[9] * s),
      (t[8] = i[10] * s),
      this.fromMatrix3(o_),
      this
    );
  }
  fromEuler(e, t, i) {
    let n = Math.cos(t / 2),
      r = Math.cos(e / 2),
      s = Math.cos(i / 2),
      a = Math.sin(t / 2),
      o = Math.sin(e / 2),
      l = Math.sin(i / 2);
    return (
      (this.w = n * r * s + a * o * l),
      (this.x = n * o * s + a * r * l),
      (this.y = a * r * s - n * o * l),
      (this.z = n * r * l - a * o * s),
      this
    );
  }
  toEuler(e) {
    let t = -2 * (this.y * this.z - this.x * this.w);
    return (
      Math.abs(t) > 0.9999
        ? ((e.x = 0.5 * Math.PI * t),
          (e.y = Math.atan2(
            this.x * this.z + this.w * this.y,
            0.5 - this.x * this.x - this.y * this.y
          )),
          (e.z = 0))
        : ((e.x = Math.asin(t)),
          (e.y = Math.atan2(
            this.x * this.z + this.w * this.y,
            0.5 - this.x * this.x - this.y * this.y
          )),
          (e.z = Math.atan2(
            this.x * this.y + this.w * this.z,
            0.5 - this.x * this.x - this.z * this.z
          ))),
      e
    );
  }
  fromMatrix3(e) {
    let t = e.elements,
      i = t[0],
      n = t[3],
      r = t[6],
      s = t[1],
      a = t[4],
      o = t[7],
      l = t[2],
      h = t[5],
      c = t[8],
      u = i + a + c;
    if (u > 0) {
      let e = 0.5 / Math.sqrt(u + 1);
      (this.w = 0.25 / e),
        (this.x = (h - o) * e),
        (this.y = (r - l) * e),
        (this.z = (s - n) * e);
    } else if (i > a && i > c) {
      let e = 2 * Math.sqrt(1 + i - a - c);
      (this.w = (h - o) / e),
        (this.x = 0.25 * e),
        (this.y = (n + s) / e),
        (this.z = (r + l) / e);
    } else if (a > c) {
      let e = 2 * Math.sqrt(1 + a - i - c);
      (this.w = (r - l) / e),
        (this.x = (n + s) / e),
        (this.y = 0.25 * e),
        (this.z = (o + h) / e);
    } else {
      let e = 2 * Math.sqrt(1 + c - i - a);
      (this.w = (s - n) / e),
        (this.x = (r + l) / e),
        (this.y = (o + h) / e),
        (this.z = 0.25 * e);
    }
    return this;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t + 0]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e, t = 0) {
    return (
      (e[t + 0] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
}
class oy {
  constructor() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(e, t, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
    let g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = i),
      (g[12] = n),
      (g[1] = r),
      (g[5] = s),
      (g[9] = a),
      (g[13] = o),
      (g[2] = l),
      (g[6] = h),
      (g[10] = c),
      (g[14] = u),
      (g[3] = d),
      (g[7] = p),
      (g[11] = m),
      (g[15] = f),
      this
    );
  }
  copy(e) {
    let t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    let i = e.elements,
      n = t.elements,
      r = this.elements,
      s = i[0],
      a = i[4],
      o = i[8],
      l = i[12],
      h = i[1],
      c = i[5],
      u = i[9],
      d = i[13],
      p = i[2],
      m = i[6],
      f = i[10],
      g = i[14],
      _ = i[3],
      v = i[7],
      x = i[11],
      y = i[15],
      M = n[0],
      S = n[4],
      b = n[8],
      T = n[12],
      E = n[1],
      w = n[5],
      A = n[9],
      R = n[13],
      C = n[2],
      P = n[6],
      L = n[10],
      N = n[14],
      I = n[3],
      D = n[7],
      O = n[11],
      U = n[15];
    return (
      (r[0] = s * M + a * E + o * C + l * I),
      (r[4] = s * S + a * w + o * P + l * D),
      (r[8] = s * b + a * A + o * L + l * O),
      (r[12] = s * T + a * R + o * N + l * U),
      (r[1] = h * M + c * E + u * C + d * I),
      (r[5] = h * S + c * w + u * P + d * D),
      (r[9] = h * b + c * A + u * L + d * O),
      (r[13] = h * T + c * R + u * N + d * U),
      (r[2] = p * M + m * E + f * C + g * I),
      (r[6] = p * S + m * w + f * P + g * D),
      (r[10] = p * b + m * A + f * L + g * O),
      (r[14] = p * T + m * R + f * N + g * U),
      (r[3] = _ * M + v * E + x * C + y * I),
      (r[7] = _ * S + v * w + x * P + y * D),
      (r[11] = _ * b + v * A + x * L + y * O),
      (r[15] = _ * T + v * R + x * N + y * U),
      this
    );
  }
  multiplyScalar(e) {
    let t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.fromMatrix4Column(this, 0),
      t.fromMatrix4Column(this, 1),
      i.fromMatrix4Column(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  compose(e, t, i) {
    return this.fromQuaternion(t), this.scale(i), this.setPosition(e), this;
  }
  scale(e) {
    let t = this.elements,
      i = e.x,
      n = e.y,
      r = e.z;
    return (
      (t[0] *= i),
      (t[4] *= n),
      (t[8] *= r),
      (t[1] *= i),
      (t[5] *= n),
      (t[9] *= r),
      (t[2] *= i),
      (t[6] *= n),
      (t[10] *= r),
      (t[3] *= i),
      (t[7] *= n),
      (t[11] *= r),
      this
    );
  }
  setPosition(e) {
    let t = this.elements;
    return (t[12] = e.x), (t[13] = e.y), (t[14] = e.z), this;
  }
  transpose() {
    let e;
    let t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  getInverse(e) {
    let t = this.elements,
      i = e.elements,
      n = t[0],
      r = t[1],
      s = t[2],
      a = t[3],
      o = t[4],
      l = t[5],
      h = t[6],
      c = t[7],
      u = t[8],
      d = t[9],
      p = t[10],
      m = t[11],
      f = t[12],
      g = t[13],
      _ = t[14],
      v = t[15],
      x = d * _ * c - g * p * c + g * h * m - l * _ * m - d * h * v + l * p * v,
      y = f * p * c - u * _ * c - f * h * m + o * _ * m + u * h * v - o * p * v,
      M = u * g * c - f * d * c + f * l * m - o * g * m - u * l * v + o * d * v,
      S = f * d * h - u * g * h - f * l * p + o * g * p + u * l * _ - o * d * _,
      b = n * x + r * y + s * M + a * S;
    if (0 === b) return e.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    let T = 1 / b;
    return (
      (i[0] = x * T),
      (i[1] =
        (g * p * a -
          d * _ * a -
          g * s * m +
          r * _ * m +
          d * s * v -
          r * p * v) *
        T),
      (i[2] =
        (l * _ * a -
          g * h * a +
          g * s * c -
          r * _ * c -
          l * s * v +
          r * h * v) *
        T),
      (i[3] =
        (d * h * a -
          l * p * a -
          d * s * c +
          r * p * c +
          l * s * m -
          r * h * m) *
        T),
      (i[4] = y * T),
      (i[5] =
        (u * _ * a -
          f * p * a +
          f * s * m -
          n * _ * m -
          u * s * v +
          n * p * v) *
        T),
      (i[6] =
        (f * h * a -
          o * _ * a -
          f * s * c +
          n * _ * c +
          o * s * v -
          n * h * v) *
        T),
      (i[7] =
        (o * p * a -
          u * h * a +
          u * s * c -
          n * p * c -
          o * s * m +
          n * h * m) *
        T),
      (i[8] = M * T),
      (i[9] =
        (f * d * a -
          u * g * a -
          f * r * m +
          n * g * m +
          u * r * v -
          n * d * v) *
        T),
      (i[10] =
        (o * g * a -
          f * l * a +
          f * r * c -
          n * g * c -
          o * r * v +
          n * l * v) *
        T),
      (i[11] =
        (u * l * a -
          o * d * a -
          u * r * c +
          n * d * c +
          o * r * m -
          n * l * m) *
        T),
      (i[12] = S * T),
      (i[13] =
        (u * g * s -
          f * d * s +
          f * r * p -
          n * g * p -
          u * r * _ +
          n * d * _) *
        T),
      (i[14] =
        (f * l * s -
          o * g * s -
          f * r * h +
          n * g * h +
          o * r * _ -
          n * l * _) *
        T),
      (i[15] =
        (o * d * s -
          u * l * s +
          u * r * h -
          n * d * h -
          o * r * p +
          n * l * p) *
        T),
      e
    );
  }
  getMaxScale() {
    let e = this.elements;
    return Math.sqrt(
      Math.max(
        e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
      )
    );
  }
  fromQuaternion(e) {
    let t = this.elements,
      i = e.x,
      n = e.y,
      r = e.z,
      s = e.w,
      a = i + i,
      o = n + n,
      l = r + r,
      h = i * a,
      c = i * o,
      u = i * l,
      d = n * o,
      p = n * l,
      m = r * l,
      f = s * a,
      g = s * o,
      _ = s * l;
    return (
      (t[0] = 1 - (d + m)),
      (t[4] = c - _),
      (t[8] = u + g),
      (t[1] = c + _),
      (t[5] = 1 - (h + m)),
      (t[9] = p - f),
      (t[2] = u - g),
      (t[6] = p + f),
      (t[10] = 1 - (h + d)),
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  fromMatrix3(e) {
    let t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = 0),
      (t[4] = i[3]),
      (t[5] = i[4]),
      (t[6] = i[5]),
      (t[7] = 0),
      (t[8] = i[6]),
      (t[9] = i[7]),
      (t[10] = i[8]),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  fromArray(e, t = 0) {
    let i = this.elements;
    for (let n = 0; n < 16; n++) i[n] = e[n + t];
    return this;
  }
  toArray(e, t = 0) {
    let i = this.elements;
    return (
      (e[t + 0] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
  equals(e) {
    let t = this.elements,
      i = e.elements;
    for (let e = 0; e < 16; e++) if (t[e] !== i[e]) return !1;
    return !0;
  }
}
const oM = new ox(),
  oS = new os(),
  ob = new os(),
  oT = new ox();
class oE {
  constructor() {
    (this.name = ""),
      (this.active = !0),
      (this.children = []),
      (this.parent = null),
      (this.neighbors = []),
      (this.neighborhoodRadius = 1),
      (this.updateNeighborhood = !1),
      (this.position = new os()),
      (this.rotation = new ox()),
      (this.scale = new os(1, 1, 1)),
      (this.forward = new os(0, 0, 1)),
      (this.up = new os(0, 1, 0)),
      (this.boundingRadius = 0),
      (this.maxTurnRate = Math.PI),
      (this.canActivateTrigger = !0),
      (this.manager = null),
      (this._localMatrix = new oy()),
      (this._worldMatrix = new oy()),
      (this._cache = {
        position: new os(),
        rotation: new ox(),
        scale: new os(1, 1, 1),
      }),
      (this._renderComponent = null),
      (this._renderComponentCallback = null),
      (this._started = !1),
      (this._uuid = null),
      (this._worldMatrixDirty = !1);
  }
  get worldMatrix() {
    return this._updateWorldMatrix(), this._worldMatrix;
  }
  get uuid() {
    return null === this._uuid && (this._uuid = or.generateUUID()), this._uuid;
  }
  start() {
    return this;
  }
  update() {
    return this;
  }
  add(e) {
    return (
      null !== e.parent && e.parent.remove(e),
      this.children.push(e),
      (e.parent = this),
      this
    );
  }
  remove(e) {
    let t = this.children.indexOf(e);
    return this.children.splice(t, 1), (e.parent = null), this;
  }
  getDirection(e) {
    return e.copy(this.forward).applyRotation(this.rotation).normalize();
  }
  lookAt(e) {
    let t = this.parent;
    return (
      null !== t
        ? (this.getWorldPosition(ob),
          oS.subVectors(e, ob).normalize(),
          this.rotation.lookAt(this.forward, oS, this.up),
          oT.extractRotationFromMatrix(t.worldMatrix).inverse(),
          this.rotation.premultiply(oT))
        : (oS.subVectors(e, this.position).normalize(),
          this.rotation.lookAt(this.forward, oS, this.up)),
      this
    );
  }
  rotateTo(e, t, i = 1e-4) {
    let n = this.parent;
    return (
      null !== n
        ? (this.getWorldPosition(ob),
          oS.subVectors(e, ob).normalize(),
          oM.lookAt(this.forward, oS, this.up),
          oT.extractRotationFromMatrix(n.worldMatrix).inverse(),
          oM.premultiply(oT))
        : (oS.subVectors(e, this.position).normalize(),
          oM.lookAt(this.forward, oS, this.up)),
      this.rotation.rotateTo(oM, this.maxTurnRate * t, i)
    );
  }
  getWorldDirection(e) {
    return (
      oT.extractRotationFromMatrix(this.worldMatrix),
      e.copy(this.forward).applyRotation(oT).normalize()
    );
  }
  getWorldPosition(e) {
    return e.extractPositionFromMatrix(this.worldMatrix);
  }
  setRenderComponent(e, t) {
    return (
      (this._renderComponent = e), (this._renderComponentCallback = t), this
    );
  }
  handleMessage() {
    return !1;
  }
  lineOfSightTest() {
    return null;
  }
  sendMessage(e, t, i = 0, n = null) {
    return (
      null !== this.manager
        ? this.manager.sendMessage(this, e, t, i, n)
        : oe.error(
            "YUKA.GameEntity: The game entity must be added to a manager in order to send a message."
          ),
      this
    );
  }
  toJSON() {
    return {
      type: this.constructor.name,
      uuid: this.uuid,
      name: this.name,
      active: this.active,
      children: ow(this.children),
      parent: null !== this.parent ? this.parent.uuid : null,
      neighbors: ow(this.neighbors),
      neighborhoodRadius: this.neighborhoodRadius,
      updateNeighborhood: this.updateNeighborhood,
      position: this.position.toArray([]),
      rotation: this.rotation.toArray([]),
      scale: this.scale.toArray([]),
      forward: this.forward.toArray([]),
      up: this.up.toArray([]),
      boundingRadius: this.boundingRadius,
      maxTurnRate: this.maxTurnRate,
      canActivateTrigger: this.canActivateTrigger,
      worldMatrix: this.worldMatrix.toArray([]),
      _localMatrix: this._localMatrix.toArray([]),
      _cache: {
        position: this._cache.position.toArray([]),
        rotation: this._cache.rotation.toArray([]),
        scale: this._cache.scale.toArray([]),
      },
      _started: this._started,
    };
  }
  fromJSON(e) {
    return (
      (this.name = e.name),
      (this.active = e.active),
      (this.neighborhoodRadius = e.neighborhoodRadius),
      (this.updateNeighborhood = e.updateNeighborhood),
      this.position.fromArray(e.position),
      this.rotation.fromArray(e.rotation),
      this.scale.fromArray(e.scale),
      this.forward.fromArray(e.forward),
      this.up.fromArray(e.up),
      (this.boundingRadius = e.boundingRadius),
      (this.maxTurnRate = e.maxTurnRate),
      (this.canActivateTrigger = e.canActivateTrigger),
      (this.children = e.children.slice()),
      (this.neighbors = e.neighbors.slice()),
      (this.parent = e.parent),
      this._localMatrix.fromArray(e._localMatrix),
      this._worldMatrix.fromArray(e.worldMatrix),
      this._cache.position.fromArray(e._cache.position),
      this._cache.rotation.fromArray(e._cache.rotation),
      this._cache.scale.fromArray(e._cache.scale),
      (this._started = e._started),
      (this._uuid = e.uuid),
      this
    );
  }
  resolveReferences(e) {
    let t = this.neighbors;
    for (let i = 0, n = t.length; i < n; i++) t[i] = e.get(t[i]);
    let i = this.children;
    for (let t = 0, n = i.length; t < n; t++) i[t] = e.get(i[t]);
    return (this.parent = e.get(this.parent) || null), this;
  }
  _updateMatrix() {
    let e = this._cache;
    (e.position.equals(this.position) &&
      e.rotation.equals(this.rotation) &&
      e.scale.equals(this.scale)) ||
      (this._localMatrix.compose(this.position, this.rotation, this.scale),
      e.position.copy(this.position),
      e.rotation.copy(this.rotation),
      e.scale.copy(this.scale),
      (this._worldMatrixDirty = !0));
  }
  _updateWorldMatrix() {
    let e = this.parent;
    if (
      (null !== e && e._updateWorldMatrix(),
      this._updateMatrix(),
      !0 === this._worldMatrixDirty)
    ) {
      null === e
        ? this._worldMatrix.copy(this._localMatrix)
        : this._worldMatrix.multiplyMatrices(
            this.parent._worldMatrix,
            this._localMatrix
          ),
        (this._worldMatrixDirty = !1);
      let t = this.children;
      for (let e = 0, i = t.length; e < i; e++) t[e]._worldMatrixDirty = !0;
    }
  }
  updateWorldMatrix() {
    return (
      console.warn(
        "GameEntity: .updateWorldMatrix() has been removed. World matrices are automatically updated on access."
      ),
      this
    );
  }
}
function ow(e) {
  let t = [];
  for (let i = 0, n = e.length; i < n; i++) t.push(e[i].uuid);
  return t;
}
const oA = new os(),
  oR = new os();
class oC extends oE {
  constructor() {
    super(),
      (this.velocity = new os()),
      (this.maxSpeed = 1),
      (this.updateOrientation = !0);
  }
  update(e) {
    return (
      this.getSpeedSquared() > this.maxSpeed * this.maxSpeed &&
        (this.velocity.normalize(),
        this.velocity.multiplyScalar(this.maxSpeed)),
      oA.copy(this.velocity).multiplyScalar(e),
      oR.copy(this.position).add(oA),
      this.updateOrientation &&
        this.getSpeedSquared() > 1e-8 &&
        this.lookAt(oR),
      this.position.copy(oR),
      this
    );
  }
  getSpeed() {
    return this.velocity.length();
  }
  getSpeedSquared() {
    return this.velocity.squaredLength();
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.velocity = this.velocity.toArray([])),
      (e.maxSpeed = this.maxSpeed),
      (e.updateOrientation = this.updateOrientation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.velocity.fromArray(e.velocity),
      (this.maxSpeed = e.maxSpeed),
      (this.updateOrientation = e.updateOrientation),
      this
    );
  }
}
class oP {
  constructor() {
    (this.active = !0), (this.weight = 1);
  }
  calculate() {}
  toJSON() {
    return {
      type: this.constructor.name,
      active: this.active,
      weight: this.weight,
    };
  }
  fromJSON(e) {
    return (this.active = e.active), (this.weight = e.weight), this;
  }
  resolveReferences() {}
}
const oL = new os(),
  oN = new os();
class oI extends oP {
  constructor() {
    super();
  }
  calculate(e, t) {
    oL.set(0, 0, 0);
    let i = e.neighbors;
    for (let e = 0, t = i.length; e < t; e++) i[e].getDirection(oN), oL.add(oN);
    return (
      i.length > 0 &&
        (oL.divideScalar(i.length), e.getDirection(oN), t.subVectors(oL, oN)),
      t
    );
  }
}
const oD = new os(),
  oO = new os();
class oU extends oP {
  constructor(e = new os(), t = 3, i = 0) {
    super(), (this.target = e), (this.deceleration = t), (this.tolerance = i);
  }
  calculate(e, t) {
    let i = this.target,
      n = this.deceleration;
    oO.subVectors(i, e.position);
    let r = oO.length();
    if (r > this.tolerance) {
      let t = r / n;
      (t = Math.min(t, e.maxSpeed)), oD.copy(oO).multiplyScalar(t / r);
    } else oD.set(0, 0, 0);
    return t.subVectors(oD, e.velocity);
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.target = this.target.toArray([])),
      (e.deceleration = this.deceleration),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.target.fromArray(e.target),
      (this.deceleration = e.deceleration),
      this
    );
  }
}
const oz = new os();
class oF extends oP {
  constructor(e = new os()) {
    super(), (this.target = e);
  }
  calculate(e, t) {
    let i = this.target;
    return (
      oz.subVectors(i, e.position).normalize(),
      oz.multiplyScalar(e.maxSpeed),
      t.subVectors(oz, e.velocity)
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (e.target = this.target.toArray([])), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.target.fromArray(e.target), this;
  }
}
const oB = new os();
class ok extends oP {
  constructor() {
    super(), (this._seek = new oF());
  }
  calculate(e, t) {
    oB.set(0, 0, 0);
    let i = e.neighbors;
    for (let e = 0, t = i.length; e < t; e++) {
      let t = i[e];
      oB.add(t.position);
    }
    return (
      i.length > 0 &&
        (oB.divideScalar(i.length),
        (this._seek.target = oB),
        this._seek.calculate(e, t),
        t.normalize()),
      t
    );
  }
}
const oH = new os();
class oV extends oP {
  constructor(e = new os(), t = 10) {
    super(), (this.target = e), (this.panicDistance = t);
  }
  calculate(e, t) {
    let i = this.target;
    return (
      e.position.squaredDistanceTo(i) <=
        this.panicDistance * this.panicDistance &&
        (oH.subVectors(e.position, i).normalize(),
        0 === oH.squaredLength() && oH.set(0, 0, 1),
        oH.multiplyScalar(e.maxSpeed),
        t.subVectors(oH, e.velocity)),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.target = this.target.toArray([])),
      (e.panicDistance = this.panicDistance),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.target.fromArray(e.target),
      (this.panicDistance = e.panicDistance),
      this
    );
  }
}
const oG = new os(),
  oW = new os(),
  oX = new os();
class oj extends oP {
  constructor(e = null, t = 10, i = 1) {
    super(),
      (this.pursuer = e),
      (this.panicDistance = t),
      (this.predictionFactor = i),
      (this._flee = new oV());
  }
  calculate(e, t) {
    let i = this.pursuer;
    oG.subVectors(i.position, e.position);
    let n = oG.length() / (e.maxSpeed + i.getSpeed());
    return (
      (n *= this.predictionFactor),
      oW.copy(i.velocity).multiplyScalar(n),
      oX.addVectors(i.position, oW),
      (this._flee.target = oX),
      (this._flee.panicDistance = this.panicDistance),
      this._flee.calculate(e, t),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.pursuer = this.pursuer ? this.pursuer.uuid : null),
      (e.panicDistance = this.panicDistance),
      (e.predictionFactor = this.predictionFactor),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.pursuer = e.pursuer),
      (this.panicDistance = e.panicDistance),
      (this.predictionFactor = e.predictionFactor),
      this
    );
  }
  resolveReferences(e) {
    this.pursuer = e.get(this.pursuer) || null;
  }
}
class oq {
  constructor() {
    (this.loop = !1), (this._waypoints = []), (this._index = 0);
  }
  add(e) {
    return this._waypoints.push(e), this;
  }
  clear() {
    return (this._waypoints.length = 0), (this._index = 0), this;
  }
  current() {
    return this._waypoints[this._index];
  }
  finished() {
    let e = this._waypoints.length - 1;
    return !0 !== this.loop && this._index === e;
  }
  advance() {
    return (
      this._index++,
      this._index === this._waypoints.length &&
        (!0 === this.loop ? (this._index = 0) : this._index--),
      this
    );
  }
  toJSON() {
    let e = {
        type: this.constructor.name,
        loop: this.loop,
        _waypoints: [],
        _index: this._index,
      },
      t = this._waypoints;
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      e._waypoints.push(n.toArray([]));
    }
    return e;
  }
  fromJSON(e) {
    (this.loop = e.loop), (this._index = e._index);
    let t = e._waypoints;
    for (let e = 0, i = t.length; e < i; e++) {
      let i = t[e];
      this._waypoints.push(new os().fromArray(i));
    }
    return this;
  }
}
class oJ extends oP {
  constructor(e = new oq(), t = 1) {
    super(),
      (this.path = e),
      (this.nextWaypointDistance = t),
      (this._arrive = new oU()),
      (this._seek = new oF());
  }
  calculate(e, t) {
    let i = this.path;
    i.current().squaredDistanceTo(e.position) <
      this.nextWaypointDistance * this.nextWaypointDistance && i.advance();
    let n = i.current();
    return (
      !0 === i.finished()
        ? ((this._arrive.target = n), this._arrive.calculate(e, t))
        : ((this._seek.target = n), this._seek.calculate(e, t)),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.path = this.path.toJSON()),
      (e.nextWaypointDistance = this.nextWaypointDistance),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.path.fromJSON(e.path),
      (this.nextWaypointDistance = e.nextWaypointDistance),
      this
    );
  }
}
const oY = new os(),
  oK = new os(),
  oZ = new os(),
  oQ = new os();
class o$ extends oP {
  constructor(e = null, t = null, i = 3) {
    super(),
      (this.entity1 = e),
      (this.entity2 = t),
      (this.deceleration = i),
      (this._arrive = new oU());
  }
  calculate(e, t) {
    let i = this.entity1,
      n = this.entity2;
    oY.addVectors(i.position, n.position).multiplyScalar(0.5);
    let r = e.position.distanceTo(oY) / e.maxSpeed;
    return (
      oK.copy(i.velocity).multiplyScalar(r),
      oZ.addVectors(i.position, oK),
      oK.copy(n.velocity).multiplyScalar(r),
      oQ.addVectors(n.position, oK),
      oY.addVectors(oZ, oQ).multiplyScalar(0.5),
      (this._arrive.deceleration = this.deceleration),
      (this._arrive.target = oY),
      this._arrive.calculate(e, t),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.entity1 = this.entity1 ? this.entity1.uuid : null),
      (e.entity2 = this.entity2 ? this.entity2.uuid : null),
      (e.deceleration = this.deceleration),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.entity1 = e.entity1),
      (this.entity2 = e.entity2),
      (this.deceleration = e.deceleration),
      this
    );
  }
  resolveReferences(e) {
    (this.entity1 = e.get(this.entity1) || null),
      (this.entity2 = e.get(this.entity2) || null);
  }
}
const o0 = new os(),
  o1 = new os(),
  o2 = new os(),
  o3 = [
    new os(),
    new os(),
    new os(),
    new os(),
    new os(),
    new os(),
    new os(),
    new os(),
  ];
class o5 {
  constructor(e = new os(), t = new os()) {
    (this.min = e), (this.max = t);
  }
  set(e, t) {
    return (this.min = e), (this.max = t), this;
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max), t;
  }
  containsPoint(e) {
    return (
      !(e.x < this.min.x) &&
      !(e.x > this.max.x) &&
      !(e.y < this.min.y) &&
      !(e.y > this.max.y) &&
      !(e.z < this.min.z) &&
      !(e.z > this.max.z)
    );
  }
  expand(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  getCenter(e) {
    return e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return e.subVectors(this.max, this.min);
  }
  intersectsAABB(e) {
    return (
      !(e.max.x < this.min.x) &&
      !(e.min.x > this.max.x) &&
      !(e.max.y < this.min.y) &&
      !(e.min.y > this.max.y) &&
      !(e.max.z < this.min.z) &&
      !(e.min.z > this.max.z)
    );
  }
  intersectsBoundingSphere(e) {
    return (
      this.clampPoint(e.center, o0),
      o0.squaredDistanceTo(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t = e.normal;
    this.getCenter(o1), o2.subVectors(this.max, o1);
    let i = o2.x * Math.abs(t.x) + o2.y * Math.abs(t.y) + o2.z * Math.abs(t.z);
    return Math.abs(e.distanceToPoint(o1)) <= i;
  }
  getNormalFromSurfacePoint(e, t) {
    let i;
    t.set(0, 0, 0);
    let n = 1 / 0;
    return (
      this.getCenter(o1),
      this.getSize(o2),
      o0.copy(e).sub(o1),
      (i = Math.abs(o2.x - Math.abs(o0.x))) < n &&
        ((n = i), t.set(1 * Math.sign(o0.x), 0, 0)),
      (i = Math.abs(o2.y - Math.abs(o0.y))) < n &&
        ((n = i), t.set(0, 1 * Math.sign(o0.y), 0)),
      (i = Math.abs(o2.z - Math.abs(o0.z))) < n &&
        t.set(0, 0, 1 * Math.sign(o0.z)),
      t
    );
  }
  fromCenterAndSize(e, t) {
    return (
      o0.copy(t).multiplyScalar(0.5),
      this.min.copy(e).sub(o0),
      this.max.copy(e).add(o0),
      this
    );
  }
  fromPoints(e) {
    this.min.set(1 / 0, 1 / 0, 1 / 0), this.max.set(-1 / 0, -1 / 0, -1 / 0);
    for (let t = 0, i = e.length; t < i; t++) this.expand(e[t]);
    return this;
  }
  applyMatrix4(e) {
    let t = this.min,
      i = this.max;
    return (
      o3[0].set(t.x, t.y, t.z).applyMatrix4(e),
      o3[1].set(t.x, t.y, i.z).applyMatrix4(e),
      o3[2].set(t.x, i.y, t.z).applyMatrix4(e),
      o3[3].set(t.x, i.y, i.z).applyMatrix4(e),
      o3[4].set(i.x, t.y, t.z).applyMatrix4(e),
      o3[5].set(i.x, t.y, i.z).applyMatrix4(e),
      o3[6].set(i.x, i.y, t.z).applyMatrix4(e),
      o3[7].set(i.x, i.y, i.z).applyMatrix4(e),
      this.fromPoints(o3)
    );
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  toJSON() {
    return {
      type: this.constructor.name,
      min: this.min.toArray([]),
      max: this.max.toArray([]),
    };
  }
  fromJSON(e) {
    return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
  }
}
const o4 = new o5();
class o6 {
  constructor(e = new os(), t = 0) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return (this.center = e), (this.radius = t), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  clampPoint(e, t) {
    return (
      t.copy(e),
      this.center.squaredDistanceTo(e) > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  containsPoint(e) {
    return e.squaredDistanceTo(this.center) <= this.radius * this.radius;
  }
  intersectsBoundingSphere(e) {
    let t = this.radius + e.radius;
    return e.center.squaredDistanceTo(this.center) <= t * t;
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  getNormalFromSurfacePoint(e, t) {
    return t.subVectors(e, this.center).normalize();
  }
  fromPoints(e) {
    return (
      o4.fromPoints(e),
      o4.getCenter(this.center),
      (this.radius = this.center.distanceTo(o4.max)),
      this
    );
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScale()),
      this
    );
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  toJSON() {
    return {
      type: this.constructor.name,
      center: this.center.toArray([]),
      radius: this.radius,
    };
  }
  fromJSON(e) {
    return this.center.fromArray(e.center), (this.radius = e.radius), this;
  }
}
const o7 = new os(),
  o8 = new os(),
  o9 = new os(),
  le = new os(),
  lt = new os(),
  li = new oy(),
  ln = new oy(),
  lr = new o5();
class ls {
  constructor(e = new os(), t = new os()) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return (this.origin = e), (this.direction = t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  intersectBoundingSphere(e, t) {
    o7.subVectors(e.center, this.origin);
    let i = o7.dot(this.direction),
      n = o7.dot(o7) - i * i,
      r = e.radius * e.radius;
    if (n > r) return null;
    let s = Math.sqrt(r - n),
      a = i - s,
      o = i + s;
    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
  }
  intersectsBoundingSphere(e) {
    let t;
    let i = new os(),
      n = i.subVectors(e.center, this.origin).dot(this.direction);
    return (
      n < 0
        ? (t = this.origin.squaredDistanceTo(e.center))
        : (i.copy(this.direction).multiplyScalar(n).add(this.origin),
          (t = i.squaredDistanceTo(e.center))),
      t <= e.radius * e.radius
    );
  }
  intersectAABB(e, t) {
    let i, n, r, s, a, o;
    let l = 1 / this.direction.x,
      h = 1 / this.direction.y,
      c = 1 / this.direction.z,
      u = this.origin;
    return (l >= 0
      ? ((i = (e.min.x - u.x) * l), (n = (e.max.x - u.x) * l))
      : ((i = (e.max.x - u.x) * l), (n = (e.min.x - u.x) * l)),
    h >= 0
      ? ((r = (e.min.y - u.y) * h), (s = (e.max.y - u.y) * h))
      : ((r = (e.max.y - u.y) * h), (s = (e.min.y - u.y) * h)),
    i > s || r > n)
      ? null
      : ((r > i || i != i) && (i = r),
        (s < n || n != n) && (n = s),
        c >= 0
          ? ((a = (e.min.z - u.z) * c), (o = (e.max.z - u.z) * c))
          : ((a = (e.max.z - u.z) * c), (o = (e.min.z - u.z) * c)),
        i > o || a > n)
      ? null
      : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0)
      ? null
      : this.at(i >= 0 ? i : n, t);
  }
  intersectsAABB(e) {
    return null !== this.intersectAABB(e, o7);
  }
  intersectPlane(e, t) {
    let i;
    let n = e.normal.dot(this.direction);
    if (0 === n) {
      if (0 !== e.distanceToPoint(this.origin)) return null;
      i = 0;
    } else i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? this.at(i, t) : null;
  }
  intersectsPlane(e) {
    let t = e.distanceToPoint(this.origin);
    return !!(0 === t || e.normal.dot(this.direction) * t < 0);
  }
  intersectOBB(e, t) {
    return (e.getSize(lt),
    lr.fromCenterAndSize(o7.set(0, 0, 0), lt),
    li.fromMatrix3(e.rotation),
    li.setPosition(e.center),
    la.copy(this).applyMatrix4(li.getInverse(ln)),
    la.intersectAABB(lr, t))
      ? t.applyMatrix4(li)
      : null;
  }
  intersectsOBB(e) {
    return null !== this.intersectOBB(e, o7);
  }
  intersectConvexHull(e, t) {
    let i = e.faces,
      n = -1 / 0,
      r = 1 / 0;
    for (let e = 0, t = i.length; e < t; e++) {
      let t = i[e].plane,
        s = t.distanceToPoint(this.origin),
        a = t.normal.dot(this.direction);
      if (s > 0 && a >= 0) return null;
      let o = 0 !== a ? -s / a : 0;
      if (
        !(o <= 0) &&
        (a > 0 ? (r = Math.min(o, r)) : (n = Math.max(o, n)), n > r)
      )
        return null;
    }
    return n !== -1 / 0 ? this.at(n, t) : this.at(r, t), t;
  }
  intersectsConvexHull(e) {
    return null !== this.intersectConvexHull(e, o7);
  }
  intersectTriangle(e, t, i) {
    let n;
    let r = e.a,
      s = e.b,
      a = e.c;
    o8.subVectors(s, r), o9.subVectors(a, r), le.crossVectors(o8, o9);
    let o = this.direction.dot(le);
    if (o > 0) {
      if (t) return null;
      n = 1;
    } else {
      if (!(o < 0)) return null;
      (n = -1), (o = -o);
    }
    o7.subVectors(this.origin, r);
    let l = n * this.direction.dot(o9.crossVectors(o7, o9));
    if (l < 0) return null;
    let h = n * this.direction.dot(o8.cross(o7));
    if (h < 0 || l + h > o) return null;
    let c = -n * o7.dot(le);
    return c < 0 ? null : this.at(c / o, i);
  }
  intersectBVH(e, t) {
    return e.root.intersectRay(this, t);
  }
  intersectsBVH(e) {
    return e.root.intersectsRay(this);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
}
const la = new ls(),
  lo = new oy(),
  ll = new os(),
  lh = new os(),
  lc = new os(),
  lu = new o6(),
  ld = new ls(new os(0, 0, 0), new os(0, 0, 1));
class lp extends oP {
  constructor(e = []) {
    super(),
      (this.obstacles = e),
      (this.brakingWeight = 0.2),
      (this.dBoxMinLength = 4);
  }
  calculate(e, t) {
    let i = this.obstacles,
      n = null,
      r = 1 / 0,
      s = this.dBoxMinLength + (e.getSpeed() / e.maxSpeed) * this.dBoxMinLength;
    e.worldMatrix.getInverse(lo);
    for (let t = 0, a = i.length; t < a; t++) {
      let a = i[t];
      if (
        a !== e &&
        (ll.copy(a.position).applyMatrix4(lo), ll.z > 0 && Math.abs(ll.z) < s)
      ) {
        let t = a.boundingRadius + e.boundingRadius;
        Math.abs(ll.x) < t &&
          (lu.center.copy(ll),
          (lu.radius = t),
          ld.intersectBoundingSphere(lu, lc),
          lc.z < r && ((r = lc.z), (n = a), lh.copy(ll)));
      }
    }
    if (null !== n) {
      let i = 1 + (s - lh.z) / s;
      (t.x = (n.boundingRadius - lh.x) * i),
        (t.z = (n.boundingRadius - lh.z) * this.brakingWeight),
        t.applyRotation(e.rotation);
    }
    return t;
  }
  toJSON() {
    let e = super.toJSON();
    (e.obstacles = []),
      (e.brakingWeight = this.brakingWeight),
      (e.dBoxMinLength = this.dBoxMinLength);
    for (let t = 0, i = this.obstacles.length; t < i; t++)
      e.obstacles.push(this.obstacles[t].uuid);
    return e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.obstacles = e.obstacles),
      (this.brakingWeight = e.brakingWeight),
      (this.dBoxMinLength = e.dBoxMinLength),
      this
    );
  }
  resolveReferences(e) {
    let t = this.obstacles;
    for (let i = 0, n = t.length; i < n; i++) t[i] = e.get(t[i]);
  }
}
const lm = new os(),
  lf = new os(),
  lg = new os(),
  l_ = new os();
class lv extends oP {
  constructor(e = null, t = new os()) {
    super(),
      (this.leader = e),
      (this.offset = t),
      (this._arrive = new oU()),
      (this._arrive.deceleration = 1.5);
  }
  calculate(e, t) {
    let i = this.leader,
      n = this.offset;
    lm.copy(n).applyMatrix4(i.worldMatrix), lf.subVectors(lm, e.position);
    let r = lf.length() / (e.maxSpeed + i.getSpeed());
    return (
      lg.copy(i.velocity).multiplyScalar(r),
      l_.addVectors(lm, lg),
      (this._arrive.target = l_),
      this._arrive.calculate(e, t),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.leader = this.leader ? this.leader.uuid : null),
      (e.offset = this.offset),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.leader = e.leader),
      (this.offset = e.offset),
      this
    );
  }
  resolveReferences(e) {
    this.leader = e.get(this.leader) || null;
  }
}
const lx = new os(),
  ly = new os(),
  lM = new os(),
  lS = new os(),
  lb = new os();
class lT extends oP {
  constructor(e = null, t = 1) {
    super(),
      (this.evader = e),
      (this.predictionFactor = t),
      (this._seek = new oF());
  }
  calculate(e, t) {
    let i = this.evader;
    lx.subVectors(i.position, e.position),
      e.getDirection(ly),
      i.getDirection(lM);
    let n = lx.dot(ly) > 0,
      r = -0.95 > ly.dot(lM);
    if (!0 === n && !0 === r)
      return (this._seek.target = i.position), this._seek.calculate(e, t), t;
    let s = lx.length() / (e.maxSpeed + i.getSpeed());
    return (
      (s *= this.predictionFactor),
      lS.copy(i.velocity).multiplyScalar(s),
      lb.addVectors(i.position, lS),
      (this._seek.target = lb),
      this._seek.calculate(e, t),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.evader = this.evader ? this.evader.uuid : null),
      (e.predictionFactor = this.predictionFactor),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.evader = e.evader),
      (this.predictionFactor = e.predictionFactor),
      this
    );
  }
  resolveReferences(e) {
    this.evader = e.get(this.evader) || null;
  }
}
const lE = new os();
class lw extends oP {
  constructor() {
    super();
  }
  calculate(e, t) {
    let i = e.neighbors;
    for (let n = 0, r = i.length; n < r; n++) {
      let r = i[n];
      lE.subVectors(e.position, r.position);
      let s = lE.length();
      0 === s && (s = 1e-4), lE.normalize().divideScalar(s), t.add(lE);
    }
    return t;
  }
}
const lA = new os(),
  lR = new os();
class lC extends oP {
  constructor(e = 1, t = 5, i = 5) {
    super(),
      (this.radius = e),
      (this.distance = t),
      (this.jitter = i),
      (this._targetLocal = new os()),
      (function (e, t) {
        let i = Math.random() * Math.PI * 2;
        (t.x = e * Math.cos(i)), (t.z = e * Math.sin(i));
      })(this.radius, this._targetLocal);
  }
  calculate(e, t, i) {
    let n = this.jitter * i;
    return (
      (lR.x = or.randFloat(-1, 1) * n),
      (lR.z = or.randFloat(-1, 1) * n),
      this._targetLocal.add(lR),
      this._targetLocal.normalize(),
      this._targetLocal.multiplyScalar(this.radius),
      lA.copy(this._targetLocal),
      (lA.z += this.distance),
      lA.applyMatrix4(e.worldMatrix),
      t.subVectors(lA, e.position),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.radius = this.radius),
      (e.distance = this.distance),
      (e.jitter = this.jitter),
      (e._targetLocal = this._targetLocal.toArray([])),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.radius = e.radius),
      (this.distance = e.distance),
      (this.jitter = e.jitter),
      this._targetLocal.fromArray(e._targetLocal),
      this
    );
  }
}
const lP = new os();
class lL {
  constructor(e) {
    (this.vehicle = e),
      (this.behaviors = []),
      (this._steeringForce = new os()),
      (this._typesMap = new Map());
  }
  add(e) {
    return this.behaviors.push(e), this;
  }
  remove(e) {
    let t = this.behaviors.indexOf(e);
    return this.behaviors.splice(t, 1), this;
  }
  clear() {
    return (this.behaviors.length = 0), this;
  }
  calculate(e, t) {
    return this._calculateByOrder(e), t.copy(this._steeringForce);
  }
  _accumulate(e) {
    let t = this._steeringForce.length(),
      i = this.vehicle.maxForce - t;
    return (
      !(i <= 0) &&
      (e.length() > i && e.normalize().multiplyScalar(i),
      this._steeringForce.add(e),
      !0)
    );
  }
  _calculateByOrder(e) {
    let t = this.behaviors;
    this._steeringForce.set(0, 0, 0);
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      if (
        !0 === n.active &&
        (lP.set(0, 0, 0),
        n.calculate(this.vehicle, lP, e),
        lP.multiplyScalar(n.weight),
        !1 === this._accumulate(lP))
      )
        return;
    }
  }
  toJSON() {
    let e = { type: "SteeringManager", behaviors: [] },
      t = this.behaviors;
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      e.behaviors.push(n.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    this.clear();
    let t = e.behaviors;
    for (let e = 0, i = t.length; e < i; e++) {
      let i;
      let n = t[e],
        r = n.type;
      switch (r) {
        case "SteeringBehavior":
          i = new oP().fromJSON(n);
          break;
        case "AlignmentBehavior":
          i = new oI().fromJSON(n);
          break;
        case "ArriveBehavior":
          i = new oU().fromJSON(n);
          break;
        case "CohesionBehavior":
          i = new ok().fromJSON(n);
          break;
        case "EvadeBehavior":
          i = new oj().fromJSON(n);
          break;
        case "FleeBehavior":
          i = new oV().fromJSON(n);
          break;
        case "FollowPathBehavior":
          i = new oJ().fromJSON(n);
          break;
        case "InterposeBehavior":
          i = new o$().fromJSON(n);
          break;
        case "ObstacleAvoidanceBehavior":
          i = new lp().fromJSON(n);
          break;
        case "OffsetPursuitBehavior":
          i = new lv().fromJSON(n);
          break;
        case "PursuitBehavior":
          i = new lT().fromJSON(n);
          break;
        case "SeekBehavior":
          i = new oF().fromJSON(n);
          break;
        case "SeparationBehavior":
          i = new lw().fromJSON(n);
          break;
        case "WanderBehavior":
          i = new lC().fromJSON(n);
          break;
        default:
          let s = this._typesMap.get(r);
          if (void 0 !== s) i = new s().fromJSON(n);
          else {
            oe.warn(
              "YUKA.SteeringManager: Unsupported steering behavior type:",
              r
            );
            continue;
          }
      }
      this.add(i);
    }
    return this;
  }
  registerType(e, t) {
    return this._typesMap.set(e, t), this;
  }
  resolveReferences(e) {
    let t = this.behaviors;
    for (let i = 0, n = t.length; i < n; i++) t[i].resolveReferences(e);
    return this;
  }
}
class lN {
  constructor(e = 10) {
    (this.count = e), (this._history = []), (this._slot = 0);
    for (let e = 0; e < this.count; e++) this._history[e] = new os();
  }
  calculate(e, t) {
    t.set(0, 0, 0),
      this._slot === this.count && (this._slot = 0),
      this._history[this._slot].copy(e),
      this._slot++;
    for (let e = 0; e < this.count; e++) t.add(this._history[e]);
    return t.divideScalar(this.count), t;
  }
  toJSON() {
    let e = {
        type: this.constructor.name,
        count: this.count,
        _history: [],
        _slot: this._slot,
      },
      t = this._history;
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      e._history.push(n.toArray([]));
    }
    return e;
  }
  fromJSON(e) {
    (this.count = e.count), (this._slot = e._slot);
    let t = e._history;
    this._history.length = 0;
    for (let e = 0, i = t.length; e < i; e++) {
      let i = t[e];
      this._history.push(new os().fromArray(i));
    }
    return this;
  }
}
const lI = new os(),
  lD = new os(),
  lO = new os(),
  lU = new os(),
  lz = new os();
class lF extends oC {
  constructor() {
    super(),
      (this.mass = 1),
      (this.maxForce = 100),
      (this.steering = new lL(this)),
      (this.smoother = null);
  }
  update(e) {
    return (
      this.steering.calculate(e, lI),
      lO.copy(lI).divideScalar(this.mass),
      this.velocity.add(lO.multiplyScalar(e)),
      this.getSpeedSquared() > this.maxSpeed * this.maxSpeed &&
        (this.velocity.normalize(),
        this.velocity.multiplyScalar(this.maxSpeed)),
      lD.copy(this.velocity).multiplyScalar(e),
      lU.copy(this.position).add(lD),
      !0 === this.updateOrientation &&
        null === this.smoother &&
        this.getSpeedSquared() > 1e-8 &&
        this.lookAt(lU),
      this.position.copy(lU),
      !0 === this.updateOrientation &&
        null !== this.smoother &&
        (this.smoother.calculate(this.velocity, lz),
        lD.copy(lz).multiplyScalar(e),
        lU.copy(this.position).add(lD),
        this.lookAt(lU)),
      this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.mass = this.mass),
      (e.maxForce = this.maxForce),
      (e.steering = this.steering.toJSON()),
      (e.smoother = this.smoother ? this.smoother.toJSON() : null),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.mass = e.mass),
      (this.maxForce = e.maxForce),
      (this.steering = new lL(this).fromJSON(e.steering)),
      (this.smoother = e.smoother ? new lN().fromJSON(e.smoother) : null),
      this
    );
  }
  resolveReferences(e) {
    super.resolveReferences(e), this.steering.resolveReferences(e);
  }
}
class lB {
  touching() {
    return !1;
  }
  update() {
    return this;
  }
  toJSON() {
    return { type: this.constructor.name };
  }
  fromJSON() {
    return this;
  }
}
const lk = new o6(),
  lH = new os();
class lV extends lB {
  constructor(e = new os()) {
    super(), (this.size = e), (this._aabb = new o5());
  }
  touching(e) {
    return (
      lk.set(e.position, e.boundingRadius),
      this._aabb.intersectsBoundingSphere(lk)
    );
  }
  update(e) {
    return (
      e.getWorldPosition(lH), this._aabb.fromCenterAndSize(lH, this.size), this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (e.size = this.size.toArray([])), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.size.fromArray(e.size), this;
  }
}
const lG = new o6();
class lW extends lB {
  constructor(e = 0) {
    super(), (this.radius = e), (this._boundingSphere = new o6());
  }
  touching(e) {
    return (
      e.getWorldPosition(lG.center),
      (lG.radius = e.boundingRadius),
      this._boundingSphere.intersectsBoundingSphere(lG)
    );
  }
  update(e) {
    return (
      e.getWorldPosition(this._boundingSphere.center),
      (this._boundingSphere.radius = this.radius),
      this
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (e.radius = this.radius), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), (this.radius = e.radius), this;
  }
}
class lX extends oE {
  constructor(e = new lB()) {
    super(),
      (this.region = e),
      (this.canActivateTrigger = !1),
      (this._typesMap = new Map());
  }
  check(e) {
    return !0 === this.region.touching(e) && this.execute(e), this;
  }
  execute() {}
  updateRegion() {
    return this.region.update(this), this;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.region = this.region.toJSON()), e;
  }
  fromJSON(e) {
    super.fromJSON(e);
    let t = e.region,
      i = t.type;
    switch (i) {
      case "TriggerRegion":
        this.region = new lB().fromJSON(t);
        break;
      case "RectangularTriggerRegion":
        this.region = new lV().fromJSON(t);
        break;
      case "SphericalTriggerRegion":
        this.region = new lW().fromJSON(t);
        break;
      default:
        let n = this._typesMap.get(i);
        void 0 !== n
          ? (this.region = new n().fromJSON(t))
          : oe.warn("YUKA.Trigger: Unsupported trigger region type:", t.type);
    }
    return this;
  }
  registerType(e, t) {
    return this._typesMap.set(e, t), this;
  }
}
const lj = [],
  lq = new os(),
  lJ = new os(),
  lY = new os();
class lK {
  constructor(e = new os(0, 0, 1), t = 0) {
    (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return (this.normal = e), (this.constant = t), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  fromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  fromCoplanarPoints(e, t, i) {
    return (
      lq.subVectors(i, t).cross(lJ.subVectors(e, t)).normalize(),
      this.fromNormalAndCoplanarPoint(lq, e),
      this
    );
  }
  intersectPlane(e, t) {
    lY.crossVectors(this.normal, e.normal);
    let i = lY.dot(lY);
    return 0 === i
      ? null
      : (lq.copy(e.normal).multiplyScalar(this.constant),
        lJ.copy(this.normal).multiplyScalar(e.constant),
        t.crossVectors(lq.sub(lJ), lY).divideScalar(i),
        t);
  }
  intersectsPlane(e) {
    return 1 !== Math.abs(this.normal.dot(e.normal));
  }
  projectPoint(e, t) {
    return (
      lq.copy(this.normal).multiplyScalar(this.distanceToPoint(e)),
      t.subVectors(e, lq),
      t
    );
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
}
function lZ() {
  !1 === document.hidden && this.reset();
}
new o6(),
  new os(),
  new os(),
  new os(),
  new ls(),
  new lK(),
  new oy(),
  new os(),
  new os(),
  new os(),
  new os();
class lQ {
  clearDegreeOfMembership() {}
  getDegreeOfMembership() {}
  updateDegreeOfMembership() {}
  toJSON() {
    return { type: this.constructor.name };
  }
}
class l$ extends lQ {
  constructor(e = []) {
    super(), (this.terms = e);
  }
  clearDegreeOfMembership() {
    let e = this.terms;
    for (let t = 0, i = e.length; t < i; t++) e[t].clearDegreeOfMembership();
    return this;
  }
  updateDegreeOfMembership(e) {
    let t = this.terms;
    for (let i = 0, n = t.length; i < n; i++) t[i].updateDegreeOfMembership(e);
    return this;
  }
  toJSON() {
    let e = super.toJSON();
    e.terms = [];
    for (let t = 0, i = this.terms.length; t < i; t++) {
      let i = this.terms[t];
      i instanceof l$ ? e.terms.push(i.toJSON()) : e.terms.push(i.uuid);
    }
    return e;
  }
}
class l0 extends l$ {
  constructor() {
    let e = Array.from(arguments);
    super(e);
  }
  getDegreeOfMembership() {
    let e = this.terms,
      t = 1 / 0;
    for (let i = 0, n = e.length; i < n; i++) {
      let n = e[i].getDegreeOfMembership();
      n < t && (t = n);
    }
    return t;
  }
}
class l1 extends l$ {
  constructor(e = null) {
    super(null !== e ? [e] : []);
  }
  clearDegreeOfMembership() {
    return this.terms[0].clearDegreeOfMembership(), this;
  }
  getDegreeOfMembership() {
    return Math.sqrt(this.terms[0].getDegreeOfMembership());
  }
  updateDegreeOfMembership(e) {
    return this.terms[0].updateDegreeOfMembership(Math.sqrt(e)), this;
  }
}
class l2 extends l$ {
  constructor() {
    let e = Array.from(arguments);
    super(e);
  }
  getDegreeOfMembership() {
    let e = this.terms,
      t = -1 / 0;
    for (let i = 0, n = e.length; i < n; i++) {
      let n = e[i].getDegreeOfMembership();
      n > t && (t = n);
    }
    return t;
  }
}
class l3 extends l$ {
  constructor(e = null) {
    super(null !== e ? [e] : []);
  }
  clearDegreeOfMembership() {
    return this.terms[0].clearDegreeOfMembership(), this;
  }
  getDegreeOfMembership() {
    let e = this.terms[0].getDegreeOfMembership();
    return e * e;
  }
  updateDegreeOfMembership(e) {
    return this.terms[0].updateDegreeOfMembership(e * e), this;
  }
}
class l5 extends lQ {
  constructor(e = 0) {
    super(),
      (this.degreeOfMembership = 0),
      (this.representativeValue = e),
      (this.left = 0),
      (this.right = 0),
      (this._uuid = null);
  }
  get uuid() {
    return null === this._uuid && (this._uuid = or.generateUUID()), this._uuid;
  }
  computeDegreeOfMembership() {}
  clearDegreeOfMembership() {
    return (this.degreeOfMembership = 0), this;
  }
  getDegreeOfMembership() {
    return this.degreeOfMembership;
  }
  updateDegreeOfMembership(e) {
    return e > this.degreeOfMembership && (this.degreeOfMembership = e), this;
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.degreeOfMembership = this.degreeOfMembership),
      (e.representativeValue = this.representativeValue),
      (e.left = this.left),
      (e.right = this.right),
      (e.uuid = this.uuid),
      e
    );
  }
  fromJSON(e) {
    return (
      (this.degreeOfMembership = e.degreeOfMembership),
      (this.representativeValue = e.representativeValue),
      (this.left = e.left),
      (this.right = e.right),
      (this._uuid = e.uuid),
      this
    );
  }
}
class l4 extends l5 {
  constructor(e = 0, t = 0, i = 0) {
    super((t + e) / 2), (this.left = e), (this.midpoint = t), (this.right = i);
  }
  computeDegreeOfMembership(e) {
    let t = this.midpoint,
      i = this.left,
      n = this.right;
    return e >= i && e <= t ? 1 : e > t && e <= n ? (1 / (n - t)) * (n - e) : 0;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.midpoint = this.midpoint), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), (this.midpoint = e.midpoint), this;
  }
}
class l6 extends l5 {
  constructor(e = 0, t = 0, i = 0) {
    super((t + i) / 2), (this.left = e), (this.midpoint = t), (this.right = i);
  }
  computeDegreeOfMembership(e) {
    let t = this.midpoint,
      i = this.left,
      n = this.right;
    return e >= i && e <= t ? (1 / (t - i)) * (e - i) : e > t && e <= n ? 1 : 0;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.midpoint = this.midpoint), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), (this.midpoint = e.midpoint), this;
  }
}
class l7 extends l5 {
  constructor(e = 0, t = 0, i = 0) {
    super(t), (this.left = e), (this.midpoint = t), (this.right = i);
  }
  computeDegreeOfMembership(e) {
    let t = this.left,
      i = this.right;
    return e >= t && e <= i ? 1 : 0;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.midpoint = this.midpoint), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), (this.midpoint = e.midpoint), this;
  }
}
class l8 extends l5 {
  constructor(e = 0, t = 0, i = 0) {
    super(t), (this.left = e), (this.midpoint = t), (this.right = i);
  }
  computeDegreeOfMembership(e) {
    let t = this.midpoint,
      i = this.left,
      n = this.right;
    return e >= i && e <= t
      ? (1 / (t - i)) * (e - i)
      : e > t && e <= n
      ? (1 / (n - t)) * (n - e)
      : 0;
  }
  toJSON() {
    let e = super.toJSON();
    return (e.midpoint = this.midpoint), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), (this.midpoint = e.midpoint), this;
  }
}
class l9 {
  constructor(e = null, t = null) {
    (this.antecedent = e), (this.consequence = t);
  }
  initConsequence() {
    return this.consequence.clearDegreeOfMembership(), this;
  }
  evaluate() {
    return (
      this.consequence.updateDegreeOfMembership(
        this.antecedent.getDegreeOfMembership()
      ),
      this
    );
  }
  toJSON() {
    let e = {},
      t = this.antecedent,
      i = this.consequence;
    return (
      (e.type = this.constructor.name),
      (e.antecedent = t instanceof l$ ? t.toJSON() : t.uuid),
      (e.consequence = i instanceof l$ ? i.toJSON() : i.uuid),
      e
    );
  }
  fromJSON(e, t) {
    function i(e) {
      if ("string" == typeof e) return t.get(e) || null;
      {
        let t;
        let n = e.type;
        switch (n) {
          case "FuzzyAND":
            t = new l0();
            break;
          case "FuzzyOR":
            t = new l2();
            break;
          case "FuzzyVERY":
            t = new l3();
            break;
          case "FuzzyFAIRLY":
            t = new l1();
            break;
          default:
            oe.error("YUKA.FuzzyRule: Unsupported operator type:", n);
            return;
        }
        let r = e.terms;
        for (let e = 0, n = r.length; e < n; e++) t.terms.push(i(r[e]));
        return t;
      }
    }
    return (
      (this.antecedent = i(e.antecedent)),
      (this.consequence = i(e.consequence)),
      this
    );
  }
}
class he {
  constructor() {
    (this.fuzzySets = []), (this.minRange = 1 / 0), (this.maxRange = -1 / 0);
  }
  add(e) {
    return (
      this.fuzzySets.push(e),
      e.left < this.minRange && (this.minRange = e.left),
      e.right > this.maxRange && (this.maxRange = e.right),
      this
    );
  }
  remove(e) {
    let t = this.fuzzySets,
      i = t.indexOf(e);
    t.splice(i, 1), (this.minRange = 1 / 0), (this.maxRange = -1 / 0);
    for (let e = 0, i = t.length; e < i; e++) {
      let i = t[e];
      i.left < this.minRange && (this.minRange = i.left),
        i.right > this.maxRange && (this.maxRange = i.right);
    }
    return this;
  }
  fuzzify(e) {
    if (e < this.minRange || e > this.maxRange) {
      oe.warn("YUKA.FuzzyVariable: Value for fuzzification out of range.");
      return;
    }
    let t = this.fuzzySets;
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      n.degreeOfMembership = n.computeDegreeOfMembership(e);
    }
    return this;
  }
  defuzzifyMaxAv() {
    let e = this.fuzzySets,
      t = 0,
      i = 0;
    for (let n = 0, r = e.length; n < r; n++) {
      let r = e[n];
      (t += r.degreeOfMembership),
        (i += r.representativeValue * r.degreeOfMembership);
    }
    return 0 === t ? 0 : i / t;
  }
  defuzzifyCentroid(e = 10) {
    let t = this.fuzzySets,
      i = (this.maxRange - this.minRange) / e,
      n = 0,
      r = 0;
    for (let s = 1; s <= e; s++) {
      let e = this.minRange + s * i;
      for (let i = 0, s = t.length; i < s; i++) {
        let s = t[i],
          a = Math.min(s.degreeOfMembership, s.computeDegreeOfMembership(e));
        (n += a), (r += e * a);
      }
    }
    return 0 === n ? 0 : r / n;
  }
  toJSON() {
    let e = {
      type: this.constructor.name,
      fuzzySets: [],
      minRange: this.minRange.toString(),
      maxRange: this.maxRange.toString(),
    };
    for (let t = 0, i = this.fuzzySets.length; t < i; t++) {
      let i = this.fuzzySets[t];
      e.fuzzySets.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (this.minRange = parseFloat(e.minRange)),
      (this.maxRange = parseFloat(e.maxRange));
    for (let t = 0, i = e.fuzzySets.length; t < i; t++) {
      let i = e.fuzzySets[t];
      switch (i.type) {
        case "LeftShoulderFuzzySet":
          this.fuzzySets.push(new l4().fromJSON(i));
          break;
        case "RightShoulderFuzzySet":
          this.fuzzySets.push(new l6().fromJSON(i));
          break;
        case "SingletonFuzzySet":
          this.fuzzySets.push(new l7().fromJSON(i));
          break;
        case "TriangularFuzzySet":
          this.fuzzySets.push(new l8().fromJSON(i));
          break;
        default:
          oe.error("YUKA.FuzzyVariable: Unsupported fuzzy set type:", i.type);
      }
    }
    return this;
  }
}
class ht {
  constructor() {
    (this.rules = []), (this.flvs = new Map());
  }
  addFLV(e, t) {
    return this.flvs.set(e, t), this;
  }
  removeFLV(e) {
    return this.flvs.delete(e), this;
  }
  addRule(e) {
    return this.rules.push(e), this;
  }
  removeRule(e) {
    let t = this.rules,
      i = t.indexOf(e);
    return t.splice(i, 1), this;
  }
  fuzzify(e, t) {
    return this.flvs.get(e).fuzzify(t), this;
  }
  defuzzify(e, t = ht.DEFUZ_TYPE.MAXAV) {
    let i;
    let n = this.flvs,
      r = this.rules;
    this._initConsequences();
    for (let e = 0, t = r.length; e < t; e++) r[e].evaluate();
    let s = n.get(e);
    switch (t) {
      case ht.DEFUZ_TYPE.MAXAV:
        i = s.defuzzifyMaxAv();
        break;
      case ht.DEFUZ_TYPE.CENTROID:
        i = s.defuzzifyCentroid();
        break;
      default:
        oe.warn("YUKA.FuzzyModule: Unknown defuzzification method:", t),
          (i = s.defuzzifyMaxAv());
    }
    return i;
  }
  _initConsequences() {
    let e = this.rules;
    for (let t = 0, i = e.length; t < i; t++) e[t].initConsequence();
    return this;
  }
  toJSON() {
    let e = { rules: [], flvs: [] },
      t = this.rules;
    for (let i = 0, n = t.length; i < n; i++) e.rules.push(t[i].toJSON());
    for (let [t, i] of this.flvs) e.flvs.push({ name: t, flv: i.toJSON() });
    return e;
  }
  fromJSON(e) {
    let t = new Map(),
      i = e.flvs;
    for (let e = 0, n = i.length; e < n; e++) {
      let n = i[e],
        r = n.name,
        s = new he().fromJSON(n.flv);
      for (let e of (this.addFLV(r, s), s.fuzzySets)) t.set(e.uuid, e);
    }
    let n = e.rules;
    for (let e = 0, i = n.length; e < i; e++) {
      let i = n[e],
        r = new l9().fromJSON(i, t);
      this.addRule(r);
    }
    return this;
  }
}
ht.DEFUZ_TYPE = Object.freeze({ MAXAV: 0, CENTROID: 1 });
class hi {
  constructor(e = null) {
    (this.owner = e), (this.status = hi.STATUS.INACTIVE);
  }
  activate() {}
  execute() {}
  terminate() {}
  handleMessage() {
    return !1;
  }
  active() {
    return this.status === hi.STATUS.ACTIVE;
  }
  inactive() {
    return this.status === hi.STATUS.INACTIVE;
  }
  completed() {
    return this.status === hi.STATUS.COMPLETED;
  }
  failed() {
    return this.status === hi.STATUS.FAILED;
  }
  replanIfFailed() {
    return !0 === this.failed() && (this.status = hi.STATUS.INACTIVE), this;
  }
  activateIfInactive() {
    return (
      !0 === this.inactive() &&
        ((this.status = hi.STATUS.ACTIVE), this.activate()),
      this
    );
  }
  toJSON() {
    return {
      type: this.constructor.name,
      owner: this.owner.uuid,
      status: this.status,
    };
  }
  fromJSON(e) {
    return (this.owner = e.owner), (this.status = e.status), this;
  }
  resolveReferences(e) {
    return (this.owner = e.get(this.owner) || null), this;
  }
}
(hi.STATUS = Object.freeze({
  ACTIVE: "active",
  INACTIVE: "inactive",
  COMPLETED: "completed",
  FAILED: "failed",
})),
  new os(),
  new os(),
  new os(),
  new os(1, 0, 0),
  new os(0, 1, 0),
  new os(0, 0, 1),
  new os(),
  new os(),
  new os(),
  new os();
const hn = new os(),
  hr = new os();
class hs {
  constructor(e = new os(), t = new os()) {
    (this.from = e), (this.to = t);
  }
  set(e, t) {
    return (this.from = e), (this.to = t), this;
  }
  copy(e) {
    return this.from.copy(e.from), this.to.copy(e.to), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  delta(e) {
    return e.subVectors(this.to, this.from);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.from);
  }
  closestPointToPoint(e, t, i) {
    let n = this.closestPointToPointParameter(e, t);
    return this.at(n, i);
  }
  closestPointToPointParameter(e, t = !0) {
    hn.subVectors(e, this.from), hr.subVectors(this.to, this.from);
    let i = hr.dot(hr),
      n = hr.dot(hn) / i;
    return t && (n = or.clamp(n, 0, 1)), n;
  }
  equals(e) {
    return e.from.equals(this.from) && e.to.equals(this.to);
  }
}
const ha = new os(),
  ho = new os(),
  hl = new os(),
  hh = new os(),
  hc = new os(),
  hu = new os(),
  hd = new os();
class hp {
  constructor(e = new os()) {
    (this.vertex = e),
      (this.next = null),
      (this.prev = null),
      (this.twin = null),
      (this.polygon = null);
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  head() {
    return this.vertex;
  }
  length() {
    let e = this.tail(),
      t = this.head();
    return null !== e ? e.distanceTo(t) : -1;
  }
  squaredLength() {
    let e = this.tail(),
      t = this.head();
    return null !== e ? e.squaredDistanceTo(t) : -1;
  }
  linkOpponent(e) {
    return (this.twin = e), (e.twin = this), this;
  }
  getDirection(e) {
    return e.subVectors(this.vertex, this.prev.vertex).normalize();
  }
}
class hm {
  constructor() {
    (this.centroid = new os()), (this.edge = null), (this.plane = new lK());
  }
  fromContour(e) {
    let t = [];
    if (e.length < 3)
      return (
        oe.error(
          "YUKA.Polygon: Unable to create polygon from contour. It needs at least three points."
        ),
        this
      );
    for (let i = 0, n = e.length; i < n; i++) {
      let n = new hp(e[i]);
      t.push(n);
    }
    for (let e = 0, i = t.length; e < i; e++) {
      let n, r, s;
      0 === e
        ? ((n = t[e]), (r = t[i - 1]), (s = t[e + 1]))
        : e === i - 1
        ? ((n = t[e]), (r = t[e - 1]), (s = t[0]))
        : ((n = t[e]), (r = t[e - 1]), (s = t[e + 1])),
        (n.prev = r),
        (n.next = s),
        (n.polygon = this);
    }
    return (
      (this.edge = t[0]), this.plane.fromCoplanarPoints(e[0], e[1], e[2]), this
    );
  }
  computeCentroid() {
    let e = this.centroid,
      t = this.edge,
      i = 0;
    e.set(0, 0, 0);
    do e.add(t.vertex), i++, (t = t.next);
    while (t !== this.edge);
    return e.divideScalar(i), this;
  }
  contains(e, t = 0.001) {
    let i = this.plane,
      n = this.edge;
    do {
      if (!1 === hf(n.tail(), n.head(), e)) return !1;
      n = n.next;
    } while (n !== this.edge);
    return !(Math.abs(i.distanceToPoint(e)) > t);
  }
  convex(e = !0) {
    let t = this.edge;
    do {
      let i = t.tail(),
        n = t.head(),
        r = t.next.head();
      if (e) {
        if (!1 === hf(i, n, r)) return !1;
      } else if (!1 === hf(r, n, i)) return !1;
      t = t.next;
    } while (t !== this.edge);
    return !0;
  }
  coplanar(e = 0.001) {
    let t = this.plane,
      i = this.edge;
    do {
      if (Math.abs(t.distanceToPoint(i.vertex)) > e) return !1;
      i = i.next;
    } while (i !== this.edge);
    return !0;
  }
  distanceToPoint(e) {
    return this.plane.distanceToPoint(e);
  }
  getContour(e) {
    let t = this.edge;
    e.length = 0;
    do e.push(t.vertex), (t = t.next);
    while (t !== this.edge);
    return e;
  }
}
function hf(e, t, i) {
  return or.area(e, t, i) >= 0;
}
class hg {
  constructor() {
    (this.faces = []),
      (this.edges = []),
      (this.vertices = []),
      (this.centroid = new os());
  }
  computeCentroid() {
    let e = this.centroid,
      t = this.faces;
    e.set(0, 0, 0);
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      e.add(n.centroid);
    }
    return e.divideScalar(t.length), this;
  }
  computeUniqueVertices() {
    let e = this.faces,
      t = this.vertices;
    t.length = 0;
    let i = new Set();
    for (let t = 0, n = e.length; t < n; t++) {
      let n = e[t],
        r = n.edge;
      do i.add(r.vertex), (r = r.next);
      while (r !== n.edge);
    }
    return t.push(...i), this;
  }
  computeUniqueEdges() {
    let e = this.faces,
      t = this.edges;
    t.length = 0;
    for (let i = 0, n = e.length; i < n; i++) {
      let n = e[i],
        r = n.edge;
      do !1 === t.includes(r.twin) && t.push(r), (r = r.next);
      while (r !== n.edge);
    }
    return this;
  }
  fromAABB(e) {
    (this.faces.length = 0), (this.vertices.length = 0);
    let t = e.min,
      i = e.max,
      n = [
        new os(i.x, i.y, i.z),
        new os(i.x, i.y, t.z),
        new os(i.x, t.y, i.z),
        new os(i.x, t.y, t.z),
        new os(t.x, i.y, i.z),
        new os(t.x, i.y, t.z),
        new os(t.x, t.y, i.z),
        new os(t.x, t.y, t.z),
      ];
    this.vertices.push(...n);
    let r = new hm().fromContour([n[4], n[0], n[1], n[5]]),
      s = new hm().fromContour([n[2], n[3], n[1], n[0]]),
      a = new hm().fromContour([n[6], n[2], n[0], n[4]]),
      o = new hm().fromContour([n[3], n[7], n[5], n[1]]),
      l = new hm().fromContour([n[3], n[2], n[6], n[7]]),
      h = new hm().fromContour([n[7], n[6], n[4], n[5]]);
    return (
      r.edge.linkOpponent(h.edge.prev),
      r.edge.next.linkOpponent(a.edge.prev),
      r.edge.next.next.linkOpponent(s.edge.prev),
      r.edge.prev.linkOpponent(o.edge.prev),
      l.edge.linkOpponent(o.edge.next),
      l.edge.next.linkOpponent(s.edge.next),
      l.edge.next.next.linkOpponent(a.edge.next),
      l.edge.prev.linkOpponent(h.edge.next),
      h.edge.linkOpponent(o.edge.next.next),
      o.edge.linkOpponent(s.edge.next.next),
      s.edge.linkOpponent(a.edge.next.next),
      a.edge.linkOpponent(h.edge.next.next),
      this.faces.push(r, s, a, o, l, h),
      r.computeCentroid(),
      s.computeCentroid(),
      a.computeCentroid(),
      o.computeCentroid(),
      l.computeCentroid(),
      h.computeCentroid(),
      e.getCenter(this.centroid),
      this.computeUniqueEdges(),
      this
    );
  }
}
const h_ = new hs(),
  hv = new lK(),
  hx = new os(),
  hy = new os(0, 1, 0),
  hM = new (class {
    intersects(e, t) {
      return !(
        this._checkFaceDirections(e, t) ||
        this._checkFaceDirections(t, e) ||
        this._checkEdgeDirections(e, t)
      );
    }
    _checkFaceDirections(e, t) {
      let i = e.faces;
      for (let e = 0, n = i.length; e < n; e++) {
        let n = i[e].plane;
        ho.copy(n.normal).multiplyScalar(-1);
        let r = this._getSupportVertex(t, ho);
        if (n.distanceToPoint(r) > 0) return !0;
      }
      return !1;
    }
    _checkEdgeDirections(e, t) {
      let i = e.edges,
        n = t.edges;
      for (let t = 0, r = i.length; t < r; t++) {
        let r = i[t];
        for (let t = 0, i = n.length; t < i; t++) {
          let i = n[t];
          if (
            (r.getDirection(hl),
            i.getDirection(hh),
            this._minkowskiFace(r, hl, i, hh) &&
              this._distanceBetweenEdges(r, hl, i, hh, e) > 0)
          )
            return !0;
        }
      }
      return !1;
    }
    _getSupportVertex(e, t) {
      let i = -1 / 0,
        n = null,
        r = e.vertices;
      for (let e = 0, s = r.length; e < s; e++) {
        let s = r[e],
          a = s.dot(t);
        a > i && ((i = a), (n = s));
      }
      return n;
    }
    _minkowskiFace(e, t, i, n) {
      let r = e.polygon.plane.normal,
        s = e.twin.polygon.plane.normal;
      hc.copy(i.polygon.plane.normal),
        hu.copy(i.twin.polygon.plane.normal),
        hc.multiplyScalar(-1),
        hu.multiplyScalar(-1);
      let a = hc.dot(t),
        o = hu.dot(t),
        l = r.dot(n),
        h = s.dot(n);
      return a * o < 0 && l * h < 0 && a * h > 0;
    }
    _distanceBetweenEdges(e, t, i, n, r) {
      return 1 === Math.abs(t.dot(n))
        ? -1 / 0
        : (ha.crossVectors(t, n).normalize(),
          0 > ha.dot(hd.subVectors(e.vertex, r.centroid)) &&
            ha.multiplyScalar(-1),
          ha.dot(hd.subVectors(i.vertex, e.vertex)));
    }
  })();
class hS extends hg {
  constructor() {
    super(),
      (this.mergeFaces = !0),
      (this._tolerance = -1),
      (this._vertices = []),
      (this._assigned = new hE()),
      (this._unassigned = new hE());
  }
  containsPoint(e) {
    let t = this.faces;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i].distanceToPoint(e) > this._tolerance) return !1;
    return !0;
  }
  intersectsAABB(e) {
    if (void 0 === t) t = new hg().fromAABB(e);
    else {
      let i = e.min,
        n = e.max,
        r = t.vertices;
      r[0].set(n.x, n.y, n.z),
        r[1].set(n.x, n.y, i.z),
        r[2].set(n.x, i.y, n.z),
        r[3].set(n.x, i.y, i.z),
        r[4].set(i.x, n.y, n.z),
        r[5].set(i.x, n.y, i.z),
        r[6].set(i.x, i.y, n.z),
        r[7].set(i.x, i.y, i.z),
        e.getCenter(t.centroid);
    }
    return hM.intersects(this, t);
  }
  intersectsConvexHull(e) {
    return hM.intersects(this, e);
  }
  fromPoints(e) {
    if (e.length < 4)
      return (
        oe.error(
          "YUKA.ConvexHull: The given points array needs at least four points."
        ),
        this
      );
    for (let t = 0, i = e.length; t < i; t++) this._vertices.push(new hT(e[t]));
    return this._generate(), this;
  }
  _addAdjoiningFace(e, t) {
    let i = new hb(e.point, t.prev.vertex, t.vertex);
    return this.faces.push(i), i.getEdge(-1).linkOpponent(t.twin), i.getEdge(0);
  }
  _addNewFaces(e, t) {
    let i = [],
      n = null,
      r = null;
    for (let s = 0, a = t.length; s < a; s++) {
      let a = this._addAdjoiningFace(e, t[s]);
      null === n ? (n = a) : a.next.linkOpponent(r), i.push(a.polygon), (r = a);
    }
    return n.next.linkOpponent(r), i;
  }
  _addVertexToFace(e, t) {
    return (
      (e.face = t),
      null === t.outside
        ? (this._assigned.append(e), (t.outside = e))
        : this._assigned.insertAfter(t.outside, e),
      this
    );
  }
  _addVertexToHull(e) {
    let t = [];
    this._unassigned.clear(), this._computeHorizon(e.point, null, e.face, t);
    let i = this._addNewFaces(e, t);
    return this._resolveUnassignedPoints(i), this;
  }
  _reset() {
    return (
      (this._vertices.length = 0),
      this._assigned.clear(),
      this._unassigned.clear(),
      this
    );
  }
  _computeInitialHull() {
    let e, t, i, n, r, s;
    let a = this._vertices,
      o = this._computeExtremes(),
      l = o.min,
      h = o.max;
    (s = h.x.point.x - l.x.point.x),
      (e = l.x),
      (t = h.x),
      (r = h.y.point.y - l.y.point.y) > s && ((e = l.y), (t = h.y), (s = r)),
      (r = h.z.point.z - l.z.point.z) > s && ((e = l.z), (t = h.z)),
      (s = -1 / 0),
      h_.set(e.point, t.point);
    for (let n = 0, o = a.length; n < o; n++) {
      let o = a[n];
      o !== e &&
        o !== t &&
        (h_.closestPointToPoint(o.point, !0, hx),
        (r = hx.squaredDistanceTo(o.point)) > s && ((s = r), (i = o)));
    }
    (s = -1 / 0), hv.fromCoplanarPoints(e.point, t.point, i.point);
    for (let o = 0, l = a.length; o < l; o++) {
      let l = a[o];
      l !== e &&
        l !== t &&
        l !== i &&
        (r = Math.abs(hv.distanceToPoint(l.point))) > s &&
        ((s = r), (n = l));
    }
    if (0 === hv.distanceToPoint(n.point))
      throw "ERROR: YUKA.ConvexHull: All extreme points lie in a single plane. Unable to compute convex hull.";
    let c = this.faces;
    0 > hv.distanceToPoint(n.point)
      ? (c.push(
          new hb(e.point, t.point, i.point),
          new hb(n.point, t.point, e.point),
          new hb(n.point, i.point, t.point),
          new hb(n.point, e.point, i.point)
        ),
        c[1].getEdge(2).linkOpponent(c[0].getEdge(1)),
        c[2].getEdge(2).linkOpponent(c[0].getEdge(2)),
        c[3].getEdge(2).linkOpponent(c[0].getEdge(0)),
        c[1].getEdge(1).linkOpponent(c[2].getEdge(0)),
        c[2].getEdge(1).linkOpponent(c[3].getEdge(0)),
        c[3].getEdge(1).linkOpponent(c[1].getEdge(0)))
      : (c.push(
          new hb(e.point, i.point, t.point),
          new hb(n.point, e.point, t.point),
          new hb(n.point, t.point, i.point),
          new hb(n.point, i.point, e.point)
        ),
        c[1].getEdge(2).linkOpponent(c[0].getEdge(0)),
        c[2].getEdge(2).linkOpponent(c[0].getEdge(2)),
        c[3].getEdge(2).linkOpponent(c[0].getEdge(1)),
        c[1].getEdge(0).linkOpponent(c[2].getEdge(1)),
        c[2].getEdge(0).linkOpponent(c[3].getEdge(1)),
        c[3].getEdge(0).linkOpponent(c[1].getEdge(1)));
    for (let o = 0, l = a.length; o < l; o++) {
      let l = a[o];
      if (l !== e && l !== t && l !== i && l !== n) {
        s = this._tolerance;
        let e = null;
        for (let t = 0; t < 4; t++)
          (r = c[t].distanceToPoint(l.point)) > s && ((s = r), (e = c[t]));
        null !== e && this._addVertexToFace(l, e);
      }
    }
    return this;
  }
  _computeExtremes() {
    let e = new os(1 / 0, 1 / 0, 1 / 0),
      t = new os(-1 / 0, -1 / 0, -1 / 0),
      i = { x: null, y: null, z: null },
      n = { x: null, y: null, z: null };
    for (let r = 0, s = this._vertices.length; r < s; r++) {
      let s = this._vertices[r],
        a = s.point;
      a.x < e.x && ((e.x = a.x), (i.x = s)),
        a.y < e.y && ((e.y = a.y), (i.y = s)),
        a.z < e.z && ((e.z = a.z), (i.z = s)),
        a.x > t.x && ((t.x = a.x), (n.x = s)),
        a.y > t.y && ((t.y = a.y), (n.y = s)),
        a.z > t.z && ((t.z = a.z), (n.z = s));
    }
    return (
      (this._tolerance =
        3 *
        Number.EPSILON *
        (Math.max(Math.abs(e.x), Math.abs(t.x)) +
          Math.max(Math.abs(e.y), Math.abs(t.y)) +
          Math.max(Math.abs(e.z), Math.abs(t.z)))),
      { min: i, max: n }
    );
  }
  _computeHorizon(e, t, i, n) {
    let r;
    if (i.outside) {
      let e = i.outside;
      this._removeAllVerticesFromFace(i), this._unassigned.appendChain(e);
    }
    (i.active = !1), (r = null === t ? (t = i.getEdge(0)) : t.next);
    do {
      let t = r.twin,
        i = t.polygon;
      i.active &&
        (i.distanceToPoint(e) > this._tolerance
          ? this._computeHorizon(e, t, i, n)
          : n.push(r)),
        (r = r.next);
    } while (r !== t);
    return this;
  }
  _generate() {
    let e;
    for (
      this.faces.length = 0, this._computeInitialHull();
      (e = this._nextVertexToAdd());

    )
      this._addVertexToHull(e);
    return this._updateFaces(), this._postprocessHull(), this._reset(), this;
  }
  _postprocessHull() {
    let e = this.faces,
      t = this.edges;
    if (!0 === this.mergeFaces) {
      let i = {};
      this.computeUniqueEdges(), t.sort((e, t) => t.length() - e.length());
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        if (!1 === this._mergePossible(r)) continue;
        (i.prev = r.prev),
          (i.next = r.next),
          (i.prevTwin = r.twin.prev),
          (i.nextTwin = r.twin.next),
          (r.prev.next = r.twin.next),
          (r.next.prev = r.twin.prev),
          (r.twin.prev.next = r.next),
          (r.twin.next.prev = r.prev);
        let s = r.polygon;
        s.edge = r.prev;
        let a = s.plane.normal.dot(hy) >= 0;
        if (!0 === s.convex(a) && !0 === s.coplanar(this._tolerance)) {
          let t = s.edge;
          do (t.polygon = s), (t = t.next);
          while (t !== s.edge);
          let i = e.indexOf(r.twin.polygon);
          e.splice(i, 1);
        } else
          (i.prev.next = r),
            (i.next.prev = r),
            (i.prevTwin.next = r.twin),
            (i.nextTwin.prev = r.twin),
            (s.edge = r);
      }
      for (let t = 0, i = e.length; t < i; t++) e[t].computeCentroid();
    }
    return (
      this.computeCentroid(),
      this.computeUniqueEdges(),
      this.computeUniqueVertices(),
      this
    );
  }
  _mergePossible(e) {
    let t = e.polygon,
      i = e.twin;
    do {
      if (i !== e.twin && i.twin.polygon === t) return !1;
      i = i.next;
    } while (e.twin !== i);
    return !0;
  }
  _nextVertexToAdd() {
    let e = null;
    if (!1 === this._assigned.empty()) {
      let t = 0,
        i = this._assigned.first(),
        n = i.face;
      do {
        let r = n.distanceToPoint(i.point);
        r > t && ((t = r), (e = i)), (i = i.next);
      } while (null !== i && i.face === n);
    }
    return e;
  }
  _updateFaces() {
    let e = this.faces,
      t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      let n = e[i];
      n.active && t.push(n);
    }
    return (this.faces.length = 0), this.faces.push(...t), this;
  }
  _removeAllVerticesFromFace(e) {
    if (null !== e.outside) {
      let t = e.outside;
      t.face = null;
      let i = e.outside;
      for (; null !== i.next && i.next.face === e; ) (i = i.next).face = null;
      (e.outside = null), this._assigned.removeChain(t, i);
    }
    return this;
  }
  _removeVertexFromFace(e, t) {
    return (
      (e.face = null),
      e === t.outside &&
        (null !== e.next && e.next.face === t
          ? (t.outside = e.next)
          : (t.outside = null)),
      this._assigned.remove(e),
      this
    );
  }
  _resolveUnassignedPoints(e) {
    if (!1 === this._unassigned.empty()) {
      let t = this._unassigned.first();
      do {
        let i = t.next,
          n = this._tolerance,
          r = null;
        for (let i = 0, s = e.length; i < s; i++) {
          let s = e[i];
          if (s.active) {
            let e = s.distanceToPoint(t.point);
            e > n && ((n = e), (r = s));
          }
        }
        null !== r && this._addVertexToFace(t, r), (t = i);
      } while (null !== t);
    }
    return this;
  }
}
class hb extends hm {
  constructor(e = new os(), t = new os(), i = new os()) {
    super(),
      (this.outside = null),
      (this.active = !0),
      this.fromContour([e, t, i]),
      this.computeCentroid();
  }
  getEdge(e) {
    let t = this.edge;
    for (; e > 0; ) (t = t.next), e--;
    for (; e < 0; ) (t = t.prev), e++;
    return t;
  }
}
class hT {
  constructor(e = new os()) {
    (this.point = e),
      (this.prev = null),
      (this.next = null),
      (this.face = null);
  }
}
class hE {
  constructor() {
    (this.head = null), (this.tail = null);
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return (this.head = this.tail = null), this;
  }
  insertAfter(e, t) {
    return (
      (t.prev = e),
      (t.next = e.next),
      t.next ? (t.next.prev = t) : (this.tail = t),
      (e.next = t),
      this
    );
  }
  append(e) {
    return (
      null === this.head ? (this.head = e) : (this.tail.next = e),
      (e.prev = this.tail),
      (e.next = null),
      (this.tail = e),
      this
    );
  }
  appendChain(e) {
    for (
      null === this.head ? (this.head = e) : (this.tail.next = e),
        e.prev = this.tail;
      null !== e.next;

    )
      e = e.next;
    return (this.tail = e), this;
  }
  remove(e) {
    return (
      null === e.prev ? (this.head = e.next) : (e.prev.next = e.next),
      null === e.next ? (this.tail = e.prev) : (e.next.prev = e.prev),
      (e.prev = null),
      (e.next = null),
      this
    );
  }
  removeChain(e, t) {
    return (
      null === e.prev ? (this.head = t.next) : (e.prev.next = t.next),
      null === t.next ? (this.tail = e.prev) : (t.next.prev = e.prev),
      (e.prev = null),
      (t.next = null),
      this
    );
  }
  empty() {
    return null === this.head;
  }
}
const hw = { unitary: new om(), diagonal: new om() },
  hA = { c: null, u: [new os(), new os(), new os()], e: [] },
  hR = { c: null, u: [new os(), new os(), new os()], e: [] },
  hC = [[], [], []],
  hP = [[], [], []],
  hL = [],
  hN = new os(),
  hI = new os(),
  hD = new os(),
  hO = new os(),
  hU = new os(),
  hz = new (class {
    constructor(e = new os(), t = new os(), i = new om()) {
      (this.center = e), (this.halfSizes = t), (this.rotation = i);
    }
    set(e, t, i) {
      return (this.center = e), (this.halfSizes = t), (this.rotation = i), this;
    }
    copy(e) {
      return (
        this.center.copy(e.center),
        this.halfSizes.copy(e.halfSizes),
        this.rotation.copy(e.rotation),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    getSize(e) {
      return e.copy(this.halfSizes).multiplyScalar(2);
    }
    clampPoint(e, t) {
      let i = this.halfSizes;
      hO.subVectors(e, this.center),
        this.rotation.extractBasis(hN, hI, hD),
        t.copy(this.center);
      let n = or.clamp(hO.dot(hN), -i.x, i.x);
      t.add(hN.multiplyScalar(n));
      let r = or.clamp(hO.dot(hI), -i.y, i.y);
      t.add(hI.multiplyScalar(r));
      let s = or.clamp(hO.dot(hD), -i.z, i.z);
      return t.add(hD.multiplyScalar(s)), t;
    }
    containsPoint(e) {
      return (
        hO.subVectors(e, this.center),
        this.rotation.extractBasis(hN, hI, hD),
        Math.abs(hO.dot(hN)) <= this.halfSizes.x &&
          Math.abs(hO.dot(hI)) <= this.halfSizes.y &&
          Math.abs(hO.dot(hD)) <= this.halfSizes.z
      );
    }
    intersectsAABB(e) {
      return this.intersectsOBB(hz.fromAABB(e));
    }
    intersectsBoundingSphere(e) {
      return (
        this.clampPoint(e.center, hU),
        hU.squaredDistanceTo(e.center) <= e.radius * e.radius
      );
    }
    intersectsOBB(e, t = Number.EPSILON) {
      let i, n;
      (hA.c = this.center),
        (hA.e[0] = this.halfSizes.x),
        (hA.e[1] = this.halfSizes.y),
        (hA.e[2] = this.halfSizes.z),
        this.rotation.extractBasis(hA.u[0], hA.u[1], hA.u[2]),
        (hR.c = e.center),
        (hR.e[0] = e.halfSizes.x),
        (hR.e[1] = e.halfSizes.y),
        (hR.e[2] = e.halfSizes.z),
        e.rotation.extractBasis(hR.u[0], hR.u[1], hR.u[2]);
      for (let e = 0; e < 3; e++)
        for (let t = 0; t < 3; t++) hC[e][t] = hA.u[e].dot(hR.u[t]);
      hO.subVectors(hR.c, hA.c),
        (hL[0] = hO.dot(hA.u[0])),
        (hL[1] = hO.dot(hA.u[1])),
        (hL[2] = hO.dot(hA.u[2]));
      for (let e = 0; e < 3; e++)
        for (let i = 0; i < 3; i++) hP[e][i] = Math.abs(hC[e][i]) + t;
      for (let e = 0; e < 3; e++)
        if (
          ((i = hA.e[e]),
          (n = hR.e[0] * hP[e][0] + hR.e[1] * hP[e][1] + hR.e[2] * hP[e][2]),
          Math.abs(hL[e]) > i + n)
        )
          return !1;
      for (let e = 0; e < 3; e++)
        if (
          ((i = hA.e[0] * hP[0][e] + hA.e[1] * hP[1][e] + hA.e[2] * hP[2][e]),
          (n = hR.e[e]),
          Math.abs(hL[0] * hC[0][e] + hL[1] * hC[1][e] + hL[2] * hC[2][e]) >
            i + n)
        )
          return !1;
      return (
        (i = hA.e[1] * hP[2][0] + hA.e[2] * hP[1][0]),
        (n = hR.e[1] * hP[0][2] + hR.e[2] * hP[0][1]),
        !(Math.abs(hL[2] * hC[1][0] - hL[1] * hC[2][0]) > i + n) &&
          ((i = hA.e[1] * hP[2][1] + hA.e[2] * hP[1][1]),
          (n = hR.e[0] * hP[0][2] + hR.e[2] * hP[0][0]),
          !(Math.abs(hL[2] * hC[1][1] - hL[1] * hC[2][1]) > i + n) &&
            ((i = hA.e[1] * hP[2][2] + hA.e[2] * hP[1][2]),
            (n = hR.e[0] * hP[0][1] + hR.e[1] * hP[0][0]),
            !(Math.abs(hL[2] * hC[1][2] - hL[1] * hC[2][2]) > i + n) &&
              ((i = hA.e[0] * hP[2][0] + hA.e[2] * hP[0][0]),
              (n = hR.e[1] * hP[1][2] + hR.e[2] * hP[1][1]),
              !(Math.abs(hL[0] * hC[2][0] - hL[2] * hC[0][0]) > i + n) &&
                ((i = hA.e[0] * hP[2][1] + hA.e[2] * hP[0][1]),
                (n = hR.e[0] * hP[1][2] + hR.e[2] * hP[1][0]),
                !(Math.abs(hL[0] * hC[2][1] - hL[2] * hC[0][1]) > i + n) &&
                  ((i = hA.e[0] * hP[2][2] + hA.e[2] * hP[0][2]),
                  (n = hR.e[0] * hP[1][1] + hR.e[1] * hP[1][0]),
                  !(Math.abs(hL[0] * hC[2][2] - hL[2] * hC[0][2]) > i + n) &&
                    ((i = hA.e[0] * hP[1][0] + hA.e[1] * hP[0][0]),
                    (n = hR.e[1] * hP[2][2] + hR.e[2] * hP[2][1]),
                    !(Math.abs(hL[1] * hC[0][0] - hL[0] * hC[1][0]) > i + n) &&
                      ((i = hA.e[0] * hP[1][1] + hA.e[1] * hP[0][1]),
                      (n = hR.e[0] * hP[2][2] + hR.e[2] * hP[2][0]),
                      !(
                        Math.abs(hL[1] * hC[0][1] - hL[0] * hC[1][1]) >
                        i + n
                      ) &&
                        ((i = hA.e[0] * hP[1][2] + hA.e[1] * hP[0][2]),
                        (n = hR.e[0] * hP[2][1] + hR.e[1] * hP[2][0]),
                        !(
                          Math.abs(hL[1] * hC[0][2] - hL[0] * hC[1][2]) >
                          i + n
                        )))))))))
      );
    }
    intersectsPlane(e) {
      this.rotation.extractBasis(hN, hI, hD);
      let t =
        this.halfSizes.x * Math.abs(e.normal.dot(hN)) +
        this.halfSizes.y * Math.abs(e.normal.dot(hI)) +
        this.halfSizes.z * Math.abs(e.normal.dot(hD));
      return Math.abs(e.normal.dot(this.center) - e.constant) <= t;
    }
    fromAABB(e) {
      return (
        e.getCenter(this.center),
        e.getSize(this.halfSizes).multiplyScalar(0.5),
        this.rotation.identity(),
        this
      );
    }
    fromPoints(e) {
      let t, i, n, r, s, a;
      let o = new hS().fromPoints(e).faces,
        l = [],
        h = [];
      for (let e = 0, t = o.length; e < t; e++) {
        let t = o[e],
          i = t.edge;
        l.length = 0;
        do l.push(i), (i = i.next);
        while (i !== t.edge);
        let n = l.length - 2;
        for (let e = 1; e <= n; e++) {
          let t = l[0].vertex,
            i = l[e + 0].vertex,
            n = l[e + 1].vertex;
          h.push(t.x, t.y, t.z), h.push(i.x, i.y, i.z), h.push(n.x, n.y, n.z);
        }
      }
      let c = new os(),
        u = new os(),
        d = new os(),
        p = new os(),
        m = new os(),
        f = new os(),
        g = new os(),
        _ = new os(),
        v = 0;
      t = i = n = r = s = a = 0;
      for (let e = 0, o = h.length; e < o; e += 9) {
        c.fromArray(h, e),
          u.fromArray(h, e + 3),
          d.fromArray(h, e + 6),
          g.set(0, 0, 0),
          g.add(c).add(u).add(d).divideScalar(3),
          p.subVectors(u, c),
          m.subVectors(d, c);
        let o = f.crossVectors(p, m).length() / 2;
        _.add(f.copy(g).multiplyScalar(o)),
          (v += o),
          (t += (9 * g.x * g.x + c.x * c.x + u.x * u.x + d.x * d.x) * (o / 12)),
          (i += (9 * g.x * g.y + c.x * c.y + u.x * u.y + d.x * d.y) * (o / 12)),
          (n += (9 * g.x * g.z + c.x * c.z + u.x * u.z + d.x * d.z) * (o / 12)),
          (r += (9 * g.y * g.y + c.y * c.y + u.y * u.y + d.y * d.y) * (o / 12)),
          (s += (9 * g.y * g.z + c.y * c.z + u.y * u.z + d.y * d.z) * (o / 12)),
          (a += (9 * g.z * g.z + c.z * c.z + u.z * u.z + d.z * d.z) * (o / 12));
      }
      _.divideScalar(v),
        (t /= v),
        (i /= v),
        (n /= v),
        (r /= v),
        (s /= v),
        (a /= v),
        (t -= _.x * _.x),
        (i -= _.x * _.y),
        (n -= _.x * _.z),
        (r -= _.y * _.y),
        (s -= _.y * _.z),
        (a -= _.z * _.z);
      let x = new om();
      (x.elements[0] = t),
        (x.elements[1] = i),
        (x.elements[2] = n),
        (x.elements[3] = i),
        (x.elements[4] = r),
        (x.elements[5] = s),
        (x.elements[6] = n),
        (x.elements[7] = s),
        (x.elements[8] = a),
        x.eigenDecomposition(hw);
      let y = hw.unitary,
        M = new os(),
        S = new os(),
        b = new os();
      y.extractBasis(M, S, b);
      let T = -1 / 0,
        E = -1 / 0,
        w = -1 / 0,
        A = 1 / 0,
        R = 1 / 0,
        C = 1 / 0;
      for (let t = 0, i = e.length; t < i; t++) {
        let i = e[t];
        (T = Math.max(M.dot(i), T)),
          (E = Math.max(S.dot(i), E)),
          (w = Math.max(b.dot(i), w)),
          (A = Math.min(M.dot(i), A)),
          (R = Math.min(S.dot(i), R)),
          (C = Math.min(b.dot(i), C));
      }
      return (
        M.multiplyScalar(0.5 * (A + T)),
        S.multiplyScalar(0.5 * (R + E)),
        b.multiplyScalar(0.5 * (C + w)),
        this.center.add(M).add(S).add(b),
        (this.halfSizes.x = T - A),
        (this.halfSizes.y = E - R),
        (this.halfSizes.z = w - C),
        this.halfSizes.multiplyScalar(0.5),
        this.rotation.copy(y),
        this
      );
    }
    equals(e) {
      return (
        e.center.equals(this.center) &&
        e.halfSizes.equals(this.halfSizes) &&
        e.rotation.equals(this.rotation)
      );
    }
    toJSON() {
      return {
        type: this.constructor.name,
        center: this.center.toArray([]),
        halfSizes: this.halfSizes.toArray([]),
        rotation: this.rotation.toArray([]),
      };
    }
    fromJSON(e) {
      return (
        this.center.fromArray(e.center),
        this.halfSizes.fromArray(e.halfSizes),
        this.rotation.fromArray(e.rotation),
        this
      );
    }
  })();
new os(),
  new os(),
  new os(),
  new os(),
  new hs(),
  new os(),
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Uint32Array,
  Float32Array,
  new os(),
  new o5(),
  new os(),
  new os(),
  new ls(),
  new os(),
  new os();
const hF = new os(),
  hB = new os(),
  hk = new os(),
  hH = new hs(),
  hV = new os();
class hG extends oP {
  constructor(e = new oq(), t = 0.1, i = 1) {
    super(),
      (this.path = e),
      (this.radius = t),
      (this.predictionFactor = i),
      (this._seek = new oF());
  }
  calculate(e, t) {
    let i = this.path;
    hF.copy(e.velocity).multiplyScalar(this.predictionFactor),
      hB.addVectors(e.position, hF);
    let n = 1 / 0,
      r = i._waypoints.length;
    r = !0 === i.loop ? r : r - 1;
    for (let e = 0; e < r; e++) {
      (hH.from = i._waypoints[e]),
        !0 === i.loop && e === r - 1
          ? (hH.to = i._waypoints[0])
          : (hH.to = i._waypoints[e + 1]),
        hH.closestPointToPoint(hB, !0, hk);
      let t = hB.squaredDistanceTo(hk);
      t < n && ((n = t), hV.copy(hk));
    }
    return (
      n > this.radius * this.radius &&
        i._waypoints.length > 1 &&
        ((this._seek.target = hV), this._seek.calculate(e, t)),
      t
    );
  }
  toJSON() {
    let e = super.toJSON();
    return (
      (e.path = this.path.toJSON()),
      (e.radius = this.radius),
      (e.predictionFactor = this.predictionFactor),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.path.fromJSON(e.path),
      (this.radius = e.radius),
      (this.predictionFactor = e.predictionFactor),
      this
    );
  }
}
const hW = { type: "change" },
  hX = { type: "start" },
  hj = { type: "end" },
  hq = new eU(),
  hJ = new is(),
  hY = Math.cos(70 * O.DEG2RAD),
  hK = new eo(),
  hZ = 2 * Math.PI,
  hQ = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6,
  };
function h$(e) {
  !1 !== this.enabled &&
    (0 === this._pointers.length &&
      (this.domElement.setPointerCapture(e.pointerId),
      this.domElement.addEventListener("pointermove", this._onPointerMove),
      this.domElement.addEventListener("pointerup", this._onPointerUp)),
    this._isTrackingPointer(e) ||
      (this._addPointer(e),
      "touch" === e.pointerType
        ? this._onTouchStart(e)
        : this._onMouseDown(e)));
}
function h0(e) {
  !1 !== this.enabled &&
    ("touch" === e.pointerType ? this._onTouchMove(e) : this._onMouseMove(e));
}
function h1(e) {
  switch ((this._removePointer(e), this._pointers.length)) {
    case 0:
      this.domElement.releasePointerCapture(e.pointerId),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.dispatchEvent(hj),
        (this.state = hQ.NONE);
      break;
    case 1:
      let t = this._pointers[0],
        i = this._pointerPositions[t];
      this._onTouchStart({ pointerId: t, pageX: i.x, pageY: i.y });
  }
}
function h2(e) {
  let t;
  switch (e.button) {
    case 0:
      t = this.mouseButtons.LEFT;
      break;
    case 1:
      t = this.mouseButtons.MIDDLE;
      break;
    case 2:
      t = this.mouseButtons.RIGHT;
      break;
    default:
      t = -1;
  }
  switch (t) {
    case p.DOLLY:
      if (!1 === this.enableZoom) return;
      this._handleMouseDownDolly(e), (this.state = hQ.DOLLY);
      break;
    case p.ROTATE:
      if (e.ctrlKey || e.metaKey || e.shiftKey) {
        if (!1 === this.enablePan) return;
        this._handleMouseDownPan(e), (this.state = hQ.PAN);
      } else {
        if (!1 === this.enableRotate) return;
        this._handleMouseDownRotate(e), (this.state = hQ.ROTATE);
      }
      break;
    case p.PAN:
      if (e.ctrlKey || e.metaKey || e.shiftKey) {
        if (!1 === this.enableRotate) return;
        this._handleMouseDownRotate(e), (this.state = hQ.ROTATE);
      } else {
        if (!1 === this.enablePan) return;
        this._handleMouseDownPan(e), (this.state = hQ.PAN);
      }
      break;
    default:
      this.state = hQ.NONE;
  }
  this.state !== hQ.NONE && this.dispatchEvent(hX);
}
function h3(e) {
  switch (this.state) {
    case hQ.ROTATE:
      if (!1 === this.enableRotate) return;
      this._handleMouseMoveRotate(e);
      break;
    case hQ.DOLLY:
      if (!1 === this.enableZoom) return;
      this._handleMouseMoveDolly(e);
      break;
    case hQ.PAN:
      if (!1 === this.enablePan) return;
      this._handleMouseMovePan(e);
  }
}
function h5(e) {
  !1 !== this.enabled &&
    !1 !== this.enableZoom &&
    this.state === hQ.NONE &&
    (e.preventDefault(),
    this.dispatchEvent(hX),
    this._handleMouseWheel(this._customWheelEvent(e)),
    this.dispatchEvent(hj));
}
function h4(e) {
  !1 !== this.enabled && !1 !== this.enablePan && this._handleKeyDown(e);
}
function h6(e) {
  switch ((this._trackPointer(e), this._pointers.length)) {
    case 1:
      switch (this.touches.ONE) {
        case m.ROTATE:
          if (!1 === this.enableRotate) return;
          this._handleTouchStartRotate(e), (this.state = hQ.TOUCH_ROTATE);
          break;
        case m.PAN:
          if (!1 === this.enablePan) return;
          this._handleTouchStartPan(e), (this.state = hQ.TOUCH_PAN);
          break;
        default:
          this.state = hQ.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case m.DOLLY_PAN:
          if (!1 === this.enableZoom && !1 === this.enablePan) return;
          this._handleTouchStartDollyPan(e), (this.state = hQ.TOUCH_DOLLY_PAN);
          break;
        case m.DOLLY_ROTATE:
          if (!1 === this.enableZoom && !1 === this.enableRotate) return;
          this._handleTouchStartDollyRotate(e),
            (this.state = hQ.TOUCH_DOLLY_ROTATE);
          break;
        default:
          this.state = hQ.NONE;
      }
      break;
    default:
      this.state = hQ.NONE;
  }
  this.state !== hQ.NONE && this.dispatchEvent(hX);
}
function h7(e) {
  switch ((this._trackPointer(e), this.state)) {
    case hQ.TOUCH_ROTATE:
      if (!1 === this.enableRotate) return;
      this._handleTouchMoveRotate(e), this.update();
      break;
    case hQ.TOUCH_PAN:
      if (!1 === this.enablePan) return;
      this._handleTouchMovePan(e), this.update();
      break;
    case hQ.TOUCH_DOLLY_PAN:
      if (!1 === this.enableZoom && !1 === this.enablePan) return;
      this._handleTouchMoveDollyPan(e), this.update();
      break;
    case hQ.TOUCH_DOLLY_ROTATE:
      if (!1 === this.enableZoom && !1 === this.enableRotate) return;
      this._handleTouchMoveDollyRotate(e), this.update();
      break;
    default:
      this.state = hQ.NONE;
  }
}
function h8(e) {
  !1 !== this.enabled && e.preventDefault();
}
function h9(e) {
  "Control" === e.key &&
    ((this._controlActive = !0),
    this.domElement
      .getRootNode()
      .addEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0,
      }));
}
function ce(e) {
  "Control" === e.key &&
    ((this._controlActive = !1),
    this.domElement
      .getRootNode()
      .removeEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0,
      }));
}
function ct(e, t) {
  if (0 === t)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      e
    );
  if (2 !== t && 1 !== t)
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        t
      ),
      e
    );
  {
    let i = e.getIndex();
    if (null === i) {
      let t = [],
        n = e.getAttribute("position");
      if (void 0 === n)
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          e
        );
      for (let e = 0; e < n.count; e++) t.push(e);
      e.setIndex(t), (i = e.getIndex());
    }
    let n = i.count - 2,
      r = [];
    if (2 === t)
      for (let e = 1; e <= n; e++)
        r.push(i.getX(0)), r.push(i.getX(e)), r.push(i.getX(e + 1));
    else
      for (let e = 0; e < n; e++)
        e % 2 == 0
          ? (r.push(i.getX(e)), r.push(i.getX(e + 1)), r.push(i.getX(e + 2)))
          : (r.push(i.getX(e + 2)), r.push(i.getX(e + 1)), r.push(i.getX(e)));
    r.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    let s = e.clone();
    return s.setIndex(r), s.clearGroups(), s;
  }
}
class ci extends aA {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (e) {
        return new cl(e);
      }),
      this.register(function (e) {
        return new ch(e);
      }),
      this.register(function (e) {
        return new cv(e);
      }),
      this.register(function (e) {
        return new cx(e);
      }),
      this.register(function (e) {
        return new cy(e);
      }),
      this.register(function (e) {
        return new cu(e);
      }),
      this.register(function (e) {
        return new cd(e);
      }),
      this.register(function (e) {
        return new cp(e);
      }),
      this.register(function (e) {
        return new cm(e);
      }),
      this.register(function (e) {
        return new co(e);
      }),
      this.register(function (e) {
        return new cf(e);
      }),
      this.register(function (e) {
        return new cc(e);
      }),
      this.register(function (e) {
        return new c_(e);
      }),
      this.register(function (e) {
        return new cg(e);
      }),
      this.register(function (e) {
        return new cs(e);
      }),
      this.register(function (e) {
        return new cM(e);
      }),
      this.register(function (e) {
        return new cS(e);
      });
  }
  load(e, t, i, n) {
    let r;
    let s = this;
    if ("" !== this.resourcePath) r = this.resourcePath;
    else if ("" !== this.path) {
      let t = aJ.extractUrlBase(e);
      r = aJ.resolveURL(t, this.path);
    } else r = aJ.extractUrlBase(e);
    this.manager.itemStart(e);
    let a = function (t) {
        n ? n(t) : console.error(t),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      o = new aP(this.manager);
    o.setPath(this.path),
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (i) {
          try {
            s.parse(
              i,
              r,
              function (i) {
                t(i), s.manager.itemEnd(e);
              },
              a
            );
          } catch (e) {
            a(e);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      -1 !== this.pluginCallbacks.indexOf(e) &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, n) {
    let r;
    let s = {},
      a = {},
      o = new TextDecoder();
    if ("string" == typeof e) r = JSON.parse(e);
    else if (e instanceof ArrayBuffer) {
      if (o.decode(new Uint8Array(e, 0, 4)) === cb) {
        try {
          s[cr.KHR_BINARY_GLTF] = new cE(e);
        } catch (e) {
          n && n(e);
          return;
        }
        r = JSON.parse(s[cr.KHR_BINARY_GLTF].content);
      } else r = JSON.parse(o.decode(e));
    } else r = e;
    if (void 0 === r.asset || r.asset.version[0] < 2) {
      n &&
        n(
          Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    let l = new cj(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let e = 0; e < this.pluginCallbacks.length; e++) {
      let t = this.pluginCallbacks[e](l);
      t.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (a[t.name] = t),
        (s[t.name] = !0);
    }
    if (r.extensionsUsed)
      for (let e = 0; e < r.extensionsUsed.length; ++e) {
        let t = r.extensionsUsed[e],
          i = r.extensionsRequired || [];
        switch (t) {
          case cr.KHR_MATERIALS_UNLIT:
            s[t] = new ca();
            break;
          case cr.KHR_DRACO_MESH_COMPRESSION:
            s[t] = new cw(r, this.dracoLoader);
            break;
          case cr.KHR_TEXTURE_TRANSFORM:
            s[t] = new cA();
            break;
          case cr.KHR_MESH_QUANTIZATION:
            s[t] = new cR();
            break;
          default:
            i.indexOf(t) >= 0 &&
              void 0 === a[t] &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".');
        }
      }
    l.setExtensions(s), l.setPlugins(a), l.parse(i, n);
  }
  parseAsync(e, t) {
    let i = this;
    return new Promise(function (n, r) {
      i.parse(e, t, n, r);
    });
  }
}
function cn() {
  let e = {};
  return {
    get: function (t) {
      return e[t];
    },
    add: function (t, i) {
      e[t] = i;
    },
    remove: function (t) {
      delete e[t];
    },
    removeAll: function () {
      e = {};
    },
  };
}
const cr = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class cs {
  constructor(e) {
    (this.parser = e),
      (this.name = cr.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    let e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i];
      n.extensions &&
        n.extensions[this.name] &&
        void 0 !== n.extensions[this.name].light &&
        e._addNodeRef(this.cache, n.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    let t;
    let i = this.parser,
      n = "light:" + e,
      r = i.cache.get(n);
    if (r) return r;
    let s = i.json,
      a = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e],
      o = new tx(16777215);
    void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], _);
    let l = void 0 !== a.range ? a.range : 0;
    switch (a.type) {
      case "directional":
        (t = new aj(o)).target.position.set(0, 0, -1), t.add(t.target);
        break;
      case "point":
        (t = new aW(o)).distance = l;
        break;
      case "spot":
        ((t = new aB(o)).distance = l),
          (a.spot = a.spot || {}),
          (a.spot.innerConeAngle =
            void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0),
          (a.spot.outerConeAngle =
            void 0 !== a.spot.outerConeAngle
              ? a.spot.outerConeAngle
              : Math.PI / 4),
          (t.angle = a.spot.outerConeAngle),
          (t.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
          t.target.position.set(0, 0, -1),
          t.add(t.target);
        break;
      default:
        throw Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return (
      t.position.set(0, 0, 0),
      (t.decay = 2),
      cV(t, a),
      void 0 !== a.intensity && (t.intensity = a.intensity),
      (t.name = i.createUniqueName(a.name || "light_" + e)),
      (r = Promise.resolve(t)),
      i.cache.add(n, r),
      r
    );
  }
  getDependency(e, t) {
    if ("light" === e) return this._loadLight(t);
  }
  createNodeAttachment(e) {
    let t = this,
      i = this.parser,
      n = i.json.nodes[e],
      r = ((n.extensions && n.extensions[this.name]) || {}).light;
    return void 0 === r
      ? null
      : this._loadLight(r).then(function (e) {
          return i._getNodeRef(t.cache, r, e);
        });
  }
}
class ca {
  constructor() {
    this.name = cr.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return tb;
  }
  extendParams(e, t, i) {
    let n = [];
    (e.color = new tx(1, 1, 1)), (e.opacity = 1);
    let r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        let t = r.baseColorFactor;
        e.color.setRGB(t[0], t[1], t[2], _), (e.opacity = t[3]);
      }
      void 0 !== r.baseColorTexture &&
        n.push(i.assignTexture(e, "map", r.baseColorTexture, g));
    }
    return Promise.all(n);
  }
}
class co {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    let i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    let n = i.extensions[this.name].emissiveStrength;
    return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve();
  }
}
class cl {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    if (
      (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
      void 0 !== s.clearcoatTexture &&
        r.push(i.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
      void 0 !== s.clearcoatRoughnessFactor &&
        (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
      void 0 !== s.clearcoatRoughnessTexture &&
        r.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            s.clearcoatRoughnessTexture
          )
        ),
      void 0 !== s.clearcoatNormalTexture &&
        (r.push(
          i.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)
        ),
        void 0 !== s.clearcoatNormalTexture.scale))
    ) {
      let e = s.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new U(e, e);
    }
    return Promise.all(r);
  }
}
class ch {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    let n = i.extensions[this.name];
    return (
      (t.dispersion = void 0 !== n.dispersion ? n.dispersion : 0),
      Promise.resolve()
    );
  }
}
class cc {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    return (
      void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor),
      void 0 !== s.iridescenceTexture &&
        r.push(i.assignTexture(t, "iridescenceMap", s.iridescenceTexture)),
      void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor),
      void 0 === t.iridescenceThicknessRange &&
        (t.iridescenceThicknessRange = [100, 400]),
      void 0 !== s.iridescenceThicknessMinimum &&
        (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
      void 0 !== s.iridescenceThicknessMaximum &&
        (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
      void 0 !== s.iridescenceThicknessTexture &&
        r.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            s.iridescenceThicknessTexture
          )
        ),
      Promise.all(r)
    );
  }
}
class cu {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [];
    (t.sheenColor = new tx(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    let s = n.extensions[this.name];
    if (void 0 !== s.sheenColorFactor) {
      let e = s.sheenColorFactor;
      t.sheenColor.setRGB(e[0], e[1], e[2], _);
    }
    return (
      void 0 !== s.sheenRoughnessFactor &&
        (t.sheenRoughness = s.sheenRoughnessFactor),
      void 0 !== s.sheenColorTexture &&
        r.push(i.assignTexture(t, "sheenColorMap", s.sheenColorTexture, g)),
      void 0 !== s.sheenRoughnessTexture &&
        r.push(
          i.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)
        ),
      Promise.all(r)
    );
  }
}
class cd {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    return (
      void 0 !== s.transmissionFactor &&
        (t.transmission = s.transmissionFactor),
      void 0 !== s.transmissionTexture &&
        r.push(i.assignTexture(t, "transmissionMap", s.transmissionTexture)),
      Promise.all(r)
    );
  }
}
class cp {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    (t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
      void 0 !== s.thicknessTexture &&
        r.push(i.assignTexture(t, "thicknessMap", s.thicknessTexture)),
      (t.attenuationDistance = s.attenuationDistance || 1 / 0);
    let a = s.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new tx().setRGB(a[0], a[1], a[2], _)),
      Promise.all(r)
    );
  }
}
class cm {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    let n = i.extensions[this.name];
    return (t.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
  }
}
class cf {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    (t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1),
      void 0 !== s.specularTexture &&
        r.push(i.assignTexture(t, "specularIntensityMap", s.specularTexture));
    let a = s.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new tx().setRGB(a[0], a[1], a[2], _)),
      void 0 !== s.specularColorTexture &&
        r.push(
          i.assignTexture(t, "specularColorMap", s.specularColorTexture, g)
        ),
      Promise.all(r)
    );
  }
}
class cg {
  constructor(e) {
    (this.parser = e), (this.name = cr.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    return (
      (t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1),
      void 0 !== s.bumpTexture &&
        r.push(i.assignTexture(t, "bumpMap", s.bumpTexture)),
      Promise.all(r)
    );
  }
}
class c_ {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    let t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? al : null;
  }
  extendMaterialParams(e, t) {
    let i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    let r = [],
      s = n.extensions[this.name];
    return (
      void 0 !== s.anisotropyStrength && (t.anisotropy = s.anisotropyStrength),
      void 0 !== s.anisotropyRotation &&
        (t.anisotropyRotation = s.anisotropyRotation),
      void 0 !== s.anisotropyTexture &&
        r.push(i.assignTexture(t, "anisotropyMap", s.anisotropyTexture)),
      Promise.all(r)
    );
  }
}
class cv {
  constructor(e) {
    (this.parser = e), (this.name = cr.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    let t = this.parser,
      i = t.json,
      n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name]) return null;
    let r = n.extensions[this.name],
      s = t.options.ktx2Loader;
    if (!s) {
      if (
        !(i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
      )
        return null;
      throw Error(
        "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
      );
    }
    return t.loadTextureImage(e, r.source, s);
  }
}
class cx {
  constructor(e) {
    (this.parser = e),
      (this.name = cr.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    let t = this.name,
      i = this.parser,
      n = i.json,
      r = n.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    let s = r.extensions[t],
      a = n.images[s.source],
      o = i.textureLoader;
    if (a.uri) {
      let e = i.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (r) {
      if (r) return i.loadTextureImage(e, s.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          let t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class cy {
  constructor(e) {
    (this.parser = e),
      (this.name = cr.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    let t = this.name,
      i = this.parser,
      n = i.json,
      r = n.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    let s = r.extensions[t],
      a = n.images[s.source],
      o = i.textureLoader;
    if (a.uri) {
      let e = i.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (r) {
      if (r) return i.loadTextureImage(e, s.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          let t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class cM {
  constructor(e) {
    (this.name = cr.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    let t = this.parser.json,
      i = t.bufferViews[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    {
      let e = i.extensions[this.name],
        n = this.parser.getDependency("buffer", e.buffer),
        r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (
          !(
            t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0
          )
        )
          return null;
        throw Error(
          "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
        );
      }
      return n.then(function (t) {
        let i = e.byteOffset || 0,
          n = e.byteLength || 0,
          s = e.count,
          a = e.byteStride,
          o = new Uint8Array(t, i, n);
        return r.decodeGltfBufferAsync
          ? r
              .decodeGltfBufferAsync(s, a, o, e.mode, e.filter)
              .then(function (e) {
                return e.buffer;
              })
          : r.ready.then(function () {
              let t = new ArrayBuffer(s * a);
              return (
                r.decodeGltfBuffer(
                  new Uint8Array(t),
                  s,
                  a,
                  o,
                  e.mode,
                  e.filter
                ),
                t
              );
            });
      });
    }
  }
}
class cS {
  constructor(e) {
    (this.name = cr.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    let t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || void 0 === i.mesh)
      return null;
    for (let e of t.meshes[i.mesh].primitives)
      if (
        e.mode !== cN.TRIANGLES &&
        e.mode !== cN.TRIANGLE_STRIP &&
        e.mode !== cN.TRIANGLE_FAN &&
        void 0 !== e.mode
      )
        return null;
    let n = i.extensions[this.name].attributes,
      r = [],
      s = {};
    for (let e in n)
      r.push(
        this.parser
          .getDependency("accessor", n[e])
          .then((t) => ((s[e] = t), s[e]))
      );
    return r.length < 1
      ? null
      : (r.push(this.parser.createNodeMesh(e)),
        Promise.all(r).then((e) => {
          let t = e.pop(),
            i = t.isGroup ? t.children : [t],
            n = e[0].count,
            r = [];
          for (let e of i) {
            let t = new ez(),
              i = new eo(),
              a = new ea(),
              o = new eo(1, 1, 1),
              l = new r3(e.geometry, e.material, n);
            for (let e = 0; e < n; e++)
              s.TRANSLATION && i.fromBufferAttribute(s.TRANSLATION, e),
                s.ROTATION && a.fromBufferAttribute(s.ROTATION, e),
                s.SCALE && o.fromBufferAttribute(s.SCALE, e),
                l.setMatrixAt(e, t.compose(i, a, o));
            for (let t in s)
              if ("_COLOR_0" === t) {
                let e = s[t];
                l.instanceColor = new rY(e.array, e.itemSize, e.normalized);
              } else
                "TRANSLATION" !== t &&
                  "ROTATION" !== t &&
                  "SCALE" !== t &&
                  e.geometry.setAttribute(t, s[t]);
            te.prototype.copy.call(l, e),
              this.parser.assignFinalMaterial(l),
              r.push(l);
          }
          return t.isGroup ? (t.clear(), t.add(...r), t) : r[0];
        }));
  }
}
const cb = "glTF",
  cT = { JSON: 1313821514, BIN: 5130562 };
class cE {
  constructor(e) {
    (this.name = cr.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    let t = new DataView(e, 0, 12),
      i = new TextDecoder();
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== cb)
    )
      throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw Error("THREE.GLTFLoader: Legacy binary file detected.");
    let n = this.header.length - 12,
      r = new DataView(e, 12),
      s = 0;
    for (; s < n; ) {
      let t = r.getUint32(s, !0);
      s += 4;
      let n = r.getUint32(s, !0);
      if (((s += 4), n === cT.JSON)) {
        let n = new Uint8Array(e, 12 + s, t);
        this.content = i.decode(n);
      } else if (n === cT.BIN) {
        let i = 12 + s;
        this.body = e.slice(i, i + t);
      }
      s += t;
    }
    if (null === this.content)
      throw Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class cw {
  constructor(e, t) {
    if (!t) throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = cr.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    let i = this.json,
      n = this.dracoLoader,
      r = e.extensions[this.name].bufferView,
      s = e.extensions[this.name].attributes,
      a = {},
      o = {},
      l = {};
    for (let e in s) a[cz[e] || e.toLowerCase()] = s[e];
    for (let t in e.attributes) {
      let n = cz[t] || t.toLowerCase();
      if (void 0 !== s[t]) {
        let r = i.accessors[e.attributes[t]],
          s = cI[r.componentType];
        (l[n] = s.name), (o[n] = !0 === r.normalized);
      }
    }
    return t.getDependency("bufferView", r).then(function (e) {
      return new Promise(function (t, i) {
        n.decodeDracoFile(
          e,
          function (e) {
            for (let t in e.attributes) {
              let i = e.attributes[t],
                n = o[t];
              void 0 !== n && (i.normalized = n);
            }
            t(e);
          },
          a,
          l,
          _,
          i
        );
      });
    });
  }
}
class cA {
  constructor() {
    this.name = cr.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((void 0 === t.texCoord || t.texCoord === e.channel) &&
        void 0 === t.offset &&
        void 0 === t.rotation &&
        void 0 === t.scale) ||
        ((e = e.clone()),
        void 0 !== t.texCoord && (e.channel = t.texCoord),
        void 0 !== t.offset && e.offset.fromArray(t.offset),
        void 0 !== t.rotation && (e.rotation = t.rotation),
        void 0 !== t.scale && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class cR {
  constructor() {
    this.name = cr.KHR_MESH_QUANTIZATION;
  }
}
class cC extends ad {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    let t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      r = e * n * 3 + n;
    for (let e = 0; e !== n; e++) t[e] = i[r + e];
    return t;
  }
  interpolate_(e, t, i, n) {
    let r = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      o = 2 * a,
      l = 3 * a,
      h = n - t,
      c = (i - t) / h,
      u = c * c,
      d = u * c,
      p = e * l,
      m = p - l,
      f = -2 * d + 3 * u,
      g = d - u,
      _ = 1 - f,
      v = g - u + c;
    for (let e = 0; e !== a; e++) {
      let t = s[m + e + a],
        i = s[m + e + o] * h,
        n = s[p + e + a],
        l = s[p + e] * h;
      r[e] = _ * t + v * i + f * n + g * l;
    }
    return r;
  }
}
const cP = new ea();
class cL extends cC {
  interpolate_(e, t, i, n) {
    let r = super.interpolate_(e, t, i, n);
    return cP.fromArray(r).normalize().toArray(r), r;
  }
}
const cN = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
  },
  cI = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  cD = {
    9728: 1003,
    9729: 1006,
    9984: 1004,
    9985: 1007,
    9986: 1005,
    9987: 1008,
  },
  cO = { 33071: 1001, 33648: 1002, 10497: 1e3 },
  cU = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  cz = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  cF = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  cB = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 },
  ck = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function cH(e, t, i) {
  for (let n in i.extensions)
    void 0 === e[n] &&
      ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
      (t.userData.gltfExtensions[n] = i.extensions[n]));
}
function cV(e, t) {
  void 0 !== t.extras &&
    ("object" == typeof t.extras
      ? Object.assign(e.userData, t.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
        ));
}
function cG(e) {
  let t = "",
    i = Object.keys(e).sort();
  for (let n = 0, r = i.length; n < r; n++) t += i[n] + ":" + e[i[n]] + ";";
  return t;
}
function cW(e) {
  switch (e) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
const cX = new ez();
class cj {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new cn()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      n = -1,
      r = !1,
      s = -1;
    if ("undefined" != typeof navigator) {
      let e = navigator.userAgent;
      i = !0 === /^((?!chrome|android).)*safari/i.test(e);
      let t = e.match(/Version\/(\d+)/);
      (n = i && t ? parseInt(t[1], 10) : -1),
        (s = (r = e.indexOf("Firefox") > -1)
          ? e.match(/Firefox\/([0-9]+)\./)[1]
          : -1);
    }
    "undefined" == typeof createImageBitmap || (i && n < 17) || (r && s < 98)
      ? (this.textureLoader = new aN(this.options.manager))
      : (this.textureLoader = new aY(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new aP(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      "use-credentials" === this.options.crossOrigin &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    let i = this,
      n = this.json,
      r = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (e) {
          return e.beforeRoot && e.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (t) {
          let s = {
            scene: t[0][n.scene || 0],
            scenes: t[0],
            animations: t[1],
            cameras: t[2],
            asset: n.asset,
            parser: i,
            userData: {},
          };
          return (
            cH(r, s, n),
            cV(s, n),
            Promise.all(
              i._invokeAll(function (e) {
                return e.afterRoot && e.afterRoot(s);
              })
            ).then(function () {
              for (let e of s.scenes) e.updateMatrixWorld();
              e(s);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    let e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      let n = t[i].joints;
      for (let t = 0, i = n.length; t < i; t++) e[n[t]].isBone = !0;
    }
    for (let t = 0, n = e.length; t < n; t++) {
      let n = e[t];
      void 0 !== n.mesh &&
        (this._addNodeRef(this.meshCache, n.mesh),
        void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)),
        void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
    }
  }
  _addNodeRef(e, t) {
    void 0 !== t &&
      (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    let n = i.clone(),
      r = (e, t) => {
        let i = this.associations.get(e);
        for (let [n, s] of (null != i && this.associations.set(t, i),
        e.children.entries()))
          r(s, t.children[n]);
      };
    return r(i, n), (n.name += "_instance_" + e.uses[t]++), n;
  }
  _invokeOne(e) {
    let t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      let n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    let t = Object.values(this.plugins);
    t.unshift(this);
    let i = [];
    for (let n = 0; n < t.length; n++) {
      let r = e(t[n]);
      r && i.push(r);
    }
    return i;
  }
  getDependency(e, t) {
    let i = e + ":" + t,
      n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function (e) {
            return e.loadNode && e.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function (e) {
            return e.loadMesh && e.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function (e) {
            return e.loadBufferView && e.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function (e) {
            return e.loadMaterial && e.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function (e) {
            return e.loadTexture && e.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function (e) {
            return e.loadAnimation && e.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (
            !(n = this._invokeOne(function (i) {
              return i != this && i.getDependency && i.getDependency(e, t);
            }))
          )
            throw Error("Unknown type: " + e);
      }
      this.cache.add(i, n);
    }
    return n;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      let i = this;
      (t = Promise.all(
        (this.json[e + ("mesh" === e ? "es" : "s")] || []).map(function (t, n) {
          return i.getDependency(e, n);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    let t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && "arraybuffer" !== t.type)
      throw Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (void 0 === t.uri && 0 === e)
      return Promise.resolve(this.extensions[cr.KHR_BINARY_GLTF].body);
    let n = this.options;
    return new Promise(function (e, r) {
      i.load(aJ.resolveURL(t.uri, n.path), e, void 0, function () {
        r(Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  loadBufferView(e) {
    let t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (e) {
      let i = t.byteLength || 0,
        n = t.byteOffset || 0;
      return e.slice(n, n + i);
    });
  }
  loadAccessor(e) {
    let t = this,
      i = this.json,
      n = this.json.accessors[e];
    if (void 0 === n.bufferView && void 0 === n.sparse) {
      let e = cU[n.type],
        t = cI[n.componentType],
        i = !0 === n.normalized;
      return Promise.resolve(new tw(new t(n.count * e), e, i));
    }
    let r = [];
    return (
      void 0 !== n.bufferView
        ? r.push(this.getDependency("bufferView", n.bufferView))
        : r.push(null),
      void 0 !== n.sparse &&
        (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
      Promise.all(r).then(function (e) {
        let r;
        let s = e[0],
          a = cU[n.type],
          o = cI[n.componentType],
          l = o.BYTES_PER_ELEMENT,
          h = l * a,
          c = n.byteOffset || 0,
          u =
            void 0 !== n.bufferView
              ? i.bufferViews[n.bufferView].byteStride
              : void 0,
          d = !0 === n.normalized;
        if (u && u !== h) {
          let e = Math.floor(c / u),
            i =
              "InterleavedBuffer:" +
              n.bufferView +
              ":" +
              n.componentType +
              ":" +
              e +
              ":" +
              n.count,
            h = t.cache.get(i);
          h ||
            ((h = new rL(new o(s, e * u, (n.count * u) / l), u / l)),
            t.cache.add(i, h)),
            (r = new rI(h, a, (c % u) / l, d));
        } else r = new tw(null === s ? new o(n.count * a) : new o(s, c, n.count * a), a, d);
        if (void 0 !== n.sparse) {
          let t = cU.SCALAR,
            i = cI[n.sparse.indices.componentType],
            l = n.sparse.indices.byteOffset || 0,
            h = n.sparse.values.byteOffset || 0,
            c = new i(e[1], l, n.sparse.count * t),
            u = new o(e[2], h, n.sparse.count * a);
          null !== s && (r = new tw(r.array.slice(), r.itemSize, r.normalized)),
            (r.normalized = !1);
          for (let e = 0, t = c.length; e < t; e++) {
            let t = c[e];
            if (
              (r.setX(t, u[e * a]),
              a >= 2 && r.setY(t, u[e * a + 1]),
              a >= 3 && r.setZ(t, u[e * a + 2]),
              a >= 4 && r.setW(t, u[e * a + 3]),
              a >= 5)
            )
              throw Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
          r.normalized = d;
        }
        return r;
      })
    );
  }
  loadTexture(e) {
    let t = this.json,
      i = this.options,
      n = t.textures[e].source,
      r = t.images[n],
      s = this.textureLoader;
    if (r.uri) {
      let e = i.manager.getHandler(r.uri);
      null !== e && (s = e);
    }
    return this.loadTextureImage(e, n, s);
  }
  loadTextureImage(e, t, i) {
    let n = this,
      r = this.json,
      s = r.textures[e],
      a = r.images[t],
      o = (a.uri || a.bufferView) + ":" + s.sampler;
    if (this.textureCache[o]) return this.textureCache[o];
    let l = this.loadImageSource(t, i)
      .then(function (t) {
        (t.flipY = !1),
          (t.name = s.name || a.name || ""),
          "" === t.name &&
            "string" == typeof a.uri &&
            !1 === a.uri.startsWith("data:image/") &&
            (t.name = a.uri);
        let i = (r.samplers || {})[s.sampler] || {};
        return (
          (t.magFilter = cD[i.magFilter] || 1006),
          (t.minFilter = cD[i.minFilter] || 1008),
          (t.wrapS = cO[i.wrapS] || 1e3),
          (t.wrapT = cO[i.wrapT] || 1e3),
          n.associations.set(t, { textures: e }),
          t
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[o] = l), l;
  }
  loadImageSource(e, t) {
    let i = this.json,
      n = this.options;
    if (void 0 !== this.sourceCache[e])
      return this.sourceCache[e].then((e) => e.clone());
    let r = i.images[e],
      s = self.URL || self.webkitURL,
      a = r.uri || "",
      o = !1;
    if (void 0 !== r.bufferView)
      a = this.getDependency("bufferView", r.bufferView).then(function (e) {
        o = !0;
        let t = new Blob([e], { type: r.mimeType });
        return (a = s.createObjectURL(t));
      });
    else if (void 0 === r.uri)
      throw Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    let l = Promise.resolve(a)
      .then(function (e) {
        return new Promise(function (i, r) {
          let s = i;
          !0 === t.isImageBitmapLoader &&
            (s = function (e) {
              let t = new et(e);
              (t.needsUpdate = !0), i(t);
            }),
            t.load(aJ.resolveURL(e, n.path), s, void 0, r);
        });
      })
      .then(function (e) {
        var t;
        return (
          !0 === o && s.revokeObjectURL(a),
          cV(e, r),
          (e.userData.mimeType =
            r.mimeType ||
            ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 ||
            0 === t.search(/^data\:image\/jpeg/)
              ? "image/jpeg"
              : t.search(/\.webp($|\?)/i) > 0 ||
                0 === t.search(/^data\:image\/webp/)
              ? "image/webp"
              : "image/png")),
          e
        );
      })
      .catch(function (e) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", a), e);
      });
    return (this.sourceCache[e] = l), l;
  }
  assignTexture(e, t, i, n) {
    let r = this;
    return this.getDependency("texture", i.index).then(function (s) {
      if (!s) return null;
      if (
        (void 0 !== i.texCoord &&
          i.texCoord > 0 &&
          ((s = s.clone()).channel = i.texCoord),
        r.extensions[cr.KHR_TEXTURE_TRANSFORM])
      ) {
        let e =
          void 0 !== i.extensions
            ? i.extensions[cr.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (e) {
          let t = r.associations.get(s);
          (s = r.extensions[cr.KHR_TEXTURE_TRANSFORM].extendTexture(s, e)),
            r.associations.set(s, t);
        }
      }
      return void 0 !== n && (s.colorSpace = n), (e[t] = s), s;
    });
  }
  assignFinalMaterial(e) {
    let t = e.geometry,
      i = e.material,
      n = void 0 === t.attributes.tangent,
      r = void 0 !== t.attributes.color,
      s = void 0 === t.attributes.normal;
    if (e.isPoints) {
      let e = "PointsMaterial:" + i.uuid,
        t = this.cache.get(e);
      t ||
        ((t = new sl()),
        tS.prototype.copy.call(t, i),
        t.color.copy(i.color),
        (t.map = i.map),
        (t.sizeAttenuation = !1),
        this.cache.add(e, t)),
        (i = t);
    } else if (e.isLine) {
      let e = "LineBasicMaterial:" + i.uuid,
        t = this.cache.get(e);
      t ||
        ((t = new r5()),
        tS.prototype.copy.call(t, i),
        t.color.copy(i.color),
        (t.map = i.map),
        this.cache.add(e, t)),
        (i = t);
    }
    if (n || r || s) {
      let e = "ClonedMaterial:" + i.uuid + ":";
      n && (e += "derivative-tangents:"),
        r && (e += "vertex-colors:"),
        s && (e += "flat-shading:");
      let t = this.cache.get(e);
      t ||
        ((t = i.clone()),
        r && (t.vertexColors = !0),
        s && (t.flatShading = !0),
        n &&
          (t.normalScale && (t.normalScale.y *= -1),
          t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
        this.cache.add(e, t),
        this.associations.set(t, this.associations.get(i))),
        (i = t);
    }
    e.material = i;
  }
  getMaterialType() {
    return ao;
  }
  loadMaterial(e) {
    let t;
    let i = this,
      n = this.json,
      r = this.extensions,
      s = n.materials[e],
      a = {},
      o = s.extensions || {},
      l = [];
    if (o[cr.KHR_MATERIALS_UNLIT]) {
      let e = r[cr.KHR_MATERIALS_UNLIT];
      (t = e.getMaterialType()), l.push(e.extendParams(a, s, i));
    } else {
      let n = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new tx(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(n.baseColorFactor))
      ) {
        let e = n.baseColorFactor;
        a.color.setRGB(e[0], e[1], e[2], _), (a.opacity = e[3]);
      }
      void 0 !== n.baseColorTexture &&
        l.push(i.assignTexture(a, "map", n.baseColorTexture, g)),
        (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
        (a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
        void 0 !== n.metallicRoughnessTexture &&
          (l.push(
            i.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)
          ),
          l.push(
            i.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture)
          )),
        (t = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        })),
        l.push(
          Promise.all(
            this._invokeAll(function (t) {
              return t.extendMaterialParams && t.extendMaterialParams(e, a);
            })
          )
        );
    }
    !0 === s.doubleSided && (a.side = 2);
    let h = s.alphaMode || ck.OPAQUE;
    if (
      (h === ck.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === ck.MASK &&
            (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
      void 0 !== s.normalTexture &&
        t !== tb &&
        (l.push(i.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new U(1, 1)),
        void 0 !== s.normalTexture.scale))
    ) {
      let e = s.normalTexture.scale;
      a.normalScale.set(e, e);
    }
    if (
      (void 0 !== s.occlusionTexture &&
        t !== tb &&
        (l.push(i.assignTexture(a, "aoMap", s.occlusionTexture)),
        void 0 !== s.occlusionTexture.strength &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      void 0 !== s.emissiveFactor && t !== tb)
    ) {
      let e = s.emissiveFactor;
      a.emissive = new tx().setRGB(e[0], e[1], e[2], _);
    }
    return (
      void 0 !== s.emissiveTexture &&
        t !== tb &&
        l.push(i.assignTexture(a, "emissiveMap", s.emissiveTexture, g)),
      Promise.all(l).then(function () {
        let n = new t(a);
        return (
          s.name && (n.name = s.name),
          cV(n, s),
          i.associations.set(n, { materials: e }),
          s.extensions && cH(r, n, s),
          n
        );
      })
    );
  }
  createUniqueName(e) {
    let t = a3.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    let t = this,
      i = this.extensions,
      n = this.primitiveCache,
      r = [];
    for (let s = 0, a = e.length; s < a; s++) {
      let a = e[s],
        o = (function (e) {
          let t;
          let i = e.extensions && e.extensions[cr.KHR_DRACO_MESH_COMPRESSION];
          if (
            ((t = i
              ? "draco:" +
                i.bufferView +
                ":" +
                i.indices +
                ":" +
                cG(i.attributes)
              : e.indices + ":" + cG(e.attributes) + ":" + e.mode),
            void 0 !== e.targets)
          )
            for (let i = 0, n = e.targets.length; i < n; i++)
              t += ":" + cG(e.targets[i]);
          return t;
        })(a),
        l = n[o];
      if (l) r.push(l.promise);
      else {
        let e;
        (e =
          a.extensions && a.extensions[cr.KHR_DRACO_MESH_COMPRESSION]
            ? (function (e) {
                return i[cr.KHR_DRACO_MESH_COMPRESSION]
                  .decodePrimitive(e, t)
                  .then(function (i) {
                    return cq(i, e, t);
                  });
              })(a)
            : cq(new tz(), a, t)),
          (n[o] = { primitive: a, promise: e }),
          r.push(e);
      }
    }
    return Promise.all(r);
  }
  loadMesh(e) {
    let t = this,
      i = this.json,
      n = this.extensions,
      r = i.meshes[e],
      s = r.primitives,
      a = [];
    for (let e = 0, t = s.length; e < t; e++) {
      var o;
      let t =
        void 0 === s[e].material
          ? (void 0 === (o = this.cache).DefaultMaterial &&
              (o.DefaultMaterial = new ao({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: 0,
              })),
            o.DefaultMaterial)
          : this.getDependency("material", s[e].material);
      a.push(t);
    }
    return (
      a.push(t.loadGeometries(s)),
      Promise.all(a).then(function (i) {
        let a = i.slice(0, i.length - 1),
          o = i[i.length - 1],
          l = [];
        for (let i = 0, h = o.length; i < h; i++) {
          let h;
          let c = o[i],
            u = s[i],
            d = a[i];
          if (
            u.mode === cN.TRIANGLES ||
            u.mode === cN.TRIANGLE_STRIP ||
            u.mode === cN.TRIANGLE_FAN ||
            void 0 === u.mode
          )
            !0 ===
              (h = !0 === r.isSkinnedMesh ? new rG(c, d) : new tY(c, d))
                .isSkinnedMesh && h.normalizeSkinWeights(),
              u.mode === cN.TRIANGLE_STRIP
                ? (h.geometry = ct(h.geometry, 1))
                : u.mode === cN.TRIANGLE_FAN &&
                  (h.geometry = ct(h.geometry, 2));
          else if (u.mode === cN.LINES) h = new sa(c, d);
          else if (u.mode === cN.LINE_STRIP) h = new si(c, d);
          else if (u.mode === cN.LINE_LOOP) h = new so(c, d);
          else if (u.mode === cN.POINTS) h = new sp(c, d);
          else
            throw Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + u.mode
            );
          Object.keys(h.geometry.morphAttributes).length > 0 &&
            (function (e, t) {
              if ((e.updateMorphTargets(), void 0 !== t.weights))
                for (let i = 0, n = t.weights.length; i < n; i++)
                  e.morphTargetInfluences[i] = t.weights[i];
              if (t.extras && Array.isArray(t.extras.targetNames)) {
                let i = t.extras.targetNames;
                if (e.morphTargetInfluences.length === i.length) {
                  e.morphTargetDictionary = {};
                  for (let t = 0, n = i.length; t < n; t++)
                    e.morphTargetDictionary[i[t]] = t;
                } else
                  console.warn(
                    "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
                  );
              }
            })(h, r),
            (h.name = t.createUniqueName(r.name || "mesh_" + e)),
            cV(h, r),
            u.extensions && cH(n, h, u),
            t.assignFinalMaterial(h),
            l.push(h);
        }
        for (let i = 0, n = l.length; i < n; i++)
          t.associations.set(l[i], { meshes: e, primitives: i });
        if (1 === l.length) return r.extensions && cH(n, l[0], r), l[0];
        let h = new ry();
        r.extensions && cH(n, h, r), t.associations.set(h, { meshes: e });
        for (let e = 0, t = l.length; e < t; e++) h.add(l[e]);
        return h;
      })
    );
  }
  loadCamera(e) {
    let t;
    let i = this.json.cameras[e],
      n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      "perspective" === i.type
        ? (t = new t7(
            O.radToDeg(n.yfov),
            n.aspectRatio || 1,
            n.znear || 1,
            n.zfar || 2e6
          ))
        : "orthographic" === i.type &&
          (t = new iE(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      cV(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    let t = this.json.skins[e],
      i = [];
    for (let e = 0, n = t.joints.length; e < n; e++)
      i.push(this._loadNodeShallow(t.joints[e]));
    return (
      void 0 !== t.inverseBindMatrices
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (e) {
        let i = e.pop(),
          n = [],
          r = [];
        for (let s = 0, a = e.length; s < a; s++) {
          let a = e[s];
          if (a) {
            n.push(a);
            let e = new ez();
            null !== i && e.fromArray(i.array, 16 * s), r.push(e);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[s]
            );
        }
        return new rJ(n, r);
      })
    );
  }
  loadAnimation(e) {
    let t = this.json,
      i = this,
      n = t.animations[e],
      r = n.name ? n.name : "animation_" + e,
      s = [],
      a = [],
      o = [],
      l = [],
      h = [];
    for (let e = 0, t = n.channels.length; e < t; e++) {
      let t = n.channels[e],
        i = n.samplers[t.sampler],
        r = t.target,
        c = r.node,
        u = void 0 !== n.parameters ? n.parameters[i.input] : i.input,
        d = void 0 !== n.parameters ? n.parameters[i.output] : i.output;
      void 0 !== r.node &&
        (s.push(this.getDependency("node", c)),
        a.push(this.getDependency("accessor", u)),
        o.push(this.getDependency("accessor", d)),
        l.push(i),
        h.push(r));
    }
    return Promise.all([
      Promise.all(s),
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(h),
    ]).then(function (e) {
      let t = e[0],
        n = e[1],
        s = e[2],
        a = e[3],
        o = e[4],
        l = [];
      for (let e = 0, r = t.length; e < r; e++) {
        let r = t[e],
          h = n[e],
          c = s[e],
          u = a[e],
          d = o[e];
        if (void 0 === r) continue;
        r.updateMatrix && r.updateMatrix();
        let p = i._createAnimationTracks(r, h, c, u, d);
        if (p) for (let e = 0; e < p.length; e++) l.push(p[e]);
      }
      return new aT(r, void 0, l);
    });
  }
  createNodeMesh(e) {
    let t = this.json,
      i = this,
      n = t.nodes[e];
    return void 0 === n.mesh
      ? null
      : i.getDependency("mesh", n.mesh).then(function (e) {
          let t = i._getNodeRef(i.meshCache, n.mesh, e);
          return (
            void 0 !== n.weights &&
              t.traverse(function (e) {
                if (e.isMesh)
                  for (let t = 0, i = n.weights.length; t < i; t++)
                    e.morphTargetInfluences[t] = n.weights[t];
              }),
            t
          );
        });
  }
  loadNode(e) {
    let t = this.json.nodes[e],
      i = this._loadNodeShallow(e),
      n = [],
      r = t.children || [];
    for (let e = 0, t = r.length; e < t; e++)
      n.push(this.getDependency("node", r[e]));
    let s =
      void 0 === t.skin
        ? Promise.resolve(null)
        : this.getDependency("skin", t.skin);
    return Promise.all([i, Promise.all(n), s]).then(function (e) {
      let t = e[0],
        i = e[1],
        n = e[2];
      null !== n &&
        t.traverse(function (e) {
          e.isSkinnedMesh && e.bind(n, cX);
        });
      for (let e = 0, n = i.length; e < n; e++) t.add(i[e]);
      return t;
    });
  }
  _loadNodeShallow(e) {
    let t = this.json,
      i = this.extensions,
      n = this;
    if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
    let r = t.nodes[e],
      s = r.name ? n.createUniqueName(r.name) : "",
      a = [],
      o = n._invokeOne(function (t) {
        return t.createNodeMesh && t.createNodeMesh(e);
      });
    return (
      o && a.push(o),
      void 0 !== r.camera &&
        a.push(
          n.getDependency("camera", r.camera).then(function (e) {
            return n._getNodeRef(n.cameraCache, r.camera, e);
          })
        ),
      n
        ._invokeAll(function (t) {
          return t.createNodeAttachment && t.createNodeAttachment(e);
        })
        .forEach(function (e) {
          a.push(e);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (t) {
        let a;
        if (
          (a =
            !0 === r.isBone
              ? new rW()
              : t.length > 1
              ? new ry()
              : 1 === t.length
              ? t[0]
              : new te()) !== t[0]
        )
          for (let e = 0, i = t.length; e < i; e++) a.add(t[e]);
        if (
          (r.name && ((a.userData.name = r.name), (a.name = s)),
          cV(a, r),
          r.extensions && cH(i, a, r),
          void 0 !== r.matrix)
        ) {
          let e = new ez();
          e.fromArray(r.matrix), a.applyMatrix4(e);
        } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
        return (
          n.associations.has(a) || n.associations.set(a, {}),
          (n.associations.get(a).nodes = e),
          a
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    let t = this.extensions,
      i = this.json.scenes[e],
      n = this,
      r = new ry();
    i.name && (r.name = n.createUniqueName(i.name)),
      cV(r, i),
      i.extensions && cH(t, r, i);
    let s = i.nodes || [],
      a = [];
    for (let e = 0, t = s.length; e < t; e++)
      a.push(n.getDependency("node", s[e]));
    return Promise.all(a).then(function (e) {
      for (let t = 0, i = e.length; t < i; t++) r.add(e[t]);
      return (
        (n.associations = ((e) => {
          let t = new Map();
          for (let [e, i] of n.associations)
            (e instanceof tS || e instanceof et) && t.set(e, i);
          return (
            e.traverse((e) => {
              let i = n.associations.get(e);
              null != i && t.set(e, i);
            }),
            t
          );
        })(r)),
        r
      );
    });
  }
  _createAnimationTracks(e, t, i, n, r) {
    let s;
    let a = [],
      o = e.name ? e.name : e.uuid,
      l = [];
    switch (
      (cF[r.path] === cF.weights
        ? e.traverse(function (e) {
            e.morphTargetInfluences && l.push(e.name ? e.name : e.uuid);
          })
        : l.push(o),
      cF[r.path])
    ) {
      case cF.weights:
        s = ax;
        break;
      case cF.rotation:
        s = aM;
        break;
      case cF.position:
      case cF.scale:
        s = ab;
        break;
      default:
        s = 1 === i.itemSize ? ax : ab;
    }
    let h = void 0 !== n.interpolation ? cB[n.interpolation] : 2301,
      c = this._getArrayFromAccessor(i);
    for (let e = 0, i = l.length; e < i; e++) {
      let i = new s(l[e] + "." + cF[r.path], t.array, c, h);
      "CUBICSPLINE" === n.interpolation &&
        this._createCubicSplineTrackInterpolant(i),
        a.push(i);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      let e = cW(t.constructor),
        i = new Float32Array(t.length);
      for (let n = 0, r = t.length; n < r; n++) i[n] = t[n] * e;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (e) {
      return new (this instanceof aM ? cL : cC)(
        this.times,
        this.values,
        this.getValueSize() / 3,
        e
      );
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function cq(e, t, i) {
  let n = t.attributes,
    r = [];
  for (let t in n) {
    let s = cz[t] || t.toLowerCase();
    s in e.attributes ||
      r.push(
        (function (t, n) {
          return i.getDependency("accessor", t).then(function (t) {
            e.setAttribute(n, t);
          });
        })(n[t], s)
      );
  }
  if (void 0 !== t.indices && !e.index) {
    let n = i.getDependency("accessor", t.indices).then(function (t) {
      e.setIndex(t);
    });
    r.push(n);
  }
  return (
    q.workingColorSpace !== _ &&
      "COLOR_0" in n &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${q.workingColorSpace}" not supported.`
      ),
    cV(e, t),
    !(function (e, t, i) {
      let n = t.attributes,
        r = new ec();
      if (void 0 === n.POSITION) return;
      {
        let e = i.json.accessors[n.POSITION],
          t = e.min,
          s = e.max;
        if (void 0 !== t && void 0 !== s) {
          if (
            (r.set(new eo(t[0], t[1], t[2]), new eo(s[0], s[1], s[2])),
            e.normalized)
          ) {
            let t = cW(cI[e.componentType]);
            r.min.multiplyScalar(t), r.max.multiplyScalar(t);
          }
        } else {
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
          return;
        }
      }
      let s = t.targets;
      if (void 0 !== s) {
        let e = new eo(),
          t = new eo();
        for (let n = 0, r = s.length; n < r; n++) {
          let r = s[n];
          if (void 0 !== r.POSITION) {
            let n = i.json.accessors[r.POSITION],
              s = n.min,
              a = n.max;
            if (void 0 !== s && void 0 !== a) {
              if (
                (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                n.normalized)
              ) {
                let e = cW(cI[n.componentType]);
                t.multiplyScalar(e);
              }
              e.max(t);
            } else
              console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
          }
        }
        r.expandByVector(e);
      }
      e.boundingBox = r;
      let a = new eR();
      r.getCenter(a.center),
        (a.radius = r.min.distanceTo(r.max) / 2),
        (e.boundingSphere = a);
    })(e, t, i),
    Promise.all(r).then(function () {
      return void 0 !== t.targets
        ? (function (e, t, i) {
            let n = !1,
              r = !1,
              s = !1;
            for (let e = 0, i = t.length; e < i; e++) {
              let i = t[e];
              if (
                (void 0 !== i.POSITION && (n = !0),
                void 0 !== i.NORMAL && (r = !0),
                void 0 !== i.COLOR_0 && (s = !0),
                n && r && s)
              )
                break;
            }
            if (!n && !r && !s) return Promise.resolve(e);
            let a = [],
              o = [],
              l = [];
            for (let h = 0, c = t.length; h < c; h++) {
              let c = t[h];
              if (n) {
                let t =
                  void 0 !== c.POSITION
                    ? i.getDependency("accessor", c.POSITION)
                    : e.attributes.position;
                a.push(t);
              }
              if (r) {
                let t =
                  void 0 !== c.NORMAL
                    ? i.getDependency("accessor", c.NORMAL)
                    : e.attributes.normal;
                o.push(t);
              }
              if (s) {
                let t =
                  void 0 !== c.COLOR_0
                    ? i.getDependency("accessor", c.COLOR_0)
                    : e.attributes.color;
                l.push(t);
              }
            }
            return Promise.all([
              Promise.all(a),
              Promise.all(o),
              Promise.all(l),
            ]).then(function (t) {
              let i = t[0],
                a = t[1],
                o = t[2];
              return (
                n && (e.morphAttributes.position = i),
                r && (e.morphAttributes.normal = a),
                s && (e.morphAttributes.color = o),
                (e.morphTargetsRelative = !0),
                e
              );
            });
          })(e, t.targets, i)
        : e;
    })
  );
}
const cJ = new eo(),
  cY = new ea(),
  cK = new eo(),
  cZ = new ez(),
  cQ = new ez(),
  c$ = {
    icon: {
      title: "Education",
      description:
        "Education in a smart city leverages advanced technologies and data-driven approaches to enhance learning experiences and accessibility. Smart educational systems integrate digital tools, such as online platforms, interactive learning environments, and virtual classrooms, allowing for personalized and flexible learning opportunities. This integration facilitates collaboration between students, educators, and communities, fostering a more engaging and inclusive educational landscape. Data analytics plays a key role in assessing student performance, enabling educators to tailor curricula and support to individual needs. Additionally, smart cities often promote lifelong learning initiatives, offering residents access to various educational resources, from vocational training to digital literacy programs, ensuring that all community members can thrive in an increasingly digital world. By incorporating technology into education, smart cities aim to equip residents with the skills and knowledge necessary to navigate and contribute to a rapidly evolving society, ultimately enhancing the overall quality of life.",
    },
    Cylinder001: {
      title: "Smart Health",
      description:
        "Smart health in a smart city leverages digital health technologies, data analytics, and interconnected systems to provide accessible, efficient, and personalized healthcare services. Through IoT devices, wearable tech, and telemedicine, residents can monitor their health and access medical services remotely, reducing the strain on physical healthcare facilities. Smart health initiatives use real-time data to track disease outbreaks, manage public health resources, and support emergency response systems. These systems often integrate with other smart city infrastructure, enabling better health outcomes and fostering a proactive, preventative approach to urban healthcare.",
    },
    icon2: {
      title: "Green Park",
      description:
        "A green park in a smart city is a sustainable, tech-enhanced public space designed to promote environmental health, biodiversity, and community well-being. These parks often feature native plantings, energy-efficient lighting, and smart irrigation systems that conserve water.IoT sensors monitor environmental factors like air quality, soil moisture, and visitor traffic to optimize park maintenance and support ecological balance.Green parks also provide recreational areas, walking trails, and spaces for outdoor activities, helping to improve urban air quality, reduce the heat island effect, and offer residents a natural retreat within the city.By integrating green spaces with smart city technology, green parks support sustainability, enhance urban resilience, and foster a connection between residents and nature.",
    },
    icon3: {
      title: "Green Building",
      description:
        "Green buildings in a smart city are designed to reduce environmental impact through energy-efficient practices, sustainable materials, and eco-friendly construction methods. These buildings optimize natural light, ventilation, and water usage and often incorporate renewable energy sources like solar or wind.  Advanced technologies monitor energy consumption and indoor air quality,  providing healthier and more sustainable spaces for occupants Additionally, green buildings focus on reducing carbon emissions and waste, aiming for high energy ratings and certifications like LEED or BREEAM. Ultimately, they contribute to the smart city's sustainability goals, promoting eco-conscious urban growth.",
    },
    icon4: {
      title: "Internet of Things",
      description:
        "The Internet of Things (IoT) in a smart city refers to the network of interconnected devices and sensors that communicate and share data to enhance urban living. This technology enables real-time monitoring and management of various city functions, including transportation, energy usage, waste management, and public safety. For instance, smart traffic lights can adjust based on traffic flow, while smart waste bins signal when they need to be emptied. IoT devices improve the efficiency of public services, enhance resource allocation, and provide valuable insights for urban planning. By leveraging data analytics and connectivity, IoT transforms cities into more responsive, efficient, and sustainable environments, ultimately improving the quality of life for residents.",
    },
    icon5: {
      title: "Smart Energy",
      description:
        "Smart energy in a smart city refers to the integration of advanced technologies and data analytics to optimize energy generation, distribution, and consumption. This approach incorporates renewable energy sources, such as solar and wind, alongside traditional power systems, allowing for a more resilient and sustainable energy grid. Smart meters and IoT devices provide real-time monitoring of energy usage, enabling consumers and utilities to make informed decisions that enhance efficiency and reduce costs. Demand response systems adjust energy consumption during peak times to alleviate strain on the grid. Additionally, smart energy systems facilitate energy storage solutions and electric vehicle integration, promoting a cleaner urban environment and supporting the transition to a low-carbon economy. By leveraging smart technology, cities can improve energy efficiency, enhance grid reliability, and reduce environmental impacts.",
    },
    icon6: {
      title: "Smart Transportation",
      description:
        "Smart public transportation in a smart city refers to the integration of advanced technologies and data systems to enhance the efficiency, accessibility, and user experience of public transit services. This includes the use of real-time tracking systems that provide commuters with accurate information about vehicle arrivals and delays through mobile apps and digital displays at stations. Smart payment systems allow for seamless fare collection, enabling contactless payments and integrated ticketing across different modes of transport. Additionally, smart public transportation often employs data analytics to optimize routes, schedules, and capacity based on demand patterns, which can help reduce overcrowding and improve service reliability. Furthermore, the integration of electric and autonomous vehicles into public transit networks supports sustainability goals and reduces environmental impact. Overall, smart public transportation aims to create a more efficient, user-friendly, and environmentally friendly transit system, encouraging greater use of public transport and contributing to the overall livability of urban areas.",
    },
    icon7: {
      title: "Smart Building",
      description:
        "Smart transportation in a smart city involves integrating advanced technologies to improve urban mobility, reduce congestion, and enhance efficiency across transportation systems. This typically includes using IoT sensors, real-time data analytics, and AI to monitor and manage traffic flow, optimize public transit schedules, and enable smart parking solutions. Autonomous vehicles, shared mobility services, and electrified transport also contribute to a more sustainable and accessible city, while apps and digital platforms provide real-time information, enabling residents to make informed travel decisions. The goal of smart transportation is to create a more connected, efficient, and eco-friendly urban environment.",
    },
    icon8: {
      title: "Smart Health",
      description:
        "Smart health in a smart city leverages digital health technologies, data analytics, and interconnected systems to provide accessible, efficient, and personalized healthcare services. Through IoT devices, wearable tech, and telemedicine, residents can monitor their health and access medical services remotely, reducing the strain on physical healthcare facilities. Smart health initiatives use real-time data to track disease outbreaks, manage public health resources, and support emergency response systems. These systems often integrate with other smart city infrastructure, enabling better health outcomes and fostering a proactive, preventative approach to urban healthcare.",
    },
    icon9: {
      title: "Smart House",
      description:
        "A smart house in a smart city is a residential space equipped with advanced technologies that automate and enhance daily living. These homes utilize Internet of Things (IoT) devices to enable seamless connectivity and control over various systems, including lighting, heating, security, and appliances. Residents can manage their home environment remotely via smartphones or voice-activated assistants, allowing for energy efficiency, improved security, and personalized comfort. Smart houses often incorporate renewable energy sources, such as solar panels, and utilize smart meters to monitor and optimize energy consumption. By integrating with the broader smart city infrastructure, smart houses contribute to sustainability goals and create a more efficient, responsive urban living experience.",
    },
    icon10: {
      title: "Traffic Management",
      description:
        "Traffic management in a smart city involves the use of advanced technologies and data analytics to optimize the flow of vehicles and pedestrians, enhancing urban mobility and reducing congestion. Smart traffic management systems utilize IoT sensors, cameras, and GPS data to monitor real-time traffic conditions, enabling dynamic adjustments to traffic signals, road signage, and routing. These systems can prioritize public transportation, manage traffic during peak hours, and provide real-time updates to drivers through mobile apps or digital displays. By analyzing traffic patterns and trends, cities can make informed decisions about infrastructure improvements, public transit planning, and emergency response strategies. The goal of smart traffic management is to create a more efficient, safer, and sustainable urban transportation system that enhances the overall quality of life for residents.",
    },
  },
  c0 = new (class {
    constructor(e = {}) {
      let t,
        i,
        n,
        r,
        s,
        a,
        o,
        l,
        h,
        c,
        u,
        d,
        p,
        m,
        f,
        v,
        x,
        y,
        M,
        S,
        b,
        T,
        E,
        w,
        A;
      let {
        canvas: R = (function () {
          let e = k("canvas");
          return (e.style.display = "block"), e;
        })(),
        context: C = null,
        depth: P = !0,
        stencil: L = !1,
        alpha: N = !1,
        antialias: I = !1,
        premultipliedAlpha: D = !0,
        preserveDrawingBuffer: O = !1,
        powerPreference: U = "default",
        failIfMajorPerformanceCaveat: z = !1,
      } = e;
      if (((this.isWebGLRenderer = !0), null !== C)) {
        if (
          "undefined" != typeof WebGLRenderingContext &&
          C instanceof WebGLRenderingContext
        )
          throw Error(
            "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
          );
        t = C.getContextAttributes().alpha;
      } else t = N;
      let F = new Uint32Array(4),
        B = new Int32Array(4),
        H = null,
        G = null,
        W = [],
        X = [];
      (this.domElement = R),
        (this.debug = { checkShaderErrors: !0, onShaderError: null }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this._outputColorSpace = g),
        (this.toneMapping = 0),
        (this.toneMappingExposure = 1);
      let j = this,
        J = !1,
        Y = 0,
        K = 0,
        Z = null,
        Q = -1,
        $ = null,
        ee = new ei(),
        et = new ei(),
        en = null,
        es = new tx(0),
        ea = 0,
        el = R.width,
        eh = R.height,
        ec = 1,
        eu = null,
        ed = null,
        ep = new ei(0, 0, el, eh),
        em = new ei(0, 0, el, eh),
        ef = !1,
        eg = new il(),
        e_ = !1,
        ev = !1,
        ex = new ez(),
        ey = new ez(),
        eM = new eo(),
        eS = new ei(),
        eb = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        },
        eT = !1;
      function eE() {
        return null === Z ? ec : 1;
      }
      let ew = C;
      function eA(e, t) {
        return R.getContext(e, t);
      }
      try {
        if (
          ("setAttribute" in R &&
            R.setAttribute("data-engine", "three.js r169"),
          R.addEventListener("webglcontextlost", eP, !1),
          R.addEventListener("webglcontextrestored", eL, !1),
          R.addEventListener("webglcontextcreationerror", eN, !1),
          null === ew)
        ) {
          let e = "webgl2";
          if (
            ((ew = eA(e, {
              alpha: !0,
              depth: P,
              stencil: L,
              antialias: I,
              premultipliedAlpha: D,
              preserveDrawingBuffer: O,
              powerPreference: U,
              failIfMajorPerformanceCaveat: z,
            })),
            null === ew)
          ) {
            if (eA(e))
              throw Error(
                "Error creating WebGL context with your selected attributes."
              );
            throw Error("Error creating WebGL context.");
          }
        }
      } catch (e) {
        throw (console.error("THREE.WebGLRenderer: " + e.message), e);
      }
      function eR() {
        (i = new iG(ew)).init(),
          (E = new rv(ew, i)),
          (n = new iS(ew, i, e, E)),
          (r = new rf(ew)),
          n.reverseDepthBuffer && r.buffers.depth.setReversed(!0),
          (s = new ij(ew)),
          (a = new re()),
          (o = new r_(ew, i, r, a, n, E, s)),
          (l = new iT(j)),
          (h = new iV(j)),
          (c = new ic(ew)),
          (w = new iy(ew, c)),
          (u = new iW(ew, c, s, w)),
          (d = new iJ(ew, u, c, s)),
          (S = new iq(ew, n, o)),
          (x = new ib(a)),
          (p = new n9(j, l, h, i, n, w, x)),
          (m = new rC(j, a)),
          (f = new rr()),
          (v = new rc(i)),
          (M = new ix(j, l, h, r, d, t, D)),
          (y = new rp(j, d, n)),
          (A = new rP(ew, s, n, r)),
          (b = new iM(ew, i, s)),
          (T = new iX(ew, i, s)),
          (s.programs = p.programs),
          (j.capabilities = n),
          (j.extensions = i),
          (j.properties = a),
          (j.renderLists = f),
          (j.shadowMap = y),
          (j.state = r),
          (j.info = s);
      }
      eR();
      let eC = new rw(j, ew);
      function eP(e) {
        e.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (J = !0);
      }
      function eL() {
        console.log("THREE.WebGLRenderer: Context Restored."), (J = !1);
        let e = s.autoReset,
          t = y.enabled,
          i = y.autoUpdate,
          n = y.needsUpdate,
          r = y.type;
        eR(),
          (s.autoReset = e),
          (y.enabled = t),
          (y.autoUpdate = i),
          (y.needsUpdate = n),
          (y.type = r);
      }
      function eN(e) {
        console.error(
          "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
          e.statusMessage
        );
      }
      function eI(e) {
        let t = e.target;
        t.removeEventListener("dispose", eI),
          (function (e) {
            let t = a.get(e).programs;
            void 0 !== t &&
              (t.forEach(function (e) {
                p.releaseProgram(e);
              }),
              e.isShaderMaterial && p.releaseShaderCache(e));
          })(t),
          a.remove(t);
      }
      function eD(e, t, i) {
        !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass
          ? ((e.side = 1),
            (e.needsUpdate = !0),
            eX(e, t, i),
            (e.side = 0),
            (e.needsUpdate = !0),
            eX(e, t, i),
            (e.side = 2))
          : eX(e, t, i);
      }
      (this.xr = eC),
        (this.getContext = function () {
          return ew;
        }),
        (this.getContextAttributes = function () {
          return ew.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          let e = i.get("WEBGL_lose_context");
          e && e.loseContext();
        }),
        (this.forceContextRestore = function () {
          let e = i.get("WEBGL_lose_context");
          e && e.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return ec;
        }),
        (this.setPixelRatio = function (e) {
          void 0 !== e && ((ec = e), this.setSize(el, eh, !1));
        }),
        (this.getSize = function (e) {
          return e.set(el, eh);
        }),
        (this.setSize = function (e, t, i = !0) {
          if (eC.isPresenting) {
            console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            );
            return;
          }
          (el = e),
            (eh = t),
            (R.width = Math.floor(e * ec)),
            (R.height = Math.floor(t * ec)),
            !0 === i &&
              ((R.style.width = e + "px"), (R.style.height = t + "px")),
            this.setViewport(0, 0, e, t);
        }),
        (this.getDrawingBufferSize = function (e) {
          return e.set(el * ec, eh * ec).floor();
        }),
        (this.setDrawingBufferSize = function (e, t, i) {
          (el = e),
            (eh = t),
            (ec = i),
            (R.width = Math.floor(e * i)),
            (R.height = Math.floor(t * i)),
            this.setViewport(0, 0, e, t);
        }),
        (this.getCurrentViewport = function (e) {
          return e.copy(ee);
        }),
        (this.getViewport = function (e) {
          return e.copy(ep);
        }),
        (this.setViewport = function (e, t, i, n) {
          e.isVector4 ? ep.set(e.x, e.y, e.z, e.w) : ep.set(e, t, i, n),
            r.viewport(ee.copy(ep).multiplyScalar(ec).round());
        }),
        (this.getScissor = function (e) {
          return e.copy(em);
        }),
        (this.setScissor = function (e, t, i, n) {
          e.isVector4 ? em.set(e.x, e.y, e.z, e.w) : em.set(e, t, i, n),
            r.scissor(et.copy(em).multiplyScalar(ec).round());
        }),
        (this.getScissorTest = function () {
          return ef;
        }),
        (this.setScissorTest = function (e) {
          r.setScissorTest((ef = e));
        }),
        (this.setOpaqueSort = function (e) {
          eu = e;
        }),
        (this.setTransparentSort = function (e) {
          ed = e;
        }),
        (this.getClearColor = function (e) {
          return e.copy(M.getClearColor());
        }),
        (this.setClearColor = function () {
          M.setClearColor.apply(M, arguments);
        }),
        (this.getClearAlpha = function () {
          return M.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          M.setClearAlpha.apply(M, arguments);
        }),
        (this.clear = function (e = !0, t = !0, i = !0) {
          let n = 0;
          if (e) {
            let e = !1;
            if (null !== Z) {
              let t = Z.texture.format;
              e = 1033 === t || 1031 === t || 1029 === t;
            }
            if (e) {
              let e = Z.texture.type,
                t = M.getClearColor(),
                i = M.getClearAlpha(),
                n = t.r,
                r = t.g,
                s = t.b;
              1009 === e ||
              1014 === e ||
              1012 === e ||
              1020 === e ||
              1017 === e ||
              1018 === e
                ? ((F[0] = n),
                  (F[1] = r),
                  (F[2] = s),
                  (F[3] = i),
                  ew.clearBufferuiv(ew.COLOR, 0, F))
                : ((B[0] = n),
                  (B[1] = r),
                  (B[2] = s),
                  (B[3] = i),
                  ew.clearBufferiv(ew.COLOR, 0, B));
            } else n |= ew.COLOR_BUFFER_BIT;
          }
          t &&
            ((n |= ew.DEPTH_BUFFER_BIT),
            ew.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1)),
            i &&
              ((n |= ew.STENCIL_BUFFER_BIT),
              this.state.buffers.stencil.setMask(4294967295)),
            ew.clear(n);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          R.removeEventListener("webglcontextlost", eP, !1),
            R.removeEventListener("webglcontextrestored", eL, !1),
            R.removeEventListener("webglcontextcreationerror", eN, !1),
            f.dispose(),
            v.dispose(),
            a.dispose(),
            l.dispose(),
            h.dispose(),
            d.dispose(),
            w.dispose(),
            A.dispose(),
            p.dispose(),
            eC.dispose(),
            eC.removeEventListener("sessionstart", eU),
            eC.removeEventListener("sessionend", eF),
            eB.stop();
        }),
        (this.renderBufferDirect = function (e, t, s, d, p, f) {
          let g;
          null === t && (t = eb);
          let v = p.isMesh && 0 > p.matrixWorld.determinant(),
            y = (function (e, t, i, s, c) {
              var u;
              !0 !== t.isScene && (t = eb), o.resetTextureUnits();
              let d = t.fog,
                p = s.isMeshStandardMaterial ? t.environment : null,
                f =
                  null === Z
                    ? j.outputColorSpace
                    : !0 === Z.isXRRenderTarget
                    ? Z.texture.colorSpace
                    : _,
                g = (s.isMeshStandardMaterial ? h : l).get(s.envMap || p),
                v =
                  !0 === s.vertexColors &&
                  !!i.attributes.color &&
                  4 === i.attributes.color.itemSize,
                y =
                  !!i.attributes.tangent && (!!s.normalMap || s.anisotropy > 0),
                M = !!i.morphAttributes.position,
                b = !!i.morphAttributes.normal,
                T = !!i.morphAttributes.color,
                E = 0;
              s.toneMapped &&
                (null === Z || !0 === Z.isXRRenderTarget) &&
                (E = j.toneMapping);
              let w =
                  i.morphAttributes.position ||
                  i.morphAttributes.normal ||
                  i.morphAttributes.color,
                R = void 0 !== w ? w.length : 0,
                C = a.get(s),
                P = G.state.lights;
              if (!0 === e_ && (!0 === ev || e !== $)) {
                let t = e === $ && s.id === Q;
                x.setState(s, e, t);
              }
              let L = !1;
              s.version === C.__version
                ? C.needsLights && C.lightsStateVersion !== P.state.version
                  ? (L = !0)
                  : C.outputColorSpace !== f
                  ? (L = !0)
                  : c.isBatchedMesh && !1 === C.batching
                  ? (L = !0)
                  : c.isBatchedMesh || !0 !== C.batching
                  ? c.isBatchedMesh &&
                    !0 === C.batchingColor &&
                    null === c.colorTexture
                    ? (L = !0)
                    : c.isBatchedMesh &&
                      !1 === C.batchingColor &&
                      null !== c.colorTexture
                    ? (L = !0)
                    : c.isInstancedMesh && !1 === C.instancing
                    ? (L = !0)
                    : c.isInstancedMesh || !0 !== C.instancing
                    ? c.isSkinnedMesh && !1 === C.skinning
                      ? (L = !0)
                      : c.isSkinnedMesh || !0 !== C.skinning
                      ? c.isInstancedMesh &&
                        !0 === C.instancingColor &&
                        null === c.instanceColor
                        ? (L = !0)
                        : c.isInstancedMesh &&
                          !1 === C.instancingColor &&
                          null !== c.instanceColor
                        ? (L = !0)
                        : c.isInstancedMesh &&
                          !0 === C.instancingMorph &&
                          null === c.morphTexture
                        ? (L = !0)
                        : c.isInstancedMesh &&
                          !1 === C.instancingMorph &&
                          null !== c.morphTexture
                        ? (L = !0)
                        : C.envMap !== g
                        ? (L = !0)
                        : !0 === s.fog && C.fog !== d
                        ? (L = !0)
                        : void 0 !== C.numClippingPlanes &&
                          (C.numClippingPlanes !== x.numPlanes ||
                            C.numIntersection !== x.numIntersection)
                        ? (L = !0)
                        : C.vertexAlphas !== v
                        ? (L = !0)
                        : C.vertexTangents !== y
                        ? (L = !0)
                        : C.morphTargets !== M
                        ? (L = !0)
                        : C.morphNormals !== b
                        ? (L = !0)
                        : C.morphColors !== T
                        ? (L = !0)
                        : C.toneMapping !== E
                        ? (L = !0)
                        : C.morphTargetsCount !== R && (L = !0)
                      : (L = !0)
                    : (L = !0)
                  : (L = !0)
                : ((L = !0), (C.__version = s.version));
              let N = C.currentProgram;
              !0 === L && (N = eX(s, t, c));
              let I = !1,
                D = !1,
                O = !1,
                U = N.getUniforms(),
                z = C.uniforms;
              if (
                (r.useProgram(N.program) && ((I = !0), (D = !0), (O = !0)),
                s.id !== Q && ((Q = s.id), (D = !0)),
                I || $ !== e)
              ) {
                n.reverseDepthBuffer
                  ? (ex.copy(e.projectionMatrix),
                    (function (e) {
                      let t = e.elements;
                      (t[2] = 0.5 * t[2] + 0.5 * t[3]),
                        (t[6] = 0.5 * t[6] + 0.5 * t[7]),
                        (t[10] = 0.5 * t[10] + 0.5 * t[11]),
                        (t[14] = 0.5 * t[14] + 0.5 * t[15]);
                    })(ex),
                    (function (e) {
                      let t = e.elements;
                      -1 === t[11]
                        ? ((t[10] = -t[10] - 1), (t[14] = -t[14]))
                        : ((t[10] = -t[10]), (t[14] = -t[14] + 1));
                    })(ex),
                    U.setValue(ew, "projectionMatrix", ex))
                  : U.setValue(ew, "projectionMatrix", e.projectionMatrix),
                  U.setValue(ew, "viewMatrix", e.matrixWorldInverse);
                let t = U.map.cameraPosition;
                void 0 !== t &&
                  t.setValue(ew, eM.setFromMatrixPosition(e.matrixWorld)),
                  n.logarithmicDepthBuffer &&
                    U.setValue(
                      ew,
                      "logDepthBufFC",
                      2 / (Math.log(e.far + 1) / Math.LN2)
                    ),
                  (s.isMeshPhongMaterial ||
                    s.isMeshToonMaterial ||
                    s.isMeshLambertMaterial ||
                    s.isMeshBasicMaterial ||
                    s.isMeshStandardMaterial ||
                    s.isShaderMaterial) &&
                    U.setValue(
                      ew,
                      "isOrthographic",
                      !0 === e.isOrthographicCamera
                    ),
                  $ !== e && (($ = e), (D = !0), (O = !0));
              }
              if (c.isSkinnedMesh) {
                U.setOptional(ew, c, "bindMatrix"),
                  U.setOptional(ew, c, "bindMatrixInverse");
                let e = c.skeleton;
                e &&
                  (null === e.boneTexture && e.computeBoneTexture(),
                  U.setValue(ew, "boneTexture", e.boneTexture, o));
              }
              c.isBatchedMesh &&
                (U.setOptional(ew, c, "batchingTexture"),
                U.setValue(ew, "batchingTexture", c._matricesTexture, o),
                U.setOptional(ew, c, "batchingIdTexture"),
                U.setValue(ew, "batchingIdTexture", c._indirectTexture, o),
                U.setOptional(ew, c, "batchingColorTexture"),
                null !== c._colorsTexture &&
                  U.setValue(ew, "batchingColorTexture", c._colorsTexture, o));
              let F = i.morphAttributes;
              if (
                ((void 0 !== F.position ||
                  void 0 !== F.normal ||
                  void 0 !== F.color) &&
                  S.update(c, i, N),
                (D || C.receiveShadow !== c.receiveShadow) &&
                  ((C.receiveShadow = c.receiveShadow),
                  U.setValue(ew, "receiveShadow", c.receiveShadow)),
                s.isMeshGouraudMaterial &&
                  null !== s.envMap &&
                  ((z.envMap.value = g),
                  (z.flipEnvMap.value =
                    g.isCubeTexture && !1 === g.isRenderTargetTexture
                      ? -1
                      : 1)),
                s.isMeshStandardMaterial &&
                  null === s.envMap &&
                  null !== t.environment &&
                  (z.envMapIntensity.value = t.environmentIntensity),
                D &&
                  (U.setValue(ew, "toneMappingExposure", j.toneMappingExposure),
                  C.needsLights &&
                    ((u = O),
                    (z.ambientLightColor.needsUpdate = u),
                    (z.lightProbe.needsUpdate = u),
                    (z.directionalLights.needsUpdate = u),
                    (z.directionalLightShadows.needsUpdate = u),
                    (z.pointLights.needsUpdate = u),
                    (z.pointLightShadows.needsUpdate = u),
                    (z.spotLights.needsUpdate = u),
                    (z.spotLightShadows.needsUpdate = u),
                    (z.rectAreaLights.needsUpdate = u),
                    (z.hemisphereLights.needsUpdate = u)),
                  d && !0 === s.fog && m.refreshFogUniforms(z, d),
                  m.refreshMaterialUniforms(
                    z,
                    s,
                    ec,
                    eh,
                    G.state.transmissionRenderTarget[e.id]
                  ),
                  nG.upload(ew, ej(C), z, o)),
                s.isShaderMaterial &&
                  !0 === s.uniformsNeedUpdate &&
                  (nG.upload(ew, ej(C), z, o), (s.uniformsNeedUpdate = !1)),
                s.isSpriteMaterial && U.setValue(ew, "center", c.center),
                U.setValue(ew, "modelViewMatrix", c.modelViewMatrix),
                U.setValue(ew, "normalMatrix", c.normalMatrix),
                U.setValue(ew, "modelMatrix", c.matrixWorld),
                s.isShaderMaterial || s.isRawShaderMaterial)
              ) {
                let e = s.uniformsGroups;
                for (let t = 0, i = e.length; t < i; t++) {
                  let i = e[t];
                  A.update(i, N), A.bind(i, N);
                }
              }
              return N;
            })(e, t, s, d, p);
          r.setMaterial(d, v);
          let M = s.index,
            E = 1;
          if (!0 === d.wireframe) {
            if (void 0 === (M = u.getWireframeAttribute(s))) return;
            E = 2;
          }
          let R = s.drawRange,
            C = s.attributes.position,
            P = R.start * E,
            L = (R.start + R.count) * E;
          null !== f &&
            ((P = Math.max(P, f.start * E)),
            (L = Math.min(L, (f.start + f.count) * E))),
            null !== M
              ? ((P = Math.max(P, 0)), (L = Math.min(L, M.count)))
              : null != C && ((P = Math.max(P, 0)), (L = Math.min(L, C.count)));
          let N = L - P;
          if (N < 0 || N === 1 / 0) return;
          w.setup(p, d, y, s, M);
          let I = b;
          if ((null !== M && ((g = c.get(M)), (I = T).setIndex(g)), p.isMesh))
            !0 === d.wireframe
              ? (r.setLineWidth(d.wireframeLinewidth * eE()),
                I.setMode(ew.LINES))
              : I.setMode(ew.TRIANGLES);
          else if (p.isLine) {
            let e = d.linewidth;
            void 0 === e && (e = 1),
              r.setLineWidth(e * eE()),
              p.isLineSegments
                ? I.setMode(ew.LINES)
                : p.isLineLoop
                ? I.setMode(ew.LINE_LOOP)
                : I.setMode(ew.LINE_STRIP);
          } else
            p.isPoints
              ? I.setMode(ew.POINTS)
              : p.isSprite && I.setMode(ew.TRIANGLES);
          if (p.isBatchedMesh) {
            if (null !== p._multiDrawInstances)
              I.renderMultiDrawInstances(
                p._multiDrawStarts,
                p._multiDrawCounts,
                p._multiDrawCount,
                p._multiDrawInstances
              );
            else if (i.get("WEBGL_multi_draw"))
              I.renderMultiDraw(
                p._multiDrawStarts,
                p._multiDrawCounts,
                p._multiDrawCount
              );
            else {
              let e = p._multiDrawStarts,
                t = p._multiDrawCounts,
                i = p._multiDrawCount,
                n = M ? c.get(M).bytesPerElement : 1,
                r = a.get(d).currentProgram.getUniforms();
              for (let s = 0; s < i; s++)
                r.setValue(ew, "_gl_DrawID", s), I.render(e[s] / n, t[s]);
            }
          } else if (p.isInstancedMesh) I.renderInstances(P, N, p.count);
          else if (s.isInstancedBufferGeometry) {
            let e =
                void 0 !== s._maxInstanceCount ? s._maxInstanceCount : 1 / 0,
              t = Math.min(s.instanceCount, e);
            I.renderInstances(P, N, t);
          } else I.render(P, N);
        }),
        (this.compile = function (e, t, i = null) {
          null === i && (i = e),
            (G = v.get(i)).init(t),
            X.push(G),
            i.traverseVisible(function (e) {
              e.isLight &&
                e.layers.test(t.layers) &&
                (G.pushLight(e), e.castShadow && G.pushShadow(e));
            }),
            e !== i &&
              e.traverseVisible(function (e) {
                e.isLight &&
                  e.layers.test(t.layers) &&
                  (G.pushLight(e), e.castShadow && G.pushShadow(e));
              }),
            G.setupLights();
          let n = new Set();
          return (
            e.traverse(function (e) {
              if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return;
              let t = e.material;
              if (t) {
                if (Array.isArray(t))
                  for (let r = 0; r < t.length; r++) {
                    let s = t[r];
                    eD(s, i, e), n.add(s);
                  }
                else eD(t, i, e), n.add(t);
              }
            }),
            X.pop(),
            (G = null),
            n
          );
        }),
        (this.compileAsync = function (e, t, n = null) {
          let r = this.compile(e, t, n);
          return new Promise((t) => {
            function n() {
              if (
                (r.forEach(function (e) {
                  a.get(e).currentProgram.isReady() && r.delete(e);
                }),
                0 === r.size)
              ) {
                t(e);
                return;
              }
              setTimeout(n, 10);
            }
            null !== i.get("KHR_parallel_shader_compile")
              ? n()
              : setTimeout(n, 10);
          });
        });
      let eO = null;
      function eU() {
        eB.stop();
      }
      function eF() {
        eB.start();
      }
      let eB = new ih();
      function ek(e, t, i, n) {
        if (!1 === e.visible) return;
        if (e.layers.test(t.layers)) {
          if (e.isGroup) i = e.renderOrder;
          else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
          else if (e.isLight) G.pushLight(e), e.castShadow && G.pushShadow(e);
          else if (e.isSprite) {
            if (!e.frustumCulled || eg.intersectsSprite(e)) {
              n && eS.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ey);
              let t = d.update(e),
                r = e.material;
              r.visible && H.push(e, t, r, i, eS.z, null);
            }
          } else if (
            (e.isMesh || e.isLine || e.isPoints) &&
            (!e.frustumCulled || eg.intersectsObject(e))
          ) {
            let t = d.update(e),
              r = e.material;
            if (
              (n &&
                (void 0 !== e.boundingSphere
                  ? (null === e.boundingSphere && e.computeBoundingSphere(),
                    eS.copy(e.boundingSphere.center))
                  : (null === t.boundingSphere && t.computeBoundingSphere(),
                    eS.copy(t.boundingSphere.center)),
                eS.applyMatrix4(e.matrixWorld).applyMatrix4(ey)),
              Array.isArray(r))
            ) {
              let n = t.groups;
              for (let s = 0, a = n.length; s < a; s++) {
                let a = n[s],
                  o = r[a.materialIndex];
                o && o.visible && H.push(e, t, o, i, eS.z, a);
              }
            } else r.visible && H.push(e, t, r, i, eS.z, null);
          }
        }
        let r = e.children;
        for (let e = 0, s = r.length; e < s; e++) ek(r[e], t, i, n);
      }
      function eH(e, t, i, n) {
        let s = e.opaque,
          a = e.transmissive,
          o = e.transparent;
        G.setupLightsView(i),
          !0 === e_ && x.setGlobalState(j.clippingPlanes, i),
          n && r.viewport(ee.copy(n)),
          s.length > 0 && eG(s, t, i),
          a.length > 0 && eG(a, t, i),
          o.length > 0 && eG(o, t, i),
          r.buffers.depth.setTest(!0),
          r.buffers.depth.setMask(!0),
          r.buffers.color.setMask(!0),
          r.setPolygonOffset(!1);
      }
      function eV(e, t, n, r) {
        if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
        void 0 === G.state.transmissionRenderTarget[r.id] &&
          (G.state.transmissionRenderTarget[r.id] = new er(1, 1, {
            generateMipmaps: !0,
            type:
              i.has("EXT_color_buffer_half_float") ||
              i.has("EXT_color_buffer_float")
                ? 1016
                : 1009,
            minFilter: 1008,
            samples: 4,
            stencilBuffer: L,
            resolveDepthBuffer: !1,
            resolveStencilBuffer: !1,
            colorSpace: q.workingColorSpace,
          }));
        let s = G.state.transmissionRenderTarget[r.id],
          a = r.viewport || ee;
        s.setSize(a.z, a.w);
        let l = j.getRenderTarget();
        j.setRenderTarget(s),
          j.getClearColor(es),
          (ea = j.getClearAlpha()) < 1 && j.setClearColor(16777215, 0.5),
          j.clear(),
          eT && M.render(n);
        let h = j.toneMapping;
        j.toneMapping = 0;
        let c = r.viewport;
        if (
          (void 0 !== r.viewport && (r.viewport = void 0),
          G.setupLightsView(r),
          !0 === e_ && x.setGlobalState(j.clippingPlanes, r),
          eG(e, n, r),
          o.updateMultisampleRenderTarget(s),
          o.updateRenderTargetMipmap(s),
          !1 === i.has("WEBGL_multisampled_render_to_texture"))
        ) {
          let e = !1;
          for (let i = 0, s = t.length; i < s; i++) {
            let s = t[i],
              a = s.object,
              o = s.geometry,
              l = s.material,
              h = s.group;
            if (2 === l.side && a.layers.test(r.layers)) {
              let t = l.side;
              (l.side = 1),
                (l.needsUpdate = !0),
                eW(a, n, r, o, l, h),
                (l.side = t),
                (l.needsUpdate = !0),
                (e = !0);
            }
          }
          !0 === e &&
            (o.updateMultisampleRenderTarget(s), o.updateRenderTargetMipmap(s));
        }
        j.setRenderTarget(l),
          j.setClearColor(es, ea),
          void 0 !== c && (r.viewport = c),
          (j.toneMapping = h);
      }
      function eG(e, t, i) {
        let n = !0 === t.isScene ? t.overrideMaterial : null;
        for (let r = 0, s = e.length; r < s; r++) {
          let s = e[r],
            a = s.object,
            o = s.geometry,
            l = null === n ? s.material : n,
            h = s.group;
          a.layers.test(i.layers) && eW(a, t, i, o, l, h);
        }
      }
      function eW(e, t, i, n, r, s) {
        e.onBeforeRender(j, t, i, n, r, s),
          e.modelViewMatrix.multiplyMatrices(
            i.matrixWorldInverse,
            e.matrixWorld
          ),
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
          r.onBeforeRender(j, t, i, n, e, s),
          !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
            ? ((r.side = 1),
              (r.needsUpdate = !0),
              j.renderBufferDirect(i, t, n, r, e, s),
              (r.side = 0),
              (r.needsUpdate = !0),
              j.renderBufferDirect(i, t, n, r, e, s),
              (r.side = 2))
            : j.renderBufferDirect(i, t, n, r, e, s),
          e.onAfterRender(j, t, i, n, r, s);
      }
      function eX(e, t, i) {
        !0 !== t.isScene && (t = eb);
        let n = a.get(e),
          r = G.state.lights,
          s = G.state.shadowsArray,
          o = r.state.version,
          c = p.getParameters(e, r.state, s, t, i),
          u = p.getProgramCacheKey(c),
          d = n.programs;
        (n.environment = e.isMeshStandardMaterial ? t.environment : null),
          (n.fog = t.fog),
          (n.envMap = (e.isMeshStandardMaterial ? h : l).get(
            e.envMap || n.environment
          )),
          (n.envMapRotation =
            null !== n.environment && null === e.envMap
              ? t.environmentRotation
              : e.envMapRotation),
          void 0 === d &&
            (e.addEventListener("dispose", eI),
            (d = new Map()),
            (n.programs = d));
        let m = d.get(u);
        if (void 0 !== m) {
          if (n.currentProgram === m && n.lightsStateVersion === o)
            return eq(e, c), m;
        } else
          (c.uniforms = p.getUniforms(e)),
            e.onBeforeCompile(c, j),
            (m = p.acquireProgram(c, u)),
            d.set(u, m),
            (n.uniforms = c.uniforms);
        let f = n.uniforms;
        return (
          ((e.isShaderMaterial || e.isRawShaderMaterial) &&
            !0 !== e.clipping) ||
            (f.clippingPlanes = x.uniform),
          eq(e, c),
          (n.needsLights =
            e.isMeshLambertMaterial ||
            e.isMeshToonMaterial ||
            e.isMeshPhongMaterial ||
            e.isMeshStandardMaterial ||
            e.isShadowMaterial ||
            (e.isShaderMaterial && !0 === e.lights)),
          (n.lightsStateVersion = o),
          n.needsLights &&
            ((f.ambientLightColor.value = r.state.ambient),
            (f.lightProbe.value = r.state.probe),
            (f.directionalLights.value = r.state.directional),
            (f.directionalLightShadows.value = r.state.directionalShadow),
            (f.spotLights.value = r.state.spot),
            (f.spotLightShadows.value = r.state.spotShadow),
            (f.rectAreaLights.value = r.state.rectArea),
            (f.ltc_1.value = r.state.rectAreaLTC1),
            (f.ltc_2.value = r.state.rectAreaLTC2),
            (f.pointLights.value = r.state.point),
            (f.pointLightShadows.value = r.state.pointShadow),
            (f.hemisphereLights.value = r.state.hemi),
            (f.directionalShadowMap.value = r.state.directionalShadowMap),
            (f.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (f.spotShadowMap.value = r.state.spotShadowMap),
            (f.spotLightMatrix.value = r.state.spotLightMatrix),
            (f.spotLightMap.value = r.state.spotLightMap),
            (f.pointShadowMap.value = r.state.pointShadowMap),
            (f.pointShadowMatrix.value = r.state.pointShadowMatrix)),
          (n.currentProgram = m),
          (n.uniformsList = null),
          m
        );
      }
      function ej(e) {
        if (null === e.uniformsList) {
          let t = e.currentProgram.getUniforms();
          e.uniformsList = nG.seqWithValue(t.seq, e.uniforms);
        }
        return e.uniformsList;
      }
      function eq(e, t) {
        let i = a.get(e);
        (i.outputColorSpace = t.outputColorSpace),
          (i.batching = t.batching),
          (i.batchingColor = t.batchingColor),
          (i.instancing = t.instancing),
          (i.instancingColor = t.instancingColor),
          (i.instancingMorph = t.instancingMorph),
          (i.skinning = t.skinning),
          (i.morphTargets = t.morphTargets),
          (i.morphNormals = t.morphNormals),
          (i.morphColors = t.morphColors),
          (i.morphTargetsCount = t.morphTargetsCount),
          (i.numClippingPlanes = t.numClippingPlanes),
          (i.numIntersection = t.numClipIntersection),
          (i.vertexAlphas = t.vertexAlphas),
          (i.vertexTangents = t.vertexTangents),
          (i.toneMapping = t.toneMapping);
      }
      eB.setAnimationLoop(function (e) {
        eO && eO(e);
      }),
        "undefined" != typeof self && eB.setContext(self),
        (this.setAnimationLoop = function (e) {
          (eO = e), eC.setAnimationLoop(e), null === e ? eB.stop() : eB.start();
        }),
        eC.addEventListener("sessionstart", eU),
        eC.addEventListener("sessionend", eF),
        (this.render = function (e, t) {
          if (void 0 !== t && !0 !== t.isCamera) {
            console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
            return;
          }
          if (!0 === J) return;
          if (
            (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
            null === t.parent &&
              !0 === t.matrixWorldAutoUpdate &&
              t.updateMatrixWorld(),
            !0 === eC.enabled &&
              !0 === eC.isPresenting &&
              (!0 === eC.cameraAutoUpdate && eC.updateCamera(t),
              (t = eC.getCamera())),
            !0 === e.isScene && e.onBeforeRender(j, e, t, Z),
            (G = v.get(e, X.length)).init(t),
            X.push(G),
            ey.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            eg.setFromProjectionMatrix(ey),
            (ev = this.localClippingEnabled),
            (e_ = x.init(this.clippingPlanes, ev)),
            (H = f.get(e, W.length)).init(),
            W.push(H),
            !0 === eC.enabled && !0 === eC.isPresenting)
          ) {
            let e = j.xr.getDepthSensingMesh();
            null !== e && ek(e, t, -1 / 0, j.sortObjects);
          }
          ek(e, t, 0, j.sortObjects),
            H.finish(),
            !0 === j.sortObjects && H.sort(eu, ed),
            (eT =
              !1 === eC.enabled ||
              !1 === eC.isPresenting ||
              !1 === eC.hasDepthSensing()) && M.addToRenderList(H, e),
            this.info.render.frame++,
            !0 === e_ && x.beginShadows();
          let i = G.state.shadowsArray;
          y.render(i, e, t),
            !0 === e_ && x.endShadows(),
            !0 === this.info.autoReset && this.info.reset();
          let n = H.opaque,
            r = H.transmissive;
          if ((G.setupLights(), t.isArrayCamera)) {
            let i = t.cameras;
            if (r.length > 0)
              for (let t = 0, s = i.length; t < s; t++) eV(n, r, e, i[t]);
            eT && M.render(e);
            for (let t = 0, n = i.length; t < n; t++) {
              let n = i[t];
              eH(H, e, n, n.viewport);
            }
          } else r.length > 0 && eV(n, r, e, t), eT && M.render(e), eH(H, e, t);
          null !== Z &&
            (o.updateMultisampleRenderTarget(Z), o.updateRenderTargetMipmap(Z)),
            !0 === e.isScene && e.onAfterRender(j, e, t),
            w.resetDefaultState(),
            (Q = -1),
            ($ = null),
            X.pop(),
            X.length > 0
              ? ((G = X[X.length - 1]),
                !0 === e_ && x.setGlobalState(j.clippingPlanes, G.state.camera))
              : (G = null),
            W.pop(),
            (H = W.length > 0 ? W[W.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return Y;
        }),
        (this.getActiveMipmapLevel = function () {
          return K;
        }),
        (this.getRenderTarget = function () {
          return Z;
        }),
        (this.setRenderTargetTextures = function (e, t, n) {
          (a.get(e.texture).__webglTexture = t),
            (a.get(e.depthTexture).__webglTexture = n);
          let r = a.get(e);
          (r.__hasExternalTextures = !0),
            (r.__autoAllocateDepthBuffer = void 0 === n),
            r.__autoAllocateDepthBuffer ||
              !0 !== i.has("WEBGL_multisampled_render_to_texture") ||
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (r.__useRenderToTexture = !1));
        }),
        (this.setRenderTargetFramebuffer = function (e, t) {
          let i = a.get(e);
          (i.__webglFramebuffer = t),
            (i.__useDefaultFramebuffer = void 0 === t);
        }),
        (this.setRenderTarget = function (e, t = 0, i = 0) {
          (Z = e), (Y = t), (K = i);
          let n = !0,
            s = null,
            l = !1,
            h = !1;
          if (e) {
            let c = a.get(e);
            if (void 0 !== c.__useDefaultFramebuffer)
              r.bindFramebuffer(ew.FRAMEBUFFER, null), (n = !1);
            else if (void 0 === c.__webglFramebuffer) o.setupRenderTarget(e);
            else if (c.__hasExternalTextures)
              o.rebindTextures(
                e,
                a.get(e.texture).__webglTexture,
                a.get(e.depthTexture).__webglTexture
              );
            else if (e.depthBuffer) {
              let t = e.depthTexture;
              if (c.__boundDepthTexture !== t) {
                if (
                  null !== t &&
                  a.has(t) &&
                  (e.width !== t.image.width || e.height !== t.image.height)
                )
                  throw Error(
                    "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
                  );
                o.setupDepthRenderbuffer(e);
              }
            }
            let u = e.texture;
            (u.isData3DTexture ||
              u.isDataArrayTexture ||
              u.isCompressedArrayTexture) &&
              (h = !0);
            let d = a.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget
              ? ((s = Array.isArray(d[t]) ? d[t][i] : d[t]), (l = !0))
              : (s =
                  e.samples > 0 && !1 === o.useMultisampledRTT(e)
                    ? a.get(e).__webglMultisampledFramebuffer
                    : Array.isArray(d)
                    ? d[i]
                    : d),
              ee.copy(e.viewport),
              et.copy(e.scissor),
              (en = e.scissorTest);
          } else
            ee.copy(ep).multiplyScalar(ec).floor(),
              et.copy(em).multiplyScalar(ec).floor(),
              (en = ef);
          if (
            (r.bindFramebuffer(ew.FRAMEBUFFER, s) && n && r.drawBuffers(e, s),
            r.viewport(ee),
            r.scissor(et),
            r.setScissorTest(en),
            l)
          ) {
            let n = a.get(e.texture);
            ew.framebufferTexture2D(
              ew.FRAMEBUFFER,
              ew.COLOR_ATTACHMENT0,
              ew.TEXTURE_CUBE_MAP_POSITIVE_X + t,
              n.__webglTexture,
              i
            );
          } else if (h) {
            let n = a.get(e.texture);
            ew.framebufferTextureLayer(
              ew.FRAMEBUFFER,
              ew.COLOR_ATTACHMENT0,
              n.__webglTexture,
              i || 0,
              t || 0
            );
          }
          Q = -1;
        }),
        (this.readRenderTargetPixels = function (e, t, i, s, o, l, h) {
          if (!(e && e.isWebGLRenderTarget)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
            return;
          }
          let c = a.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== h && (c = c[h]), c)) {
            r.bindFramebuffer(ew.FRAMEBUFFER, c);
            try {
              let r = e.texture,
                a = r.format,
                h = r.type;
              if (!n.textureFormatReadable(a)) {
                console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
                return;
              }
              if (!n.textureTypeReadable(h)) {
                console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
                return;
              }
              t >= 0 &&
                t <= e.width - s &&
                i >= 0 &&
                i <= e.height - o &&
                ew.readPixels(t, i, s, o, E.convert(a), E.convert(h), l);
            } finally {
              let e = null !== Z ? a.get(Z).__webglFramebuffer : null;
              r.bindFramebuffer(ew.FRAMEBUFFER, e);
            }
          }
        }),
        (this.readRenderTargetPixelsAsync = async function (
          e,
          t,
          i,
          s,
          o,
          l,
          h
        ) {
          if (!(e && e.isWebGLRenderTarget))
            throw Error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let c = a.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== h && (c = c[h]), c)) {
            let h = e.texture,
              d = h.format,
              p = h.type;
            if (!n.textureFormatReadable(d))
              throw Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!n.textureTypeReadable(p))
              throw Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            if (t >= 0 && t <= e.width - s && i >= 0 && i <= e.height - o) {
              var u;
              r.bindFramebuffer(ew.FRAMEBUFFER, c);
              let e = ew.createBuffer();
              ew.bindBuffer(ew.PIXEL_PACK_BUFFER, e),
                ew.bufferData(
                  ew.PIXEL_PACK_BUFFER,
                  l.byteLength,
                  ew.STREAM_READ
                ),
                ew.readPixels(t, i, s, o, E.convert(d), E.convert(p), 0);
              let n = null !== Z ? a.get(Z).__webglFramebuffer : null;
              r.bindFramebuffer(ew.FRAMEBUFFER, n);
              let h = ew.fenceSync(ew.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return (
                ew.flush(),
                await ((u = ew),
                new Promise(function (e, t) {
                  setTimeout(function i() {
                    switch (u.clientWaitSync(h, u.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                      case u.WAIT_FAILED:
                        t();
                        break;
                      case u.TIMEOUT_EXPIRED:
                        setTimeout(i, 4);
                        break;
                      default:
                        e();
                    }
                  }, 4);
                })),
                ew.bindBuffer(ew.PIXEL_PACK_BUFFER, e),
                ew.getBufferSubData(ew.PIXEL_PACK_BUFFER, 0, l),
                ew.deleteBuffer(e),
                ew.deleteSync(h),
                l
              );
            }
            throw Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
          }
        }),
        (this.copyFramebufferToTexture = function (e, t = null, i = 0) {
          !0 !== e.isTexture &&
            (V(
              "WebGLRenderer: copyFramebufferToTexture function signature has changed."
            ),
            (t = arguments[0] || null),
            (e = arguments[1]));
          let n = Math.pow(2, -i),
            s = Math.floor(e.image.width * n),
            a = Math.floor(e.image.height * n),
            l = null !== t ? t.x : 0,
            h = null !== t ? t.y : 0;
          o.setTexture2D(e, 0),
            ew.copyTexSubImage2D(ew.TEXTURE_2D, i, 0, 0, l, h, s, a),
            r.unbindTexture();
        }),
        (this.copyTextureToTexture = function (
          e,
          t,
          i = null,
          n = null,
          s = 0
        ) {
          let a, l, h, c, u, d;
          !0 !== e.isTexture &&
            (V(
              "WebGLRenderer: copyTextureToTexture function signature has changed."
            ),
            (n = arguments[0] || null),
            (e = arguments[1]),
            (t = arguments[2]),
            (s = arguments[3] || 0),
            (i = null)),
            null !== i
              ? ((a = i.max.x - i.min.x),
                (l = i.max.y - i.min.y),
                (h = i.min.x),
                (c = i.min.y))
              : ((a = e.image.width), (l = e.image.height), (h = 0), (c = 0)),
            null !== n ? ((u = n.x), (d = n.y)) : ((u = 0), (d = 0));
          let p = E.convert(t.format),
            m = E.convert(t.type);
          o.setTexture2D(t, 0),
            ew.pixelStorei(ew.UNPACK_FLIP_Y_WEBGL, t.flipY),
            ew.pixelStorei(
              ew.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              t.premultiplyAlpha
            ),
            ew.pixelStorei(ew.UNPACK_ALIGNMENT, t.unpackAlignment);
          let f = ew.getParameter(ew.UNPACK_ROW_LENGTH),
            g = ew.getParameter(ew.UNPACK_IMAGE_HEIGHT),
            _ = ew.getParameter(ew.UNPACK_SKIP_PIXELS),
            v = ew.getParameter(ew.UNPACK_SKIP_ROWS),
            x = ew.getParameter(ew.UNPACK_SKIP_IMAGES),
            y = e.isCompressedTexture ? e.mipmaps[s] : e.image;
          ew.pixelStorei(ew.UNPACK_ROW_LENGTH, y.width),
            ew.pixelStorei(ew.UNPACK_IMAGE_HEIGHT, y.height),
            ew.pixelStorei(ew.UNPACK_SKIP_PIXELS, h),
            ew.pixelStorei(ew.UNPACK_SKIP_ROWS, c),
            e.isDataTexture
              ? ew.texSubImage2D(ew.TEXTURE_2D, s, u, d, a, l, p, m, y.data)
              : e.isCompressedTexture
              ? ew.compressedTexSubImage2D(
                  ew.TEXTURE_2D,
                  s,
                  u,
                  d,
                  y.width,
                  y.height,
                  p,
                  y.data
                )
              : ew.texSubImage2D(ew.TEXTURE_2D, s, u, d, a, l, p, m, y),
            ew.pixelStorei(ew.UNPACK_ROW_LENGTH, f),
            ew.pixelStorei(ew.UNPACK_IMAGE_HEIGHT, g),
            ew.pixelStorei(ew.UNPACK_SKIP_PIXELS, _),
            ew.pixelStorei(ew.UNPACK_SKIP_ROWS, v),
            ew.pixelStorei(ew.UNPACK_SKIP_IMAGES, x),
            0 === s && t.generateMipmaps && ew.generateMipmap(ew.TEXTURE_2D),
            r.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (
          e,
          t,
          i = null,
          n = null,
          s = 0
        ) {
          let a, l, h, c, u, d, p, m, f, g;
          !0 !== e.isTexture &&
            (V(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed."
            ),
            (i = arguments[0] || null),
            (n = arguments[1] || null),
            (e = arguments[2]),
            (t = arguments[3]),
            (s = arguments[4] || 0));
          let _ = e.isCompressedTexture ? e.mipmaps[s] : e.image;
          null !== i
            ? ((a = i.max.x - i.min.x),
              (l = i.max.y - i.min.y),
              (h = i.max.z - i.min.z),
              (c = i.min.x),
              (u = i.min.y),
              (d = i.min.z))
            : ((a = _.width),
              (l = _.height),
              (h = _.depth),
              (c = 0),
              (u = 0),
              (d = 0)),
            null !== n
              ? ((p = n.x), (m = n.y), (f = n.z))
              : ((p = 0), (m = 0), (f = 0));
          let v = E.convert(t.format),
            x = E.convert(t.type);
          if (t.isData3DTexture) o.setTexture3D(t, 0), (g = ew.TEXTURE_3D);
          else if (t.isDataArrayTexture || t.isCompressedArrayTexture)
            o.setTexture2DArray(t, 0), (g = ew.TEXTURE_2D_ARRAY);
          else {
            console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
            );
            return;
          }
          ew.pixelStorei(ew.UNPACK_FLIP_Y_WEBGL, t.flipY),
            ew.pixelStorei(
              ew.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              t.premultiplyAlpha
            ),
            ew.pixelStorei(ew.UNPACK_ALIGNMENT, t.unpackAlignment);
          let y = ew.getParameter(ew.UNPACK_ROW_LENGTH),
            M = ew.getParameter(ew.UNPACK_IMAGE_HEIGHT),
            S = ew.getParameter(ew.UNPACK_SKIP_PIXELS),
            b = ew.getParameter(ew.UNPACK_SKIP_ROWS),
            T = ew.getParameter(ew.UNPACK_SKIP_IMAGES);
          ew.pixelStorei(ew.UNPACK_ROW_LENGTH, _.width),
            ew.pixelStorei(ew.UNPACK_IMAGE_HEIGHT, _.height),
            ew.pixelStorei(ew.UNPACK_SKIP_PIXELS, c),
            ew.pixelStorei(ew.UNPACK_SKIP_ROWS, u),
            ew.pixelStorei(ew.UNPACK_SKIP_IMAGES, d),
            e.isDataTexture || e.isData3DTexture
              ? ew.texSubImage3D(g, s, p, m, f, a, l, h, v, x, _.data)
              : t.isCompressedArrayTexture
              ? ew.compressedTexSubImage3D(g, s, p, m, f, a, l, h, v, _.data)
              : ew.texSubImage3D(g, s, p, m, f, a, l, h, v, x, _),
            ew.pixelStorei(ew.UNPACK_ROW_LENGTH, y),
            ew.pixelStorei(ew.UNPACK_IMAGE_HEIGHT, M),
            ew.pixelStorei(ew.UNPACK_SKIP_PIXELS, S),
            ew.pixelStorei(ew.UNPACK_SKIP_ROWS, b),
            ew.pixelStorei(ew.UNPACK_SKIP_IMAGES, T),
            0 === s && t.generateMipmaps && ew.generateMipmap(g),
            r.unbindTexture();
        }),
        (this.initRenderTarget = function (e) {
          void 0 === a.get(e).__webglFramebuffer && o.setupRenderTarget(e);
        }),
        (this.initTexture = function (e) {
          e.isCubeTexture
            ? o.setTextureCube(e, 0)
            : e.isData3DTexture
            ? o.setTexture3D(e, 0)
            : e.isDataArrayTexture || e.isCompressedArrayTexture
            ? o.setTexture2DArray(e, 0)
            : o.setTexture2D(e, 0),
            r.unbindTexture();
        }),
        (this.resetState = function () {
          (Y = 0), (K = 0), (Z = null), r.reset(), w.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    get coordinateSystem() {
      return 2e3;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(e) {
      this._outputColorSpace = e;
      let t = this.getContext();
      (t.drawingBufferColorSpace = e === v ? "display-p3" : "srgb"),
        (t.unpackColorSpace =
          q.workingColorSpace === x ? "display-p3" : "srgb");
    }
  })();
c0.setSize(window.innerWidth, window.innerHeight),
  document.body.appendChild(c0.domElement);
const c1 = new (class {
  constructor(e = {}) {
    let t, i, n, r;
    let s = this,
      a = { camera: { style: "" }, objects: new WeakMap() },
      o = void 0 !== e.element ? e.element : document.createElement("div");
    (o.style.overflow = "hidden"), (this.domElement = o);
    let l = document.createElement("div");
    (l.style.transformOrigin = "0 0"),
      (l.style.pointerEvents = "none"),
      o.appendChild(l);
    let h = document.createElement("div");
    function c(e) {
      return 1e-10 > Math.abs(e) ? 0 : e;
    }
    function u(e) {
      let t = e.elements;
      return (
        "matrix3d(" +
        c(t[0]) +
        "," +
        c(-t[1]) +
        "," +
        c(t[2]) +
        "," +
        c(t[3]) +
        "," +
        c(t[4]) +
        "," +
        c(-t[5]) +
        "," +
        c(t[6]) +
        "," +
        c(t[7]) +
        "," +
        c(t[8]) +
        "," +
        c(-t[9]) +
        "," +
        c(t[10]) +
        "," +
        c(t[11]) +
        "," +
        c(t[12]) +
        "," +
        c(-t[13]) +
        "," +
        c(t[14]) +
        "," +
        c(t[15]) +
        ")"
      );
    }
    function d(e) {
      let t = e.elements;
      return (
        "translate(-50%,-50%)" +
        ("matrix3d(" +
          c(t[0]) +
          "," +
          c(t[1]) +
          "," +
          c(t[2]) +
          "," +
          c(t[3]) +
          "," +
          c(-t[4]) +
          "," +
          c(-t[5]) +
          "," +
          c(-t[6]) +
          "," +
          c(-t[7]) +
          "," +
          c(t[8]) +
          "," +
          c(t[9]) +
          "," +
          c(t[10]) +
          "," +
          c(t[11]) +
          "," +
          c(t[12]) +
          "," +
          c(t[13]) +
          "," +
          c(t[14]) +
          ",") +
        c(t[15]) +
        ")"
      );
    }
    (h.style.transformStyle = "preserve-3d"),
      l.appendChild(h),
      (this.getSize = function () {
        return { width: t, height: i };
      }),
      (this.render = function (e, o) {
        let p, m;
        let f = o.projectionMatrix.elements[5] * r;
        o.view && o.view.enabled
          ? ((l.style.transform = `translate( ${
              -o.view.offsetX * (t / o.view.width)
            }px, ${-o.view.offsetY * (i / o.view.height)}px )`),
            (l.style.transform += `scale( ${o.view.fullWidth / o.view.width}, ${
              o.view.fullHeight / o.view.height
            } )`))
          : (l.style.transform = ""),
          !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
          null === o.parent &&
            !0 === o.matrixWorldAutoUpdate &&
            o.updateMatrixWorld(),
          o.isOrthographicCamera &&
            ((p = -(o.right + o.left) / 2), (m = (o.top + o.bottom) / 2));
        let g =
            o.view && o.view.enabled ? o.view.height / o.view.fullHeight : 1,
          _ = o.isOrthographicCamera
            ? `scale( ${g} )scale(` +
              f +
              ")translate(" +
              c(p) +
              "px," +
              c(m) +
              "px)" +
              u(o.matrixWorldInverse)
            : `scale( ${g} )translateZ(` + f + "px)" + u(o.matrixWorldInverse),
          v =
            (o.isPerspectiveCamera ? "perspective(" + f + "px) " : "") +
            _ +
            "translate(" +
            n +
            "px," +
            r +
            "px)";
        a.camera.style !== v && ((h.style.transform = v), (a.camera.style = v)),
          (function e(t, i, n, r) {
            if (!1 === t.visible) {
              !(function e(t) {
                t.isCSS3DObject && (t.element.style.display = "none");
                for (let i = 0, n = t.children.length; i < n; i++)
                  e(t.children[i]);
              })(t);
              return;
            }
            if (t.isCSS3DObject) {
              let e = !0 === t.layers.test(n.layers),
                r = t.element;
              if (((r.style.display = !0 === e ? "" : "none"), !0 === e)) {
                let e;
                t.onBeforeRender(s, i, n),
                  t.isCSS3DSprite
                    ? (cZ.copy(n.matrixWorldInverse),
                      cZ.transpose(),
                      0 !== t.rotation2D &&
                        cZ.multiply(cQ.makeRotationZ(t.rotation2D)),
                      t.matrixWorld.decompose(cJ, cY, cK),
                      cZ.setPosition(cJ),
                      cZ.scale(cK),
                      (cZ.elements[3] = 0),
                      (cZ.elements[7] = 0),
                      (cZ.elements[11] = 0),
                      (cZ.elements[15] = 1),
                      (e = d(cZ)))
                    : (e = d(t.matrixWorld));
                let o = a.objects.get(t);
                if (void 0 === o || o.style !== e) {
                  r.style.transform = e;
                  let i = { style: e };
                  a.objects.set(t, i);
                }
                r.parentNode !== h && h.appendChild(r),
                  t.onAfterRender(s, i, n);
              }
            }
            for (let s = 0, a = t.children.length; s < a; s++)
              e(t.children[s], i, n, r);
          })(e, e, o, _);
      }),
      (this.setSize = function (e, s) {
        (t = e),
          (i = s),
          (n = t / 2),
          (r = i / 2),
          (o.style.width = e + "px"),
          (o.style.height = s + "px"),
          (l.style.width = e + "px"),
          (l.style.height = s + "px"),
          (h.style.width = e + "px"),
          (h.style.height = s + "px");
      });
  }
})();
c1.setSize(window.innerWidth, window.innerHeight),
  (c1.domElement.style.position = "absolute"),
  (c1.domElement.style.top = "0"),
  (c1.domElement.style.zIndex = "-1"),
  document.body.appendChild(c1.domElement);
const c2 = document.getElementById("backButton"),
  c3 = document.getElementById("ui-card"),
  c5 = new ci();
c0.setClearColor(10542847);
const c4 = new (class extends te {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.backgroundRotation = new eq()),
        (this.environmentIntensity = 1),
        (this.environmentRotation = new eq()),
        (this.overrideMaterial = null),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        null !== e.background && (this.background = e.background.clone()),
        null !== e.environment && (this.environment = e.environment.clone()),
        null !== e.fog && (this.fog = e.fog.clone()),
        (this.backgroundBlurriness = e.backgroundBlurriness),
        (this.backgroundIntensity = e.backgroundIntensity),
        this.backgroundRotation.copy(e.backgroundRotation),
        (this.environmentIntensity = e.environmentIntensity),
        this.environmentRotation.copy(e.environmentRotation),
        null !== e.overrideMaterial &&
          (this.overrideMaterial = e.overrideMaterial.clone()),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this
      );
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return (
        null !== this.fog && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (t.object.backgroundBlurriness = this.backgroundBlurriness),
        1 !== this.backgroundIntensity &&
          (t.object.backgroundIntensity = this.backgroundIntensity),
        (t.object.backgroundRotation = this.backgroundRotation.toArray()),
        1 !== this.environmentIntensity &&
          (t.object.environmentIntensity = this.environmentIntensity),
        (t.object.environmentRotation = this.environmentRotation.toArray()),
        t
      );
    }
  })(),
  c6 = new t7(45, window.innerWidth / window.innerHeight, 0.1, 1e3),
  c7 = new (class extends a8 {
    constructor(e, t = null) {
      super(e, t),
        (this.state = hQ.NONE),
        (this.enabled = !0),
        (this.target = new eo()),
        (this.cursor = new eo()),
        (this.minDistance = 0),
        (this.maxDistance = 1 / 0),
        (this.minZoom = 0),
        (this.maxZoom = 1 / 0),
        (this.minTargetRadius = 0),
        (this.maxTargetRadius = 1 / 0),
        (this.minPolarAngle = 0),
        (this.maxPolarAngle = Math.PI),
        (this.minAzimuthAngle = -1 / 0),
        (this.maxAzimuthAngle = 1 / 0),
        (this.enableDamping = !1),
        (this.dampingFactor = 0.05),
        (this.enableZoom = !0),
        (this.zoomSpeed = 1),
        (this.enableRotate = !0),
        (this.rotateSpeed = 1),
        (this.enablePan = !0),
        (this.panSpeed = 1),
        (this.screenSpacePanning = !0),
        (this.keyPanSpeed = 7),
        (this.zoomToCursor = !1),
        (this.autoRotate = !1),
        (this.autoRotateSpeed = 2),
        (this.keys = {
          LEFT: "ArrowLeft",
          UP: "ArrowUp",
          RIGHT: "ArrowRight",
          BOTTOM: "ArrowDown",
        }),
        (this.mouseButtons = { LEFT: p.ROTATE, MIDDLE: p.DOLLY, RIGHT: p.PAN }),
        (this.touches = { ONE: m.ROTATE, TWO: m.DOLLY_PAN }),
        (this.target0 = this.target.clone()),
        (this.position0 = this.object.position.clone()),
        (this.zoom0 = this.object.zoom),
        (this._domElementKeyEvents = null),
        (this._lastPosition = new eo()),
        (this._lastQuaternion = new ea()),
        (this._lastTargetPosition = new eo()),
        (this._quat = new ea().setFromUnitVectors(e.up, new eo(0, 1, 0))),
        (this._quatInverse = this._quat.clone().invert()),
        (this._spherical = new a7()),
        (this._sphericalDelta = new a7()),
        (this._scale = 1),
        (this._panOffset = new eo()),
        (this._rotateStart = new U()),
        (this._rotateEnd = new U()),
        (this._rotateDelta = new U()),
        (this._panStart = new U()),
        (this._panEnd = new U()),
        (this._panDelta = new U()),
        (this._dollyStart = new U()),
        (this._dollyEnd = new U()),
        (this._dollyDelta = new U()),
        (this._dollyDirection = new eo()),
        (this._mouse = new U()),
        (this._performCursorZoom = !1),
        (this._pointers = []),
        (this._pointerPositions = {}),
        (this._controlActive = !1),
        (this._onPointerMove = h0.bind(this)),
        (this._onPointerDown = h$.bind(this)),
        (this._onPointerUp = h1.bind(this)),
        (this._onContextMenu = h8.bind(this)),
        (this._onMouseWheel = h5.bind(this)),
        (this._onKeyDown = h4.bind(this)),
        (this._onTouchStart = h6.bind(this)),
        (this._onTouchMove = h7.bind(this)),
        (this._onMouseDown = h2.bind(this)),
        (this._onMouseMove = h3.bind(this)),
        (this._interceptControlDown = h9.bind(this)),
        (this._interceptControlUp = ce.bind(this)),
        null !== this.domElement && this.connect(),
        this.update();
    }
    connect() {
      this.domElement.addEventListener("pointerdown", this._onPointerDown),
        this.domElement.addEventListener("pointercancel", this._onPointerUp),
        this.domElement.addEventListener("contextmenu", this._onContextMenu),
        this.domElement.addEventListener("wheel", this._onMouseWheel, {
          passive: !1,
        }),
        this.domElement
          .getRootNode()
          .addEventListener("keydown", this._interceptControlDown, {
            passive: !0,
            capture: !0,
          }),
        (this.domElement.style.touchAction = "none");
    }
    disconnect() {
      this.domElement.removeEventListener("pointerdown", this._onPointerDown),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.domElement.removeEventListener("pointercancel", this._onPointerUp),
        this.domElement.removeEventListener("wheel", this._onMouseWheel),
        this.domElement.removeEventListener("contextmenu", this._onContextMenu),
        this.stopListenToKeyEvents(),
        this.domElement
          .getRootNode()
          .removeEventListener("keydown", this._interceptControlDown, {
            capture: !0,
          }),
        (this.domElement.style.touchAction = "auto");
    }
    dispose() {
      this.disconnect();
    }
    getPolarAngle() {
      return this._spherical.phi;
    }
    getAzimuthalAngle() {
      return this._spherical.theta;
    }
    getDistance() {
      return this.object.position.distanceTo(this.target);
    }
    listenToKeyEvents(e) {
      e.addEventListener("keydown", this._onKeyDown),
        (this._domElementKeyEvents = e);
    }
    stopListenToKeyEvents() {
      null !== this._domElementKeyEvents &&
        (this._domElementKeyEvents.removeEventListener(
          "keydown",
          this._onKeyDown
        ),
        (this._domElementKeyEvents = null));
    }
    saveState() {
      this.target0.copy(this.target),
        this.position0.copy(this.object.position),
        (this.zoom0 = this.object.zoom);
    }
    reset() {
      this.target.copy(this.target0),
        this.object.position.copy(this.position0),
        (this.object.zoom = this.zoom0),
        this.object.updateProjectionMatrix(),
        this.dispatchEvent(hW),
        this.update(),
        (this.state = hQ.NONE);
    }
    update(e = null) {
      let t = this.object.position;
      hK.copy(t).sub(this.target),
        hK.applyQuaternion(this._quat),
        this._spherical.setFromVector3(hK),
        this.autoRotate &&
          this.state === hQ.NONE &&
          this._rotateLeft(this._getAutoRotationAngle(e)),
        this.enableDamping
          ? ((this._spherical.theta +=
              this._sphericalDelta.theta * this.dampingFactor),
            (this._spherical.phi +=
              this._sphericalDelta.phi * this.dampingFactor))
          : ((this._spherical.theta += this._sphericalDelta.theta),
            (this._spherical.phi += this._sphericalDelta.phi));
      let i = this.minAzimuthAngle,
        n = this.maxAzimuthAngle;
      isFinite(i) &&
        isFinite(n) &&
        (i < -Math.PI ? (i += hZ) : i > Math.PI && (i -= hZ),
        n < -Math.PI ? (n += hZ) : n > Math.PI && (n -= hZ),
        i <= n
          ? (this._spherical.theta = Math.max(
              i,
              Math.min(n, this._spherical.theta)
            ))
          : (this._spherical.theta =
              this._spherical.theta > (i + n) / 2
                ? Math.max(i, this._spherical.theta)
                : Math.min(n, this._spherical.theta))),
        (this._spherical.phi = Math.max(
          this.minPolarAngle,
          Math.min(this.maxPolarAngle, this._spherical.phi)
        )),
        this._spherical.makeSafe(),
        !0 === this.enableDamping
          ? this.target.addScaledVector(this._panOffset, this.dampingFactor)
          : this.target.add(this._panOffset),
        this.target.sub(this.cursor),
        this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
        this.target.add(this.cursor);
      let r = !1;
      if (
        (this.zoomToCursor && this._performCursorZoom) ||
        this.object.isOrthographicCamera
      )
        this._spherical.radius = this._clampDistance(this._spherical.radius);
      else {
        let e = this._spherical.radius;
        (this._spherical.radius = this._clampDistance(
          this._spherical.radius * this._scale
        )),
          (r = e != this._spherical.radius);
      }
      if (
        (hK.setFromSpherical(this._spherical),
        hK.applyQuaternion(this._quatInverse),
        t.copy(this.target).add(hK),
        this.object.lookAt(this.target),
        !0 === this.enableDamping
          ? ((this._sphericalDelta.theta *= 1 - this.dampingFactor),
            (this._sphericalDelta.phi *= 1 - this.dampingFactor),
            this._panOffset.multiplyScalar(1 - this.dampingFactor))
          : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)),
        this.zoomToCursor && this._performCursorZoom)
      ) {
        let e = null;
        if (this.object.isPerspectiveCamera) {
          let t = hK.length();
          e = this._clampDistance(t * this._scale);
          let i = t - e;
          this.object.position.addScaledVector(this._dollyDirection, i),
            this.object.updateMatrixWorld(),
            (r = !!i);
        } else if (this.object.isOrthographicCamera) {
          let t = new eo(this._mouse.x, this._mouse.y, 0);
          t.unproject(this.object);
          let i = this.object.zoom;
          (this.object.zoom = Math.max(
            this.minZoom,
            Math.min(this.maxZoom, this.object.zoom / this._scale)
          )),
            this.object.updateProjectionMatrix(),
            (r = i !== this.object.zoom);
          let n = new eo(this._mouse.x, this._mouse.y, 0);
          n.unproject(this.object),
            this.object.position.sub(n).add(t),
            this.object.updateMatrixWorld(),
            (e = hK.length());
        } else
          console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
          ),
            (this.zoomToCursor = !1);
        null !== e &&
          (this.screenSpacePanning
            ? this.target
                .set(0, 0, -1)
                .transformDirection(this.object.matrix)
                .multiplyScalar(e)
                .add(this.object.position)
            : (hq.origin.copy(this.object.position),
              hq.direction.set(0, 0, -1).transformDirection(this.object.matrix),
              Math.abs(this.object.up.dot(hq.direction)) < hY
                ? this.object.lookAt(this.target)
                : (hJ.setFromNormalAndCoplanarPoint(
                    this.object.up,
                    this.target
                  ),
                  hq.intersectPlane(hJ, this.target))));
      } else if (this.object.isOrthographicCamera) {
        let e = this.object.zoom;
        (this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / this._scale)
        )),
          e !== this.object.zoom &&
            (this.object.updateProjectionMatrix(), (r = !0));
      }
      return (
        (this._scale = 1),
        (this._performCursorZoom = !1),
        !!(
          r ||
          this._lastPosition.distanceToSquared(this.object.position) > 1e-6 ||
          8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > 1e-6 ||
          this._lastTargetPosition.distanceToSquared(this.target) > 1e-6
        ) &&
          (this.dispatchEvent(hW),
          this._lastPosition.copy(this.object.position),
          this._lastQuaternion.copy(this.object.quaternion),
          this._lastTargetPosition.copy(this.target),
          !0)
      );
    }
    _getAutoRotationAngle(e) {
      return null !== e
        ? (hZ / 60) * this.autoRotateSpeed * e
        : (hZ / 60 / 60) * this.autoRotateSpeed;
    }
    _getZoomScale(e) {
      return Math.pow(0.95, this.zoomSpeed * Math.abs(0.01 * e));
    }
    _rotateLeft(e) {
      this._sphericalDelta.theta -= e;
    }
    _rotateUp(e) {
      this._sphericalDelta.phi -= e;
    }
    _panLeft(e, t) {
      hK.setFromMatrixColumn(t, 0),
        hK.multiplyScalar(-e),
        this._panOffset.add(hK);
    }
    _panUp(e, t) {
      !0 === this.screenSpacePanning
        ? hK.setFromMatrixColumn(t, 1)
        : (hK.setFromMatrixColumn(t, 0), hK.crossVectors(this.object.up, hK)),
        hK.multiplyScalar(e),
        this._panOffset.add(hK);
    }
    _pan(e, t) {
      let i = this.domElement;
      if (this.object.isPerspectiveCamera) {
        let n = this.object.position;
        hK.copy(n).sub(this.target);
        let r = hK.length();
        (r *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
          this._panLeft((2 * e * r) / i.clientHeight, this.object.matrix),
          this._panUp((2 * t * r) / i.clientHeight, this.object.matrix);
      } else
        this.object.isOrthographicCamera
          ? (this._panLeft(
              (e * (this.object.right - this.object.left)) /
                this.object.zoom /
                i.clientWidth,
              this.object.matrix
            ),
            this._panUp(
              (t * (this.object.top - this.object.bottom)) /
                this.object.zoom /
                i.clientHeight,
              this.object.matrix
            ))
          : (console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
            ),
            (this.enablePan = !1));
    }
    _dollyOut(e) {
      this.object.isPerspectiveCamera || this.object.isOrthographicCamera
        ? (this._scale /= e)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (this.enableZoom = !1));
    }
    _dollyIn(e) {
      this.object.isPerspectiveCamera || this.object.isOrthographicCamera
        ? (this._scale *= e)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (this.enableZoom = !1));
    }
    _updateZoomParameters(e, t) {
      if (!this.zoomToCursor) return;
      this._performCursorZoom = !0;
      let i = this.domElement.getBoundingClientRect(),
        n = e - i.left,
        r = t - i.top,
        s = i.width,
        a = i.height;
      (this._mouse.x = (n / s) * 2 - 1),
        (this._mouse.y = -((r / a) * 2) + 1),
        this._dollyDirection
          .set(this._mouse.x, this._mouse.y, 1)
          .unproject(this.object)
          .sub(this.object.position)
          .normalize();
    }
    _clampDistance(e) {
      return Math.max(this.minDistance, Math.min(this.maxDistance, e));
    }
    _handleMouseDownRotate(e) {
      this._rotateStart.set(e.clientX, e.clientY);
    }
    _handleMouseDownDolly(e) {
      this._updateZoomParameters(e.clientX, e.clientX),
        this._dollyStart.set(e.clientX, e.clientY);
    }
    _handleMouseDownPan(e) {
      this._panStart.set(e.clientX, e.clientY);
    }
    _handleMouseMoveRotate(e) {
      this._rotateEnd.set(e.clientX, e.clientY),
        this._rotateDelta
          .subVectors(this._rotateEnd, this._rotateStart)
          .multiplyScalar(this.rotateSpeed);
      let t = this.domElement;
      this._rotateLeft((hZ * this._rotateDelta.x) / t.clientHeight),
        this._rotateUp((hZ * this._rotateDelta.y) / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd),
        this.update();
    }
    _handleMouseMoveDolly(e) {
      this._dollyEnd.set(e.clientX, e.clientY),
        this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
        this._dollyDelta.y > 0
          ? this._dollyOut(this._getZoomScale(this._dollyDelta.y))
          : this._dollyDelta.y < 0 &&
            this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
        this._dollyStart.copy(this._dollyEnd),
        this.update();
    }
    _handleMouseMovePan(e) {
      this._panEnd.set(e.clientX, e.clientY),
        this._panDelta
          .subVectors(this._panEnd, this._panStart)
          .multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd),
        this.update();
    }
    _handleMouseWheel(e) {
      this._updateZoomParameters(e.clientX, e.clientY),
        e.deltaY < 0
          ? this._dollyIn(this._getZoomScale(e.deltaY))
          : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
        this.update();
    }
    _handleKeyDown(e) {
      let t = !1;
      switch (e.code) {
        case this.keys.UP:
          e.ctrlKey || e.metaKey || e.shiftKey
            ? this._rotateUp(
                (hZ * this.rotateSpeed) / this.domElement.clientHeight
              )
            : this._pan(0, this.keyPanSpeed),
            (t = !0);
          break;
        case this.keys.BOTTOM:
          e.ctrlKey || e.metaKey || e.shiftKey
            ? this._rotateUp(
                (-hZ * this.rotateSpeed) / this.domElement.clientHeight
              )
            : this._pan(0, -this.keyPanSpeed),
            (t = !0);
          break;
        case this.keys.LEFT:
          e.ctrlKey || e.metaKey || e.shiftKey
            ? this._rotateLeft(
                (hZ * this.rotateSpeed) / this.domElement.clientHeight
              )
            : this._pan(this.keyPanSpeed, 0),
            (t = !0);
          break;
        case this.keys.RIGHT:
          e.ctrlKey || e.metaKey || e.shiftKey
            ? this._rotateLeft(
                (-hZ * this.rotateSpeed) / this.domElement.clientHeight
              )
            : this._pan(-this.keyPanSpeed, 0),
            (t = !0);
      }
      t && (e.preventDefault(), this.update());
    }
    _handleTouchStartRotate(e) {
      if (1 === this._pointers.length) this._rotateStart.set(e.pageX, e.pageY);
      else {
        let t = this._getSecondPointerPosition(e),
          i = 0.5 * (e.pageX + t.x),
          n = 0.5 * (e.pageY + t.y);
        this._rotateStart.set(i, n);
      }
    }
    _handleTouchStartPan(e) {
      if (1 === this._pointers.length) this._panStart.set(e.pageX, e.pageY);
      else {
        let t = this._getSecondPointerPosition(e),
          i = 0.5 * (e.pageX + t.x),
          n = 0.5 * (e.pageY + t.y);
        this._panStart.set(i, n);
      }
    }
    _handleTouchStartDolly(e) {
      let t = this._getSecondPointerPosition(e),
        i = e.pageX - t.x,
        n = e.pageY - t.y;
      this._dollyStart.set(0, Math.sqrt(i * i + n * n));
    }
    _handleTouchStartDollyPan(e) {
      this.enableZoom && this._handleTouchStartDolly(e),
        this.enablePan && this._handleTouchStartPan(e);
    }
    _handleTouchStartDollyRotate(e) {
      this.enableZoom && this._handleTouchStartDolly(e),
        this.enableRotate && this._handleTouchStartRotate(e);
    }
    _handleTouchMoveRotate(e) {
      if (1 == this._pointers.length) this._rotateEnd.set(e.pageX, e.pageY);
      else {
        let t = this._getSecondPointerPosition(e),
          i = 0.5 * (e.pageX + t.x),
          n = 0.5 * (e.pageY + t.y);
        this._rotateEnd.set(i, n);
      }
      this._rotateDelta
        .subVectors(this._rotateEnd, this._rotateStart)
        .multiplyScalar(this.rotateSpeed);
      let t = this.domElement;
      this._rotateLeft((hZ * this._rotateDelta.x) / t.clientHeight),
        this._rotateUp((hZ * this._rotateDelta.y) / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd);
    }
    _handleTouchMovePan(e) {
      if (1 === this._pointers.length) this._panEnd.set(e.pageX, e.pageY);
      else {
        let t = this._getSecondPointerPosition(e),
          i = 0.5 * (e.pageX + t.x),
          n = 0.5 * (e.pageY + t.y);
        this._panEnd.set(i, n);
      }
      this._panDelta
        .subVectors(this._panEnd, this._panStart)
        .multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd);
    }
    _handleTouchMoveDolly(e) {
      let t = this._getSecondPointerPosition(e),
        i = e.pageX - t.x,
        n = e.pageY - t.y;
      this._dollyEnd.set(0, Math.sqrt(i * i + n * n)),
        this._dollyDelta.set(
          0,
          Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)
        ),
        this._dollyOut(this._dollyDelta.y),
        this._dollyStart.copy(this._dollyEnd);
      let r = (e.pageX + t.x) * 0.5,
        s = (e.pageY + t.y) * 0.5;
      this._updateZoomParameters(r, s);
    }
    _handleTouchMoveDollyPan(e) {
      this.enableZoom && this._handleTouchMoveDolly(e),
        this.enablePan && this._handleTouchMovePan(e);
    }
    _handleTouchMoveDollyRotate(e) {
      this.enableZoom && this._handleTouchMoveDolly(e),
        this.enableRotate && this._handleTouchMoveRotate(e);
    }
    _addPointer(e) {
      this._pointers.push(e.pointerId);
    }
    _removePointer(e) {
      delete this._pointerPositions[e.pointerId];
      for (let t = 0; t < this._pointers.length; t++)
        if (this._pointers[t] == e.pointerId) {
          this._pointers.splice(t, 1);
          return;
        }
    }
    _isTrackingPointer(e) {
      for (let t = 0; t < this._pointers.length; t++)
        if (this._pointers[t] == e.pointerId) return !0;
      return !1;
    }
    _trackPointer(e) {
      let t = this._pointerPositions[e.pointerId];
      void 0 === t &&
        ((t = new U()), (this._pointerPositions[e.pointerId] = t)),
        t.set(e.pageX, e.pageY);
    }
    _getSecondPointerPosition(e) {
      let t =
        e.pointerId === this._pointers[0]
          ? this._pointers[1]
          : this._pointers[0];
      return this._pointerPositions[t];
    }
    _customWheelEvent(e) {
      let t = e.deltaMode,
        i = { clientX: e.clientX, clientY: e.clientY, deltaY: e.deltaY };
      switch (t) {
        case 1:
          i.deltaY *= 16;
          break;
        case 2:
          i.deltaY *= 100;
      }
      return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
    }
  })(c6, c0.domElement);
c7.update();
let c8 = new eo(250, 200, 230),
  c9 = new eo(-25, -30, -50);
c6.position.copy(c8), c6.lookAt(c9);
const ue = new (class {
    constructor() {
      (this.entities = []),
        (this.spatialIndex = null),
        (this._triggers = []),
        (this._indexMap = new Map()),
        (this._typesMap = new Map()),
        (this._messageDispatcher = new oi());
    }
    add(e) {
      return this.entities.push(e), (e.manager = this), this;
    }
    remove(e) {
      let t = this.entities.indexOf(e);
      return this.entities.splice(t, 1), (e.manager = null), this;
    }
    clear() {
      return (this.entities.length = 0), this._messageDispatcher.clear(), this;
    }
    getEntityByName(e) {
      let t = this.entities;
      for (let i = 0, n = t.length; i < n; i++) {
        let n = t[i];
        if (n.name === e) return n;
      }
      return null;
    }
    update(e) {
      let t = this.entities,
        i = this._triggers;
      for (let i = t.length - 1; i >= 0; i--) {
        let n = t[i];
        this.updateEntity(n, e);
      }
      for (let e = i.length - 1; e >= 0; e--) {
        let t = i[e];
        this.processTrigger(t);
      }
      return (
        (this._triggers.length = 0),
        this._messageDispatcher.dispatchDelayedMessages(e),
        this
      );
    }
    updateEntity(e, t) {
      if (!0 === e.active) {
        this.updateNeighborhood(e),
          !1 === e._started && (e.start(), (e._started = !0)),
          e.update(t);
        let i = e.children;
        for (let e = i.length - 1; e >= 0; e--) {
          let n = i[e];
          this.updateEntity(n, t);
        }
        if (
          (e instanceof lX && this._triggers.push(e),
          null !== this.spatialIndex)
        ) {
          let t = this._indexMap.get(e) || -1;
          (t = this.spatialIndex.updateEntity(e, t)), this._indexMap.set(e, t);
        }
        let n = e._renderComponent,
          r = e._renderComponentCallback;
        null !== n && null !== r && r(e, n);
      }
      return this;
    }
    updateNeighborhood(e) {
      if (!0 === e.updateNeighborhood) {
        (e.neighbors.length = 0),
          null !== this.spatialIndex
            ? this.spatialIndex.query(e.position, e.neighborhoodRadius, lj)
            : ((lj.length = 0), lj.push(...this.entities));
        let t = e.neighborhoodRadius * e.neighborhoodRadius;
        for (let i = 0, n = lj.length; i < n; i++) {
          let n = lj[i];
          e !== n &&
            !0 === n.active &&
            e.position.squaredDistanceTo(n.position) <= t &&
            e.neighbors.push(n);
        }
      }
      return this;
    }
    processTrigger(e) {
      e.updateRegion();
      let t = this.entities;
      for (let i = t.length - 1; i >= 0; i--) {
        let n = t[i];
        e !== n && !0 === n.active && !0 === n.canActivateTrigger && e.check(n);
      }
      return this;
    }
    sendMessage(e, t, i, n, r) {
      return this._messageDispatcher.dispatch(e, t, i, n, r), this;
    }
    toJSON() {
      let e = {
        type: this.constructor.name,
        entities: [],
        _messageDispatcher: this._messageDispatcher.toJSON(),
      };
      for (let t = 0, i = this.entities.length; t < i; t++)
        !(function t(i) {
          e.entities.push(i.toJSON());
          for (let e = 0, n = i.children.length; e < n; e++) t(i.children[e]);
        })(this.entities[t]);
      return e;
    }
    fromJSON(e) {
      this.clear();
      let t = e.entities,
        i = e._messageDispatcher,
        n = new Map();
      for (let e = 0, i = t.length; e < i; e++) {
        let i;
        let r = t[e],
          s = r.type;
        switch (s) {
          case "GameEntity":
            i = new oE().fromJSON(r);
            break;
          case "MovingEntity":
            i = new oC().fromJSON(r);
            break;
          case "Vehicle":
            i = new lF().fromJSON(r);
            break;
          case "Trigger":
            i = new lX().fromJSON(r);
            break;
          default:
            let a = this._typesMap.get(s);
            if (void 0 !== a) i = new a().fromJSON(r);
            else {
              oe.warn("YUKA.EntityManager: Unsupported entity type:", s);
              continue;
            }
        }
        n.set(i.uuid, i), null === i.parent && this.add(i);
      }
      for (let e of n.values()) e.resolveReferences(n);
      return this._messageDispatcher.fromJSON(i), this;
    }
    registerType(e, t) {
      return this._typesMap.set(e, t), this;
    }
  })(),
  ut = [],
  ui = new (class {
    constructor() {
      (this._previousTime = 0),
        (this._currentTime = 0),
        (this._delta = 0),
        (this._elapsed = 0),
        (this._timescale = 1),
        (this._useFixedDelta = !1),
        (this._fixedDelta = 16.67),
        (this._usePageVisibilityAPI =
          "undefined" != typeof document && void 0 !== document.hidden),
        !0 === this._usePageVisibilityAPI &&
          ((this._pageVisibilityHandler = lZ.bind(this)),
          document.addEventListener(
            "visibilitychange",
            this._pageVisibilityHandler,
            !1
          ));
    }
    disableFixedDelta() {
      return (this._useFixedDelta = !1), this;
    }
    dispose() {
      return (
        !0 === this._usePageVisibilityAPI &&
          document.removeEventListener(
            "visibilitychange",
            this._pageVisibilityHandler
          ),
        this
      );
    }
    enableFixedDelta() {
      return (this._useFixedDelta = !0), this;
    }
    getDelta() {
      return this._delta / 1e3;
    }
    getElapsed() {
      return this._elapsed / 1e3;
    }
    getFixedDelta() {
      return this._fixedDelta / 1e3;
    }
    getTimescale() {
      return this._timescale;
    }
    reset() {
      return (this._currentTime = this._now()), this;
    }
    setFixedDelta(e) {
      return (this._fixedDelta = 1e3 * e), this;
    }
    setTimescale(e) {
      return (this._timescale = e), this;
    }
    update() {
      return (
        !0 === this._useFixedDelta
          ? (this._delta = this._fixedDelta)
          : ((this._previousTime = this._currentTime),
            (this._currentTime = this._now()),
            (this._delta = this._currentTime - this._previousTime)),
        (this._delta *= this._timescale),
        (this._elapsed += this._delta),
        this
      );
    }
    _now() {
      return ("undefined" == typeof performance ? Date : performance).now();
    }
  })();
function un(e, t) {
  t.matrix.copy(e.worldMatrix);
}
function ur(e, t = 6) {
  let i = new lF(),
    n = new oq();
  e.forEach((e) => n.add(new os(e.x, e.y, e.z))),
    (n.loop = !0),
    i.position.copy(n.current()),
    (i.maxSpeed = t);
  let r = new oJ(n, 0.5);
  i.steering.add(r);
  let s = new hG(n);
  i.steering.add(s),
    ue.add(i),
    ut.push(i),
    c5.load(
      "./public/assets/car.glb",
      function (e) {
        let t = e.scene.clone();
        (t.matrixAutoUpdate = !1), c4.add(t), i.setRenderComponent(t, un);
      },
      void 0,
      function (e) {
        console.error(e);
      }
    );
}
const us = new lF(),
  ua = new oq();
ua.add(new os(90, 0, 77.5)),
  ua.add(new os(-62, 0, 76.5)),
  ua.add(new os(-74, 0, 73.5)),
  ua.add(new os(-82, 0, 67.5)),
  ua.add(new os(-87, 0, 57.5)),
  ua.add(new os(-89, 0, 47.5)),
  ua.add(new os(-89.5, 0, 45.5)),
  ua.add(new os(-90, 0, -110)),
  us.position.copy(ua.current()),
  (us.maxSpeed = 6);
const uo = new oJ(ua, 0.5);
us.steering.add(uo);
const ul = new hG(ua);
function uh(e, t = 8) {
  let i = new lF(),
    n = new oq();
  e.forEach((e) => n.add(new os(e.x, e.y, e.z))),
    (n.loop = !0),
    i.position.copy(n.current()),
    (i.maxSpeed = t);
  let r = new oJ(n, 0.5);
  i.steering.add(r);
  let s = new hG(n);
  i.steering.add(s),
    ue.add(i),
    ut.push(i),
    c5.load(
      "./public/assets/drone.glb",
      function (e) {
        let t = e.scene.clone();
        (t.matrixAutoUpdate = !1),
          (t.rotation.y = Math.PI / 2),
          c4.add(t),
          (i.scale = new os(2, 2, 2)),
          i.setRenderComponent(t, un);
      },
      void 0,
      function (e) {
        console.error(e);
      }
    );
}
us.steering.add(ul),
  ue.add(us),
  c5.load(
    "./public/assets/train.glb",
    function (e) {
      let t = e.scene;
      c4.add(t),
        (t.matrixAutoUpdate = !1),
        (us.scale = new os(1.5, 1.5, 1.5)),
        us.setRenderComponent(t, un);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  ur([
    { x: 105, y: -7.5, z: 23.8 },
    { x: 34, y: -7.5, z: 23.8 },
    { x: 34, y: -7.5, z: 80 },
    { x: 28, y: -7.5, z: 80 },
    { x: 28, y: -7.5, z: -60.5 },
    { x: -28, y: -7.5, z: -60.5 },
    { x: -28, y: -7.5, z: 23.8 },
    { x: -100, y: -7.5, z: 23.8 },
  ]),
  ur([
    { x: -105, y: -7.5, z: 17.8 },
    { x: -28, y: -7.5, z: 17.8 },
    { x: -28, y: -7.5, z: 80.8 },
    { x: -32, y: -7.5, z: 80.8 },
    { x: -32, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: -60.5 },
    { x: -32, y: -7.5, z: -60.5 },
    { x: -32, y: -7.5, z: -120 },
    { x: -28, y: -7.5, z: -120 },
    { x: -28, y: -7.5, z: 23.8 },
    { x: -105, y: -7.5, z: 23.8 },
  ]),
  ur([
    { x: -105, y: -7.5, z: -66 },
    { x: -28, y: -7.5, z: -66 },
    { x: -28, y: -7.5, z: 80.8 },
    { x: -34, y: -7.5, z: 80.8 },
    { x: -34, y: -7.5, z: 17.8 },
    { x: 105, y: -7.5, z: 17.8 },
    { x: 105, y: -7.5, z: 23.8 },
    { x: 28, y: -7.5, z: 23.8 },
    { x: 28, y: -7.5, z: -61 },
    { x: -105, y: -7.5, z: -61 },
  ]),
  ur([
    { x: 105, y: -7.5, z: -61 },
    { x: -28, y: -7.5, z: -61 },
    { x: -28, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: -66 },
    { x: 105, y: -7.5, z: -66 },
  ]),
  ur([
    { x: 0, y: -7.5, z: -61 },
    { x: -28, y: -7.5, z: -61 },
    { x: -28, y: -7.5, z: 23.8 },
    { x: -105, y: -7.5, z: 23.8 },
    { x: -105, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: -120 },
    { x: 33, y: -7.5, z: -120 },
    { x: 33, y: -7.5, z: -61 },
  ]),
  ur([
    { x: 0, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: 17.8 },
    { x: 28, y: -7.5, z: -120 },
    { x: 33, y: -7.5, z: -120 },
    { x: 33, y: -7.5, z: -66 },
    { x: 105, y: -7.5, z: -66 },
    { x: 105, y: -7.5, z: -61 },
    { x: -105, y: -7.5, z: -61 },
    { x: -105, y: -7.5, z: -66 },
    { x: -28, y: -7.5, z: -66 },
    { x: -28, y: -7.5, z: 17.8 },
  ]),
  uh([
    { x: 0, y: 50, z: 17.8 },
    { x: 28, y: 50, z: 17.8 },
    { x: 28, y: 50, z: -120 },
    { x: 33, y: 50, z: -120 },
    { x: 33, y: 50, z: -66 },
    { x: 105, y: 50, z: -66 },
    { x: 105, y: 50, z: -61 },
    { x: -105, y: 50, z: -61 },
    { x: -105, y: 50, z: -66 },
    { x: -28, y: 50, z: -66 },
    { x: -28, y: 50, z: 17.8 },
  ]),
  uh([
    { x: 0, y: 50, z: 30 },
    { x: 70, y: 50, z: 17.8 },
    { x: 28, y: 50, z: -50 },
    { x: -80, y: 50, z: -50 },
    { x: -80, y: 50, z: 70 },
    { x: 100, y: 50, z: 70 },
    { x: -100, y: 50, z: -100 },
    { x: 100, y: 50, z: -100 },
    { x: 100, y: 50, z: -50 },
  ]),
  uh([
    { x: -90, y: 50, z: 30 },
    { x: 70, y: 50, z: 17.8 },
    { x: -70, y: 40, z: -61.8 },
    { x: 100, y: 50, z: -81.8 },
    { x: 100, y: 40, z: -51.8 },
    { x: -80, y: 50, z: -51.8 },
    { x: -80, y: 50, z: 40.8 },
    { x: 80, y: 40, z: 40.8 },
    { x: 80, y: 50, z: -100.8 },
    { x: -90, y: 50, z: -100.8 },
  ]),
  (function (e) {
    let t = new ci();
    t.load(
      "./public/assets/apartment.glb",
      function (t) {
        let i = t.scene;
        e.add(i),
          i.scale.set(3, 3, 3),
          i.position.set(-55, -10, -5),
          (i.rotation.y = Math.PI);
      },
      void 0,
      function (e) {
        console.error(e);
      }
    ),
      t.load(
        "./public/assets/apartment.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(3, 3, 3),
            i.position.set(-55, -10, -38),
            (i.rotation.y = Math.PI);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/apartment.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(3, 3, 3),
            i.position.set(-55, -10, -90),
            (i.rotation.y = Math.PI);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/apartment.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(3, 3, 3),
            i.position.set(-55, -10, -120),
            (i.rotation.y = Math.PI);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/apartment2.glb",
        function (t) {
          let i = t.scene;
          e.add(i), i.scale.set(4, 4, 4), i.position.set(55, -10, 45);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/apartment2.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(4, 4, 4),
            i.position.set(88, -10, 45),
            (i.rotation.y = -(Math.PI / 2));
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/apartment2.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(4, 4, 4),
            i.position.set(55, -10, -90),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/apartment2.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(4, 4, 4),
            i.position.set(88, -10, -90),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/hospital.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(4, 4, 4),
            i.position.set(0, -10, -100),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/university.glb",
        function (t) {
          let i = t.scene;
          e.add(i), i.scale.set(3, 3, 3), i.position.set(75, -10, -18);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/taman.glb",
        function (t) {
          let i = t.scene;
          e.add(i), i.scale.set(1.5, 1.5, 1.5), i.position.set(0, -8, -18);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/tower-iot.glb",
        function (t) {
          let i = t.scene;
          e.add(i), i.scale.set(10, 10, 10), i.position.set(0, -8, -51.5);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/rumah.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(7, 7, 7),
            i.position.set(-50, -10, 45),
            (i.rotation.y = -(Math.PI / 2));
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/rumah.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(7, 7, 7),
            i.position.set(-65, -10, 45),
            (i.rotation.y = -(Math.PI / 2));
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/rumah.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(7, 7, 7),
            i.position.set(-80, -10, 45),
            (i.rotation.y = -(Math.PI / 2));
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/rumah.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(7, 7, 7),
            i.position.set(93, -10, -125),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/rumah.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(7, 7, 7),
            i.position.set(73, -10, -125),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/rumah.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(7, 7, 7),
            i.position.set(53, -10, -125),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/powerplant.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(1.3, 3, 1.3),
            i.position.set(0, -10, 45),
            (i.rotation.y = -(Math.PI / 2));
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/station.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(1.05, 2.05, 1.05),
            i.position.set(-20, -10, -10);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/jalan.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(1, 1, 1),
            i.position.set(0, -9, -25),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      ),
      t.load(
        "./public/assets/lampu.glb",
        function (t) {
          let i = t.scene;
          e.add(i),
            i.scale.set(5, 5, 5),
            i.position.set(0, -10, -56),
            (i.rotation.y = Math.PI / 2);
        },
        void 0,
        function (e) {
          console.error(e);
        }
      );
  })(c4),
  (function (e) {
    let t = new tY(new tZ(220, 8, 220), new tb({ color: 12578047, side: 2 }));
    t.position.set(0, -15, -25), e.add(t);
  })(c4),
  (function (e) {
    let t = new aj(0, 1);
    t.position.set(0, 0, 10), e.add(t);
    let i = new aq(4210752, 60);
    e.add(i);
  })(c4),
  c5.load(
    "./public/assets/Icon/Education.glb",
    function (e) {
      (i = e.scene),
        c4.add(i),
        (i.name = "icon"),
        i.scale.set(10, 10, 10),
        i.position.set(65, 35, -18);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/Education.glb",
    function (e) {
      (n = e.scene),
        c4.add(n),
        (n.name = "icon1"),
        n.scale.set(0, 0, 0),
        n.position.set(105, 35, -18);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/GreenPark.glb",
    function (e) {
      (r = e.scene),
        c4.add(r),
        (r.name = "icon2"),
        r.scale.set(10, 10, 10),
        r.position.set(0, 35, -18),
        (r.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/GreenBuilding.glb",
    function (e) {
      (s = e.scene),
        c4.add(s),
        (s.name = "icon3"),
        s.scale.set(10, 10, 10),
        s.position.set(70, 35, -90),
        (s.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/InternetOfThings.glb",
    function (e) {
      (a = e.scene),
        c4.add(a),
        (a.name = "icon4"),
        a.scale.set(10, 10, 10),
        a.position.set(0, 35, -51.5),
        (a.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/SmartEnergy.glb",
    function (e) {
      (o = e.scene),
        c4.add(o),
        (o.name = "icon5"),
        o.scale.set(10, 10, 10),
        o.position.set(0, 35, 44),
        (o.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/SmartTransportation.glb",
    function (e) {
      (l = e.scene),
        c4.add(l),
        (l.name = "icon6"),
        l.scale.set(10, 10, 10),
        l.position.set(80, 35, 78),
        (l.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/SmartBuilding.glb",
    function (e) {
      (h = e.scene),
        c4.add(h),
        (h.name = "icon7"),
        h.scale.set(10, 10, 10),
        h.position.set(-50, 35, -20),
        (h.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/SmartHealth.glb",
    function (e) {
      (c = e.scene),
        c4.add(c),
        (c.name = "icon8"),
        c.scale.set(10, 10, 10),
        c.position.set(0, 35, -94),
        (c.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/SmartHouse.glb",
    function (e) {
      (u = e.scene),
        c4.add(u),
        (u.name = "icon9"),
        u.scale.set(10, 10, 10),
        u.position.set(-65, 35, 44),
        (u.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  ),
  c5.load(
    "./public/assets/Icon/TrafficManagement.glb",
    function (e) {
      (d = e.scene),
        c4.add(d),
        (d.name = "icon10"),
        d.scale.set(10, 10, 10),
        d.position.set(29, 35, -61),
        (d.rotation.y = Math.PI);
    },
    void 0,
    function (e) {
      console.error(e);
    }
  );
let uc = !1,
  uu = new eo(),
  ud = new eo();
const up = new (class {
    constructor(e, t, i = 0, n = 1 / 0) {
      (this.ray = new eU(e, t)),
        (this.near = i),
        (this.far = n),
        (this.camera = null),
        (this.layers = new eJ()),
        (this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {},
        });
    }
    set(e, t) {
      this.ray.set(e, t);
    }
    setFromCamera(e, t) {
      t.isPerspectiveCamera
        ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
          this.ray.direction
            .set(e.x, e.y, 0.5)
            .unproject(t)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = t))
        : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    setFromXRController(e) {
      return (
        a5.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(a5),
        this
      );
    }
    intersectObject(e, t = !0, i = []) {
      return a6(e, this, i, t), i.sort(a4), i;
    }
    intersectObjects(e, t = !0, i = []) {
      for (let n = 0, r = e.length; n < r; n++) a6(e[n], this, i, t);
      return i.sort(a4), i;
    }
  })(),
  um = new U();
document.addEventListener("click", (e) => {
  (um.x = (e.clientX / window.innerWidth) * 2 - 1),
    (um.y = -((e.clientY / window.innerHeight) * 2) + 1),
    up.setFromCamera(um, c6);
  let t = up.intersectObjects([i, n, r, s, a, o, l, h, c, u, d], !0);
  t.length > 0 &&
    (function (e) {
      if (e) {
        switch (((uc = !0), (c7.enabled = !1), e.name)) {
          case "icon":
            uu.set(e.position.x - 40, e.position.y - 40, e.position.z - 20),
              ud.set(e.position.x, e.position.y - 35, e.position.z + 10);
            break;
          case "icon2":
            uu.set(e.position.x + 45, e.position.y - 30, e.position.z + 50),
              ud.set(e.position.x + 10, e.position.y - 40, e.position.z);
            break;
          case "icon3":
            uu.set(e.position.x - 30, e.position.y - 35, e.position.z + 47),
              ud.set(e.position.x, e.position.y - 35, e.position.z + 15);
            break;
          case "icon4":
            uu.set(e.position.x + 15, e.position.y - 15, e.position.z - 45),
              ud.set(e.position.x, e.position.y - 30, e.position.z);
            break;
          case "icon5":
            uu.set(e.position.x + 25, e.position.y - 28, e.position.z - 45),
              ud.set(e.position.x - 15, e.position.y - 35, e.position.z);
            break;
          case "icon6":
            uu.set(e.position.x - 20, e.position.y - 35, e.position.z + 35),
              ud.set(e.position.x, e.position.y - 35, e.position.z);
            break;
          case "icon7":
            uu.set(e.position.x + 25, e.position.y - 30, e.position.z + 45),
              ud.set(e.position.x, e.position.y - 30, e.position.z);
            break;
          case "icon8":
            uu.set(e.position.x + 2, e.position.y + -35, e.position.z + 35),
              ud.set(e.position.x + 10, e.position.y - 35, e.position.z);
            break;
          case "icon9":
            uu.set(e.position.x + 15, e.position.y - 35, e.position.z - 35),
              ud.set(e.position.x - 5, e.position.y - 40, e.position.z);
            break;
          case "icon10":
            uu.set(e.position.x + 10, e.position.y - 35, e.position.z + 40),
              ud.set(e.position.x, e.position.y - 40, e.position.z);
        }
        console.log("Zooming to icon:", e),
          console.log("Zooming to icon:", e.name),
          (function (e) {
            let t = c$[e];
            t
              ? ((document.getElementById("ui-header").textContent = t.title),
                (document.getElementById("ui-content").textContent =
                  t.description))
              : console.log("No data found for icon:", e);
          })(e.name),
          (c3.style.display = "block");
      }
    })(t[0].object.parent);
}),
  c2.addEventListener("click", () => {
    c6.position.copy(c8),
      c6.lookAt(c9),
      (c3.style.display = "none"),
      (c7.enabled = !0);
  }),
  (function e() {
    i &&
      n &&
      r &&
      s &&
      a &&
      o &&
      l &&
      h &&
      c &&
      c &&
      u &&
      d &&
      ((i.rotation.y += 0.02),
      (n.rotation.y += 0.02),
      (r.rotation.y += 0.02),
      (s.rotation.y += 0.02),
      (a.rotation.y += 0.02),
      (o.rotation.y += 0.02),
      (l.rotation.y += 0.02),
      (h.rotation.y += 0.02),
      (c.rotation.y += 0.02),
      (u.rotation.y += 0.02),
      (d.rotation.y += 0.02)),
      1 > us.position.distanceTo(ua._waypoints[ua._waypoints.length - 1]) &&
        (us.position.copy(ua._waypoints[0]), (ua._index = 0)),
      c0.render(c4, c6);
    let t = ui.update().getDelta();
    ue.update(t),
      uc &&
        (c6.position.lerp(uu, 0.5),
        c6.lookAt(ud),
        0.1 > c6.position.distanceTo(uu) && (uc = !1)),
      c1.render(c4, c6),
      c0.setAnimationLoop(e);
  })(),
  window.addEventListener("resize", function () {
    (c6.aspect = window.innerWidth / window.innerHeight),
      c6.updateProjectionMatrix(),
      c0.setSize(window.innerWidth, window.innerHeight),
      c1.setSize(window.innerWidth, window.innerHeight);
  });
//# sourceMappingURL=index.96a2c0d9.js.map
